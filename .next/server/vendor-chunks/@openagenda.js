/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openagenda";
exports.ids = ["vendor-chunks/@openagenda"];
exports.modules = {

/***/ "(ssr)/./node_modules/@openagenda/verror/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@openagenda/verror/dist/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.js\nvar src_exports = {};\n__export(src_exports, {\n  BadGateway: () => BadGateway,\n  BadRequest: () => BadRequest,\n  Conflict: () => Conflict,\n  Forbidden: () => Forbidden,\n  GeneralError: () => GeneralError,\n  Gone: () => Gone,\n  LengthRequired: () => LengthRequired,\n  MethodNotAllowed: () => MethodNotAllowed,\n  NotAcceptable: () => NotAcceptable,\n  NotAuthenticated: () => NotAuthenticated,\n  NotFound: () => NotFound,\n  NotImplemented: () => NotImplemented,\n  PaymentError: () => PaymentError,\n  Timeout: () => Timeout,\n  TooManyRequests: () => TooManyRequests,\n  Unavailable: () => Unavailable,\n  Unprocessable: () => Unprocessable,\n  VError: () => verror_default,\n  default: () => src_default\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/verror.js\nvar import_inherits = __toESM(__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\"));\nvar import_assertion_error2 = __toESM(__webpack_require__(/*! assertion-error */ \"(ssr)/./node_modules/assertion-error/index.js\"));\n\n// src/assert.js\nfunction isError(arg) {\n  return Object.prototype.toString.call(arg) === \"[object Error]\" || arg instanceof Error;\n}\nfunction isObject(arg) {\n  return typeof arg === \"object\" && arg !== null;\n}\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\nfunction isFunc(arg) {\n  return typeof arg === \"function\";\n}\n\n// src/parseConstructorArguments.js\nvar import_sprintf_js = __webpack_require__(/*! sprintf-js */ \"(ssr)/./node_modules/sprintf-js/src/sprintf.js\");\nvar import_assertion_error = __toESM(__webpack_require__(/*! assertion-error */ \"(ssr)/./node_modules/assertion-error/index.js\"));\nfunction parseConstructorArguments(...argv) {\n  let options;\n  let sprintfArgs;\n  if (argv.length === 0) {\n    options = {};\n    sprintfArgs = [];\n  } else if (isError(argv[0])) {\n    options = { cause: argv[0] };\n    sprintfArgs = argv.slice(1);\n  } else if (typeof argv[0] === \"object\") {\n    options = {};\n    for (const k in argv[0]) {\n      if (Object.prototype.hasOwnProperty.call(argv[0], k)) {\n        options[k] = argv[0][k];\n      }\n    }\n    sprintfArgs = argv.slice(1);\n  } else {\n    if (!isString(argv[0])) {\n      throw new import_assertion_error.default(\n        \"first argument to VError, or WError constructor must be a string, object, or Error\"\n      );\n    }\n    options = {};\n    sprintfArgs = argv;\n  }\n  if (!isObject(options))\n    throw new import_assertion_error.default(\"options (object) is required\");\n  if (options.meta && !isObject(options.meta))\n    throw new import_assertion_error.default(\"options.meta must be an object\");\n  return {\n    options,\n    shortMessage: sprintfArgs.length === 0 ? \"\" : import_sprintf_js.sprintf.apply(null, sprintfArgs)\n  };\n}\n\n// src/utils.js\nfunction defineProperty(target, descriptor) {\n  descriptor.enumerable = descriptor.enumerable || false;\n  descriptor.configurable = true;\n  if (\"value\" in descriptor)\n    descriptor.writable = true;\n  Object.defineProperty(target, descriptor.key, descriptor);\n}\nfunction defineProperties(target, props) {\n  for (let i = 0; i < props.length; i++) {\n    defineProperty(target, props[i]);\n  }\n}\n\n// src/verror.js\nvar META = \"@@verror/meta\";\nvar reserved = [\n  \"name\",\n  \"message\",\n  \"shortMessage\",\n  \"cause\",\n  \"info\",\n  \"stack\",\n  \"fileName\",\n  \"lineNumber\"\n];\nfunction mergeMeta(instance, meta2) {\n  if (!meta2) {\n    return;\n  }\n  for (const k in meta2) {\n    if (Object.prototype.hasOwnProperty.call(meta2, k)) {\n      if (reserved.includes(k)) {\n        throw new import_assertion_error2.default(`\"${k}\" is a reserved meta`);\n      }\n      instance[META][k] = meta2[k];\n      instance[k] = meta2[k];\n    }\n  }\n}\nfunction VError(...args) {\n  if (!(this instanceof VError)) {\n    return new VError(...args);\n  }\n  const { options, shortMessage } = parseConstructorArguments(...args);\n  const { cause: cause2, constructorOpt, info: info2, name, skipCauseMessage, meta: meta2 } = options;\n  let message = shortMessage;\n  if (cause2) {\n    if (!isError(cause2))\n      throw new import_assertion_error2.default(\"cause is not an Error\");\n    if (!skipCauseMessage && cause2.message) {\n      message = message === \"\" ? cause2.message : `${message}: ${cause2.message}`;\n    }\n  }\n  Error.call(this, message);\n  if (name) {\n    if (!isString(name))\n      throw new import_assertion_error2.default(`error's \"name\" must be a string`);\n    this.name = name;\n  }\n  this.message = message;\n  this.shortMessage = shortMessage;\n  if (cause2) {\n    this.cause = cause2;\n  }\n  this.info = {};\n  if (info2) {\n    for (const k in info2) {\n      if (Object.prototype.hasOwnProperty.call(info2, k)) {\n        this.info[k] = info2[k];\n      }\n    }\n  }\n  defineProperty(this, {\n    key: META,\n    value: {}\n  });\n  mergeMeta(this, VError.meta(this));\n  mergeMeta(this, meta2);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, constructorOpt || this.constructor);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n(0, import_inherits.default)(VError, Error);\ndefineProperties(VError.prototype, [\n  {\n    key: \"toString\",\n    value: function toString() {\n      let str = Object.prototype.hasOwnProperty.call(this, \"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n      if (this.message) {\n        str += `: ${this.message}`;\n      }\n      return str;\n    }\n  },\n  {\n    key: \"toJSON\",\n    value: function toJSON() {\n      const obj = {\n        name: this.name,\n        message: this.message,\n        shortMessage: this.shortMessage,\n        cause: this.cause,\n        info: this.info\n      };\n      for (const key in this[META]) {\n        if (Object.prototype.hasOwnProperty.call(this[META], key) && !(key in obj)) {\n          obj[key] = this[META][key];\n        }\n      }\n      return obj;\n    }\n  }\n]);\ndefineProperties(VError, [\n  {\n    key: \"cause\",\n    value: function cause(err) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      return isError(err.cause) ? err.cause : null;\n    }\n  },\n  {\n    key: \"info\",\n    value: function info(err) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      const cause2 = VError.cause(err);\n      const rv = cause2 !== null ? VError.info(cause2) : {};\n      if (isObject(err.info)) {\n        for (const k in err.info) {\n          if (Object.prototype.hasOwnProperty.call(err.info, k)) {\n            rv[k] = err.info[k];\n          }\n        }\n      }\n      return rv;\n    }\n  },\n  {\n    key: \"meta\",\n    value: function meta(err) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      const cause2 = VError.cause(err);\n      const rv = cause2 !== null ? VError.meta(cause2) : {};\n      if (isObject(err[META])) {\n        for (const k in err[META]) {\n          if (Object.prototype.hasOwnProperty.call(err[META], k)) {\n            rv[k] = err[META][k];\n          }\n        }\n      }\n      return rv;\n    }\n  },\n  {\n    key: \"findCauseByName\",\n    value: function findCauseByName(err, name) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      if (!isString(name))\n        throw new import_assertion_error2.default(\"name (string) is required\");\n      if (name.length <= 0)\n        throw new import_assertion_error2.default(\"name cannot be empty\");\n      for (let cause2 = err; cause2 !== null; cause2 = VError.cause(cause2)) {\n        if (!isError(err))\n          throw new import_assertion_error2.default(\"cause must be an Error\");\n        if (cause2.name === name) {\n          return cause2;\n        }\n      }\n      return null;\n    }\n  },\n  {\n    key: \"findCauseByType\",\n    value: function findCauseByType(err, type) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      if (!isFunc(type))\n        throw new import_assertion_error2.default(\"type (func) is required\");\n      for (let cause2 = err; cause2 !== null; cause2 = VError.cause(cause2)) {\n        if (!isError(err))\n          throw new import_assertion_error2.default(\"cause must be an Error\");\n        if (cause2 instanceof type) {\n          return cause2;\n        }\n      }\n      return null;\n    }\n  },\n  {\n    key: \"hasCauseWithName\",\n    value: function hasCauseWithName(err, name) {\n      return VError.findCauseByName(err, name) !== null;\n    }\n  },\n  {\n    key: \"hasCauseWithType\",\n    value: function hasCauseWithType(err, type) {\n      return VError.findCauseByType(err, type) !== null;\n    }\n  },\n  {\n    key: \"fullStack\",\n    value: function fullStack(err) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      const cause2 = VError.cause(err);\n      if (cause2) {\n        return `${err.stack}\ncaused by: ${VError.fullStack(cause2)}`;\n      }\n      return err.stack;\n    }\n  },\n  {\n    key: \"errorFromList\",\n    value: function errorFromList(errors) {\n      if (!Array.isArray(errors)) {\n        throw new import_assertion_error2.default(\"list of errors (array) is required\");\n      }\n      errors.forEach(function(error) {\n        if (!isObject(error)) {\n          throw new import_assertion_error2.default(\"errors ([object]) is required\");\n        }\n      });\n      if (errors.length === 0) {\n        return null;\n      }\n      errors.forEach((e) => {\n        if (!isError(e))\n          throw new import_assertion_error2.default(\"error must be an Error\");\n      });\n      if (errors.length === 1) {\n        return errors[0];\n      }\n      return new MultiError(errors);\n    }\n  },\n  {\n    key: \"errorForEach\",\n    value: function errorForEach(err, func) {\n      if (!isError(err))\n        throw new import_assertion_error2.default(\"err must be an Error\");\n      if (!isFunc(func))\n        throw new import_assertion_error2.default(\"func (func) is required\");\n      if (err instanceof MultiError) {\n        err.errors.forEach((e) => {\n          func(e);\n        });\n      } else {\n        func(err);\n      }\n    }\n  }\n]);\nVError.prototype.name = \"VError\";\nfunction MultiError(errors) {\n  if (!(this instanceof MultiError)) {\n    return new MultiError(errors);\n  }\n  if (!Array.isArray(errors)) {\n    throw new import_assertion_error2.default(\"list of errors (array) is required\");\n  }\n  if (errors.length <= 0) {\n    throw new import_assertion_error2.default(\"must be at least one error is required\");\n  }\n  VError.call(\n    this,\n    {\n      cause: errors[0],\n      meta: {\n        errors: [...errors]\n      }\n    },\n    \"first of %d error%s\",\n    errors.length,\n    errors.length === 1 ? \"\" : \"s\"\n  );\n}\n(0, import_inherits.default)(MultiError, VError);\nMultiError.prototype.name = \"MultiError\";\nfunction WError(...args) {\n  if (!(this instanceof WError)) {\n    return new WError(...args);\n  }\n  const { options, shortMessage } = parseConstructorArguments(...args);\n  options.skipCauseMessage = true;\n  VError.call(\n    this,\n    options,\n    \"%s\",\n    shortMessage\n  );\n}\n(0, import_inherits.default)(WError, VError);\ndefineProperties(WError.prototype, [\n  {\n    key: \"toString\",\n    value: function toString2() {\n      let str = Object.prototype.hasOwnProperty.call(this, \"name\") && this.name || this.constructor.name || this.constructor.prototype.name;\n      if (this.message) {\n        str += `: ${this.message}`;\n      }\n      if (this.cause && this.cause.message) {\n        str += `; caused by ${this.cause.toString()}`;\n      }\n      return str;\n    }\n  }\n]);\nWError.prototype.name = \"WError\";\nVError.VError = VError;\nVError.WError = WError;\nVError.MultiError = MultiError;\nVError.META = META;\nvar verror_default = VError;\n\n// src/http.js\nvar http_exports = {};\n__export(http_exports, {\n  BadGateway: () => BadGateway,\n  BadRequest: () => BadRequest,\n  Conflict: () => Conflict,\n  Forbidden: () => Forbidden,\n  GeneralError: () => GeneralError,\n  Gone: () => Gone,\n  LengthRequired: () => LengthRequired,\n  MethodNotAllowed: () => MethodNotAllowed,\n  NotAcceptable: () => NotAcceptable,\n  NotAuthenticated: () => NotAuthenticated,\n  NotFound: () => NotFound,\n  NotImplemented: () => NotImplemented,\n  PaymentError: () => PaymentError,\n  Timeout: () => Timeout,\n  TooManyRequests: () => TooManyRequests,\n  Unavailable: () => Unavailable,\n  Unprocessable: () => Unprocessable,\n  VError: () => verror_default\n});\nvar import_inherits2 = __toESM(__webpack_require__(/*! inherits */ \"(ssr)/./node_modules/inherits/inherits.js\"));\nvar import_depd = __toESM(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/depd/index.js\"));\nvar deprecate = (0, import_depd.default)(\"@openangeda/verror\");\nfunction createError(name, statusCode, className) {\n  const ExtendedError = function(...args) {\n    if (!(this instanceof ExtendedError)) {\n      return new ExtendedError(...args);\n    }\n    const { options, shortMessage } = parseConstructorArguments(...args);\n    options.meta = {\n      code: statusCode,\n      statusCode,\n      className,\n      ...options.meta\n    };\n    verror_default.call(\n      this,\n      options,\n      shortMessage\n    );\n    deprecate.property(this, \"code\", \"use `statusCode` instead of `code`\");\n  };\n  Object.defineProperty(ExtendedError, \"name\", { configurable: true, value: name });\n  (0, import_inherits2.default)(ExtendedError, verror_default);\n  ExtendedError.prototype.name = name;\n  return ExtendedError;\n}\nvar BadRequest = createError(\"BadRequest\", 400, \"bad-request\");\nvar NotAuthenticated = createError(\"NotAuthenticated\", 401, \"not-authenticated\");\nvar PaymentError = createError(\"PaymentError\", 402, \"payment-error\");\nvar Forbidden = createError(\"Forbidden\", 403, \"forbidden\");\nvar NotFound = createError(\"NotFound\", 404, \"not-found\");\nvar MethodNotAllowed = createError(\"MethodNotAllowed\", 405, \"method-not-allowed\");\nvar NotAcceptable = createError(\"NotAcceptable\", 406, \"not-acceptable\");\nvar Timeout = createError(\"Timeout\", 408, \"timeout\");\nvar Conflict = createError(\"Conflict\", 409, \"conflict\");\nvar Gone = createError(\"Gone\", 410, \"gone\");\nvar LengthRequired = createError(\"LengthRequired\", 411, \"length-required\");\nvar Unprocessable = createError(\"Unprocessable\", 422, \"unprocessable\");\nvar TooManyRequests = createError(\"TooManyRequests\", 429, \"too-many-requests\");\nvar GeneralError = createError(\"GeneralError\", 500, \"general-error\");\nvar NotImplemented = createError(\"NotImplemented\", 501, \"not-implemented\");\nvar BadGateway = createError(\"BadGateway\", 502, \"bad-gateway\");\nvar Unavailable = createError(\"Unavailable\", 503, \"unavailable\");\n\n// src/index.js\nvar httpAliases = {\n  400: BadRequest,\n  401: NotAuthenticated,\n  402: PaymentError,\n  403: Forbidden,\n  404: NotFound,\n  405: MethodNotAllowed,\n  406: NotAcceptable,\n  408: Timeout,\n  409: Conflict,\n  410: Gone,\n  411: LengthRequired,\n  422: Unprocessable,\n  429: TooManyRequests,\n  500: GeneralError,\n  501: NotImplemented,\n  502: BadGateway,\n  503: Unavailable\n};\nObject.assign(verror_default, http_exports, httpAliases);\nvar src_default = verror_default;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5hZ2VuZGEvdmVycm9yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLDJEQUFVO0FBQ2hELHNDQUFzQyxtQkFBTyxDQUFDLHNFQUFpQjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBWTtBQUM1QyxxQ0FBcUMsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdCQUFnQjtBQUNoQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0JBQStCLG1CQUFPLENBQUMsMkRBQVU7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsZ0RBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQW1CTCIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BvcGVuYWdlbmRhL3ZlcnJvci9kaXN0L2luZGV4LmpzPzRmNGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LmpzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIEJhZEdhdGV3YXk6ICgpID0+IEJhZEdhdGV3YXksXG4gIEJhZFJlcXVlc3Q6ICgpID0+IEJhZFJlcXVlc3QsXG4gIENvbmZsaWN0OiAoKSA9PiBDb25mbGljdCxcbiAgRm9yYmlkZGVuOiAoKSA9PiBGb3JiaWRkZW4sXG4gIEdlbmVyYWxFcnJvcjogKCkgPT4gR2VuZXJhbEVycm9yLFxuICBHb25lOiAoKSA9PiBHb25lLFxuICBMZW5ndGhSZXF1aXJlZDogKCkgPT4gTGVuZ3RoUmVxdWlyZWQsXG4gIE1ldGhvZE5vdEFsbG93ZWQ6ICgpID0+IE1ldGhvZE5vdEFsbG93ZWQsXG4gIE5vdEFjY2VwdGFibGU6ICgpID0+IE5vdEFjY2VwdGFibGUsXG4gIE5vdEF1dGhlbnRpY2F0ZWQ6ICgpID0+IE5vdEF1dGhlbnRpY2F0ZWQsXG4gIE5vdEZvdW5kOiAoKSA9PiBOb3RGb3VuZCxcbiAgTm90SW1wbGVtZW50ZWQ6ICgpID0+IE5vdEltcGxlbWVudGVkLFxuICBQYXltZW50RXJyb3I6ICgpID0+IFBheW1lbnRFcnJvcixcbiAgVGltZW91dDogKCkgPT4gVGltZW91dCxcbiAgVG9vTWFueVJlcXVlc3RzOiAoKSA9PiBUb29NYW55UmVxdWVzdHMsXG4gIFVuYXZhaWxhYmxlOiAoKSA9PiBVbmF2YWlsYWJsZSxcbiAgVW5wcm9jZXNzYWJsZTogKCkgPT4gVW5wcm9jZXNzYWJsZSxcbiAgVkVycm9yOiAoKSA9PiB2ZXJyb3JfZGVmYXVsdCxcbiAgZGVmYXVsdDogKCkgPT4gc3JjX2RlZmF1bHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuXG4vLyBzcmMvdmVycm9yLmpzXG52YXIgaW1wb3J0X2luaGVyaXRzID0gX190b0VTTShyZXF1aXJlKFwiaW5oZXJpdHNcIikpO1xudmFyIGltcG9ydF9hc3NlcnRpb25fZXJyb3IyID0gX190b0VTTShyZXF1aXJlKFwiYXNzZXJ0aW9uLWVycm9yXCIpKTtcblxuLy8gc3JjL2Fzc2VydC5qc1xuZnVuY3Rpb24gaXNFcnJvcihhcmcpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSBcIltvYmplY3QgRXJyb3JdXCIgfHwgYXJnIGluc3RhbmNlb2YgRXJyb3I7XG59XG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgYXJnICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNGdW5jKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cy5qc1xudmFyIGltcG9ydF9zcHJpbnRmX2pzID0gcmVxdWlyZShcInNwcmludGYtanNcIik7XG52YXIgaW1wb3J0X2Fzc2VydGlvbl9lcnJvciA9IF9fdG9FU00ocmVxdWlyZShcImFzc2VydGlvbi1lcnJvclwiKSk7XG5mdW5jdGlvbiBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKC4uLmFyZ3YpIHtcbiAgbGV0IG9wdGlvbnM7XG4gIGxldCBzcHJpbnRmQXJncztcbiAgaWYgKGFyZ3YubGVuZ3RoID09PSAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIHNwcmludGZBcmdzID0gW107XG4gIH0gZWxzZSBpZiAoaXNFcnJvcihhcmd2WzBdKSkge1xuICAgIG9wdGlvbnMgPSB7IGNhdXNlOiBhcmd2WzBdIH07XG4gICAgc3ByaW50ZkFyZ3MgPSBhcmd2LnNsaWNlKDEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd2WzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBhcmd2WzBdKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3ZbMF0sIGspKSB7XG4gICAgICAgIG9wdGlvbnNba10gPSBhcmd2WzBdW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBzcHJpbnRmQXJncyA9IGFyZ3Yuc2xpY2UoMSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpc1N0cmluZyhhcmd2WzBdKSkge1xuICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IuZGVmYXVsdChcbiAgICAgICAgXCJmaXJzdCBhcmd1bWVudCB0byBWRXJyb3IsIG9yIFdFcnJvciBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgc3RyaW5nLCBvYmplY3QsIG9yIEVycm9yXCJcbiAgICAgICk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSB7fTtcbiAgICBzcHJpbnRmQXJncyA9IGFyZ3Y7XG4gIH1cbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSlcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvci5kZWZhdWx0KFwib3B0aW9ucyAob2JqZWN0KSBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKG9wdGlvbnMubWV0YSAmJiAhaXNPYmplY3Qob3B0aW9ucy5tZXRhKSlcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvci5kZWZhdWx0KFwib3B0aW9ucy5tZXRhIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgc2hvcnRNZXNzYWdlOiBzcHJpbnRmQXJncy5sZW5ndGggPT09IDAgPyBcIlwiIDogaW1wb3J0X3NwcmludGZfanMuc3ByaW50Zi5hcHBseShudWxsLCBzcHJpbnRmQXJncylcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLmpzXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3IpIHtcbiAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcilcbiAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xufVxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BzW2ldKTtcbiAgfVxufVxuXG4vLyBzcmMvdmVycm9yLmpzXG52YXIgTUVUQSA9IFwiQEB2ZXJyb3IvbWV0YVwiO1xudmFyIHJlc2VydmVkID0gW1xuICBcIm5hbWVcIixcbiAgXCJtZXNzYWdlXCIsXG4gIFwic2hvcnRNZXNzYWdlXCIsXG4gIFwiY2F1c2VcIixcbiAgXCJpbmZvXCIsXG4gIFwic3RhY2tcIixcbiAgXCJmaWxlTmFtZVwiLFxuICBcImxpbmVOdW1iZXJcIlxuXTtcbmZ1bmN0aW9uIG1lcmdlTWV0YShpbnN0YW5jZSwgbWV0YTIpIHtcbiAgaWYgKCFtZXRhMikge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gbWV0YTIpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGEyLCBrKSkge1xuICAgICAgaWYgKHJlc2VydmVkLmluY2x1ZGVzKGspKSB7XG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfYXNzZXJ0aW9uX2Vycm9yMi5kZWZhdWx0KGBcIiR7a31cIiBpcyBhIHJlc2VydmVkIG1ldGFgKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlW01FVEFdW2tdID0gbWV0YTJba107XG4gICAgICBpbnN0YW5jZVtrXSA9IG1ldGEyW2tdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gVkVycm9yKC4uLmFyZ3MpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZFcnJvcikpIHtcbiAgICByZXR1cm4gbmV3IFZFcnJvciguLi5hcmdzKTtcbiAgfVxuICBjb25zdCB7IG9wdGlvbnMsIHNob3J0TWVzc2FnZSB9ID0gcGFyc2VDb25zdHJ1Y3RvckFyZ3VtZW50cyguLi5hcmdzKTtcbiAgY29uc3QgeyBjYXVzZTogY2F1c2UyLCBjb25zdHJ1Y3Rvck9wdCwgaW5mbzogaW5mbzIsIG5hbWUsIHNraXBDYXVzZU1lc3NhZ2UsIG1ldGE6IG1ldGEyIH0gPSBvcHRpb25zO1xuICBsZXQgbWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgaWYgKGNhdXNlMikge1xuICAgIGlmICghaXNFcnJvcihjYXVzZTIpKVxuICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJjYXVzZSBpcyBub3QgYW4gRXJyb3JcIik7XG4gICAgaWYgKCFza2lwQ2F1c2VNZXNzYWdlICYmIGNhdXNlMi5tZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZSA9PT0gXCJcIiA/IGNhdXNlMi5tZXNzYWdlIDogYCR7bWVzc2FnZX06ICR7Y2F1c2UyLm1lc3NhZ2V9YDtcbiAgICB9XG4gIH1cbiAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIWlzU3RyaW5nKG5hbWUpKVxuICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoYGVycm9yJ3MgXCJuYW1lXCIgbXVzdCBiZSBhIHN0cmluZ2ApO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XG4gIGlmIChjYXVzZTIpIHtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2UyO1xuICB9XG4gIHRoaXMuaW5mbyA9IHt9O1xuICBpZiAoaW5mbzIpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gaW5mbzIpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5mbzIsIGspKSB7XG4gICAgICAgIHRoaXMuaW5mb1trXSA9IGluZm8yW2tdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCB7XG4gICAga2V5OiBNRVRBLFxuICAgIHZhbHVlOiB7fVxuICB9KTtcbiAgbWVyZ2VNZXRhKHRoaXMsIFZFcnJvci5tZXRhKHRoaXMpKTtcbiAgbWVyZ2VNZXRhKHRoaXMsIG1ldGEyKTtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgY29uc3RydWN0b3JPcHQgfHwgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICB9XG59XG4oMCwgaW1wb3J0X2luaGVyaXRzLmRlZmF1bHQpKFZFcnJvciwgRXJyb3IpO1xuZGVmaW5lUHJvcGVydGllcyhWRXJyb3IucHJvdG90eXBlLCBbXG4gIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBsZXQgc3RyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIFwibmFtZVwiKSAmJiB0aGlzLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWU7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICAgIHN0ciArPSBgOiAke3RoaXMubWVzc2FnZX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIHNob3J0TWVzc2FnZTogdGhpcy5zaG9ydE1lc3NhZ2UsXG4gICAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgICBpbmZvOiB0aGlzLmluZm9cbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzW01FVEFdKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpc1tNRVRBXSwga2V5KSAmJiAhKGtleSBpbiBvYmopKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB0aGlzW01FVEFdW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XG5dKTtcbmRlZmluZVByb3BlcnRpZXMoVkVycm9yLCBbXG4gIHtcbiAgICBrZXk6IFwiY2F1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2F1c2UoZXJyKSB7XG4gICAgICBpZiAoIWlzRXJyb3IoZXJyKSlcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJlcnIgbXVzdCBiZSBhbiBFcnJvclwiKTtcbiAgICAgIHJldHVybiBpc0Vycm9yKGVyci5jYXVzZSkgPyBlcnIuY2F1c2UgOiBudWxsO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogXCJpbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8oZXJyKSB7XG4gICAgICBpZiAoIWlzRXJyb3IoZXJyKSlcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJlcnIgbXVzdCBiZSBhbiBFcnJvclwiKTtcbiAgICAgIGNvbnN0IGNhdXNlMiA9IFZFcnJvci5jYXVzZShlcnIpO1xuICAgICAgY29uc3QgcnYgPSBjYXVzZTIgIT09IG51bGwgPyBWRXJyb3IuaW5mbyhjYXVzZTIpIDoge307XG4gICAgICBpZiAoaXNPYmplY3QoZXJyLmluZm8pKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiBlcnIuaW5mbykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLmluZm8sIGspKSB7XG4gICAgICAgICAgICBydltrXSA9IGVyci5pbmZvW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogXCJtZXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ldGEoZXJyKSB7XG4gICAgICBpZiAoIWlzRXJyb3IoZXJyKSlcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJlcnIgbXVzdCBiZSBhbiBFcnJvclwiKTtcbiAgICAgIGNvbnN0IGNhdXNlMiA9IFZFcnJvci5jYXVzZShlcnIpO1xuICAgICAgY29uc3QgcnYgPSBjYXVzZTIgIT09IG51bGwgPyBWRXJyb3IubWV0YShjYXVzZTIpIDoge307XG4gICAgICBpZiAoaXNPYmplY3QoZXJyW01FVEFdKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gZXJyW01FVEFdKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnJbTUVUQV0sIGspKSB7XG4gICAgICAgICAgICBydltrXSA9IGVycltNRVRBXVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFwiZmluZENhdXNlQnlOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDYXVzZUJ5TmFtZShlcnIsIG5hbWUpIHtcbiAgICAgIGlmICghaXNFcnJvcihlcnIpKVxuICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvcjIuZGVmYXVsdChcImVyciBtdXN0IGJlIGFuIEVycm9yXCIpO1xuICAgICAgaWYgKCFpc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJuYW1lIChzdHJpbmcpIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKG5hbWUubGVuZ3RoIDw9IDApXG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfYXNzZXJ0aW9uX2Vycm9yMi5kZWZhdWx0KFwibmFtZSBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICBmb3IgKGxldCBjYXVzZTIgPSBlcnI7IGNhdXNlMiAhPT0gbnVsbDsgY2F1c2UyID0gVkVycm9yLmNhdXNlKGNhdXNlMikpIHtcbiAgICAgICAgaWYgKCFpc0Vycm9yKGVycikpXG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJjYXVzZSBtdXN0IGJlIGFuIEVycm9yXCIpO1xuICAgICAgICBpZiAoY2F1c2UyLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gY2F1c2UyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFwiZmluZENhdXNlQnlUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDYXVzZUJ5VHlwZShlcnIsIHR5cGUpIHtcbiAgICAgIGlmICghaXNFcnJvcihlcnIpKVxuICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvcjIuZGVmYXVsdChcImVyciBtdXN0IGJlIGFuIEVycm9yXCIpO1xuICAgICAgaWYgKCFpc0Z1bmModHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfYXNzZXJ0aW9uX2Vycm9yMi5kZWZhdWx0KFwidHlwZSAoZnVuYykgaXMgcmVxdWlyZWRcIik7XG4gICAgICBmb3IgKGxldCBjYXVzZTIgPSBlcnI7IGNhdXNlMiAhPT0gbnVsbDsgY2F1c2UyID0gVkVycm9yLmNhdXNlKGNhdXNlMikpIHtcbiAgICAgICAgaWYgKCFpc0Vycm9yKGVycikpXG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJjYXVzZSBtdXN0IGJlIGFuIEVycm9yXCIpO1xuICAgICAgICBpZiAoY2F1c2UyIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgIHJldHVybiBjYXVzZTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogXCJoYXNDYXVzZVdpdGhOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhdXNlV2l0aE5hbWUoZXJyLCBuYW1lKSB7XG4gICAgICByZXR1cm4gVkVycm9yLmZpbmRDYXVzZUJ5TmFtZShlcnIsIG5hbWUpICE9PSBudWxsO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogXCJoYXNDYXVzZVdpdGhUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhdXNlV2l0aFR5cGUoZXJyLCB0eXBlKSB7XG4gICAgICByZXR1cm4gVkVycm9yLmZpbmRDYXVzZUJ5VHlwZShlcnIsIHR5cGUpICE9PSBudWxsO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGtleTogXCJmdWxsU3RhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnVsbFN0YWNrKGVycikge1xuICAgICAgaWYgKCFpc0Vycm9yKGVycikpXG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfYXNzZXJ0aW9uX2Vycm9yMi5kZWZhdWx0KFwiZXJyIG11c3QgYmUgYW4gRXJyb3JcIik7XG4gICAgICBjb25zdCBjYXVzZTIgPSBWRXJyb3IuY2F1c2UoZXJyKTtcbiAgICAgIGlmIChjYXVzZTIpIHtcbiAgICAgICAgcmV0dXJuIGAke2Vyci5zdGFja31cbmNhdXNlZCBieTogJHtWRXJyb3IuZnVsbFN0YWNrKGNhdXNlMil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnIuc3RhY2s7XG4gICAgfVxuICB9LFxuICB7XG4gICAga2V5OiBcImVycm9yRnJvbUxpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3JGcm9tTGlzdChlcnJvcnMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfYXNzZXJ0aW9uX2Vycm9yMi5kZWZhdWx0KFwibGlzdCBvZiBlcnJvcnMgKGFycmF5KSBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJlcnJvcnMgKFtvYmplY3RdKSBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVycm9ycy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGlmICghaXNFcnJvcihlKSlcbiAgICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvcjIuZGVmYXVsdChcImVycm9yIG11c3QgYmUgYW4gRXJyb3JcIik7XG4gICAgICB9KTtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnNbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE11bHRpRXJyb3IoZXJyb3JzKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICBrZXk6IFwiZXJyb3JGb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yRm9yRWFjaChlcnIsIGZ1bmMpIHtcbiAgICAgIGlmICghaXNFcnJvcihlcnIpKVxuICAgICAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvcjIuZGVmYXVsdChcImVyciBtdXN0IGJlIGFuIEVycm9yXCIpO1xuICAgICAgaWYgKCFpc0Z1bmMoZnVuYykpXG4gICAgICAgIHRocm93IG5ldyBpbXBvcnRfYXNzZXJ0aW9uX2Vycm9yMi5kZWZhdWx0KFwiZnVuYyAoZnVuYykgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTXVsdGlFcnJvcikge1xuICAgICAgICBlcnIuZXJyb3JzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICBmdW5jKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmMoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbl0pO1xuVkVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJWRXJyb3JcIjtcbmZ1bmN0aW9uIE11bHRpRXJyb3IoZXJyb3JzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNdWx0aUVycm9yKSkge1xuICAgIHJldHVybiBuZXcgTXVsdGlFcnJvcihlcnJvcnMpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgdGhyb3cgbmV3IGltcG9ydF9hc3NlcnRpb25fZXJyb3IyLmRlZmF1bHQoXCJsaXN0IG9mIGVycm9ycyAoYXJyYXkpIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGlmIChlcnJvcnMubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgaW1wb3J0X2Fzc2VydGlvbl9lcnJvcjIuZGVmYXVsdChcIm11c3QgYmUgYXQgbGVhc3Qgb25lIGVycm9yIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIFZFcnJvci5jYWxsKFxuICAgIHRoaXMsXG4gICAge1xuICAgICAgY2F1c2U6IGVycm9yc1swXSxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgZXJyb3JzOiBbLi4uZXJyb3JzXVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJmaXJzdCBvZiAlZCBlcnJvciVzXCIsXG4gICAgZXJyb3JzLmxlbmd0aCxcbiAgICBlcnJvcnMubGVuZ3RoID09PSAxID8gXCJcIiA6IFwic1wiXG4gICk7XG59XG4oMCwgaW1wb3J0X2luaGVyaXRzLmRlZmF1bHQpKE11bHRpRXJyb3IsIFZFcnJvcik7XG5NdWx0aUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJNdWx0aUVycm9yXCI7XG5mdW5jdGlvbiBXRXJyb3IoLi4uYXJncykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV0Vycm9yKSkge1xuICAgIHJldHVybiBuZXcgV0Vycm9yKC4uLmFyZ3MpO1xuICB9XG4gIGNvbnN0IHsgb3B0aW9ucywgc2hvcnRNZXNzYWdlIH0gPSBwYXJzZUNvbnN0cnVjdG9yQXJndW1lbnRzKC4uLmFyZ3MpO1xuICBvcHRpb25zLnNraXBDYXVzZU1lc3NhZ2UgPSB0cnVlO1xuICBWRXJyb3IuY2FsbChcbiAgICB0aGlzLFxuICAgIG9wdGlvbnMsXG4gICAgXCIlc1wiLFxuICAgIHNob3J0TWVzc2FnZVxuICApO1xufVxuKDAsIGltcG9ydF9pbmhlcml0cy5kZWZhdWx0KShXRXJyb3IsIFZFcnJvcik7XG5kZWZpbmVQcm9wZXJ0aWVzKFdFcnJvci5wcm90b3R5cGUsIFtcbiAge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZzIoKSB7XG4gICAgICBsZXQgc3RyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIFwibmFtZVwiKSAmJiB0aGlzLm5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIHx8IHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWU7XG4gICAgICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICAgIHN0ciArPSBgOiAke3RoaXMubWVzc2FnZX1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2F1c2UgJiYgdGhpcy5jYXVzZS5tZXNzYWdlKSB7XG4gICAgICAgIHN0ciArPSBgOyBjYXVzZWQgYnkgJHt0aGlzLmNhdXNlLnRvU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5dKTtcbldFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiV0Vycm9yXCI7XG5WRXJyb3IuVkVycm9yID0gVkVycm9yO1xuVkVycm9yLldFcnJvciA9IFdFcnJvcjtcblZFcnJvci5NdWx0aUVycm9yID0gTXVsdGlFcnJvcjtcblZFcnJvci5NRVRBID0gTUVUQTtcbnZhciB2ZXJyb3JfZGVmYXVsdCA9IFZFcnJvcjtcblxuLy8gc3JjL2h0dHAuanNcbnZhciBodHRwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGh0dHBfZXhwb3J0cywge1xuICBCYWRHYXRld2F5OiAoKSA9PiBCYWRHYXRld2F5LFxuICBCYWRSZXF1ZXN0OiAoKSA9PiBCYWRSZXF1ZXN0LFxuICBDb25mbGljdDogKCkgPT4gQ29uZmxpY3QsXG4gIEZvcmJpZGRlbjogKCkgPT4gRm9yYmlkZGVuLFxuICBHZW5lcmFsRXJyb3I6ICgpID0+IEdlbmVyYWxFcnJvcixcbiAgR29uZTogKCkgPT4gR29uZSxcbiAgTGVuZ3RoUmVxdWlyZWQ6ICgpID0+IExlbmd0aFJlcXVpcmVkLFxuICBNZXRob2ROb3RBbGxvd2VkOiAoKSA9PiBNZXRob2ROb3RBbGxvd2VkLFxuICBOb3RBY2NlcHRhYmxlOiAoKSA9PiBOb3RBY2NlcHRhYmxlLFxuICBOb3RBdXRoZW50aWNhdGVkOiAoKSA9PiBOb3RBdXRoZW50aWNhdGVkLFxuICBOb3RGb3VuZDogKCkgPT4gTm90Rm91bmQsXG4gIE5vdEltcGxlbWVudGVkOiAoKSA9PiBOb3RJbXBsZW1lbnRlZCxcbiAgUGF5bWVudEVycm9yOiAoKSA9PiBQYXltZW50RXJyb3IsXG4gIFRpbWVvdXQ6ICgpID0+IFRpbWVvdXQsXG4gIFRvb01hbnlSZXF1ZXN0czogKCkgPT4gVG9vTWFueVJlcXVlc3RzLFxuICBVbmF2YWlsYWJsZTogKCkgPT4gVW5hdmFpbGFibGUsXG4gIFVucHJvY2Vzc2FibGU6ICgpID0+IFVucHJvY2Vzc2FibGUsXG4gIFZFcnJvcjogKCkgPT4gdmVycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9pbmhlcml0czIgPSBfX3RvRVNNKHJlcXVpcmUoXCJpbmhlcml0c1wiKSk7XG52YXIgaW1wb3J0X2RlcGQgPSBfX3RvRVNNKHJlcXVpcmUoXCJkZXBkXCIpKTtcbnZhciBkZXByZWNhdGUgPSAoMCwgaW1wb3J0X2RlcGQuZGVmYXVsdCkoXCJAb3BlbmFuZ2VkYS92ZXJyb3JcIik7XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihuYW1lLCBzdGF0dXNDb2RlLCBjbGFzc05hbWUpIHtcbiAgY29uc3QgRXh0ZW5kZWRFcnJvciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXh0ZW5kZWRFcnJvcikpIHtcbiAgICAgIHJldHVybiBuZXcgRXh0ZW5kZWRFcnJvciguLi5hcmdzKTtcbiAgICB9XG4gICAgY29uc3QgeyBvcHRpb25zLCBzaG9ydE1lc3NhZ2UgfSA9IHBhcnNlQ29uc3RydWN0b3JBcmd1bWVudHMoLi4uYXJncyk7XG4gICAgb3B0aW9ucy5tZXRhID0ge1xuICAgICAgY29kZTogc3RhdHVzQ29kZSxcbiAgICAgIHN0YXR1c0NvZGUsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICAuLi5vcHRpb25zLm1ldGFcbiAgICB9O1xuICAgIHZlcnJvcl9kZWZhdWx0LmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHNob3J0TWVzc2FnZVxuICAgICk7XG4gICAgZGVwcmVjYXRlLnByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCBcInVzZSBgc3RhdHVzQ29kZWAgaW5zdGVhZCBvZiBgY29kZWBcIik7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeHRlbmRlZEVycm9yLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBuYW1lIH0pO1xuICAoMCwgaW1wb3J0X2luaGVyaXRzMi5kZWZhdWx0KShFeHRlbmRlZEVycm9yLCB2ZXJyb3JfZGVmYXVsdCk7XG4gIEV4dGVuZGVkRXJyb3IucHJvdG90eXBlLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gRXh0ZW5kZWRFcnJvcjtcbn1cbnZhciBCYWRSZXF1ZXN0ID0gY3JlYXRlRXJyb3IoXCJCYWRSZXF1ZXN0XCIsIDQwMCwgXCJiYWQtcmVxdWVzdFwiKTtcbnZhciBOb3RBdXRoZW50aWNhdGVkID0gY3JlYXRlRXJyb3IoXCJOb3RBdXRoZW50aWNhdGVkXCIsIDQwMSwgXCJub3QtYXV0aGVudGljYXRlZFwiKTtcbnZhciBQYXltZW50RXJyb3IgPSBjcmVhdGVFcnJvcihcIlBheW1lbnRFcnJvclwiLCA0MDIsIFwicGF5bWVudC1lcnJvclwiKTtcbnZhciBGb3JiaWRkZW4gPSBjcmVhdGVFcnJvcihcIkZvcmJpZGRlblwiLCA0MDMsIFwiZm9yYmlkZGVuXCIpO1xudmFyIE5vdEZvdW5kID0gY3JlYXRlRXJyb3IoXCJOb3RGb3VuZFwiLCA0MDQsIFwibm90LWZvdW5kXCIpO1xudmFyIE1ldGhvZE5vdEFsbG93ZWQgPSBjcmVhdGVFcnJvcihcIk1ldGhvZE5vdEFsbG93ZWRcIiwgNDA1LCBcIm1ldGhvZC1ub3QtYWxsb3dlZFwiKTtcbnZhciBOb3RBY2NlcHRhYmxlID0gY3JlYXRlRXJyb3IoXCJOb3RBY2NlcHRhYmxlXCIsIDQwNiwgXCJub3QtYWNjZXB0YWJsZVwiKTtcbnZhciBUaW1lb3V0ID0gY3JlYXRlRXJyb3IoXCJUaW1lb3V0XCIsIDQwOCwgXCJ0aW1lb3V0XCIpO1xudmFyIENvbmZsaWN0ID0gY3JlYXRlRXJyb3IoXCJDb25mbGljdFwiLCA0MDksIFwiY29uZmxpY3RcIik7XG52YXIgR29uZSA9IGNyZWF0ZUVycm9yKFwiR29uZVwiLCA0MTAsIFwiZ29uZVwiKTtcbnZhciBMZW5ndGhSZXF1aXJlZCA9IGNyZWF0ZUVycm9yKFwiTGVuZ3RoUmVxdWlyZWRcIiwgNDExLCBcImxlbmd0aC1yZXF1aXJlZFwiKTtcbnZhciBVbnByb2Nlc3NhYmxlID0gY3JlYXRlRXJyb3IoXCJVbnByb2Nlc3NhYmxlXCIsIDQyMiwgXCJ1bnByb2Nlc3NhYmxlXCIpO1xudmFyIFRvb01hbnlSZXF1ZXN0cyA9IGNyZWF0ZUVycm9yKFwiVG9vTWFueVJlcXVlc3RzXCIsIDQyOSwgXCJ0b28tbWFueS1yZXF1ZXN0c1wiKTtcbnZhciBHZW5lcmFsRXJyb3IgPSBjcmVhdGVFcnJvcihcIkdlbmVyYWxFcnJvclwiLCA1MDAsIFwiZ2VuZXJhbC1lcnJvclwiKTtcbnZhciBOb3RJbXBsZW1lbnRlZCA9IGNyZWF0ZUVycm9yKFwiTm90SW1wbGVtZW50ZWRcIiwgNTAxLCBcIm5vdC1pbXBsZW1lbnRlZFwiKTtcbnZhciBCYWRHYXRld2F5ID0gY3JlYXRlRXJyb3IoXCJCYWRHYXRld2F5XCIsIDUwMiwgXCJiYWQtZ2F0ZXdheVwiKTtcbnZhciBVbmF2YWlsYWJsZSA9IGNyZWF0ZUVycm9yKFwiVW5hdmFpbGFibGVcIiwgNTAzLCBcInVuYXZhaWxhYmxlXCIpO1xuXG4vLyBzcmMvaW5kZXguanNcbnZhciBodHRwQWxpYXNlcyA9IHtcbiAgNDAwOiBCYWRSZXF1ZXN0LFxuICA0MDE6IE5vdEF1dGhlbnRpY2F0ZWQsXG4gIDQwMjogUGF5bWVudEVycm9yLFxuICA0MDM6IEZvcmJpZGRlbixcbiAgNDA0OiBOb3RGb3VuZCxcbiAgNDA1OiBNZXRob2ROb3RBbGxvd2VkLFxuICA0MDY6IE5vdEFjY2VwdGFibGUsXG4gIDQwODogVGltZW91dCxcbiAgNDA5OiBDb25mbGljdCxcbiAgNDEwOiBHb25lLFxuICA0MTE6IExlbmd0aFJlcXVpcmVkLFxuICA0MjI6IFVucHJvY2Vzc2FibGUsXG4gIDQyOTogVG9vTWFueVJlcXVlc3RzLFxuICA1MDA6IEdlbmVyYWxFcnJvcixcbiAgNTAxOiBOb3RJbXBsZW1lbnRlZCxcbiAgNTAyOiBCYWRHYXRld2F5LFxuICA1MDM6IFVuYXZhaWxhYmxlXG59O1xuT2JqZWN0LmFzc2lnbih2ZXJyb3JfZGVmYXVsdCwgaHR0cF9leHBvcnRzLCBodHRwQWxpYXNlcyk7XG52YXIgc3JjX2RlZmF1bHQgPSB2ZXJyb3JfZGVmYXVsdDtcbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBCYWRHYXRld2F5LFxuICBCYWRSZXF1ZXN0LFxuICBDb25mbGljdCxcbiAgRm9yYmlkZGVuLFxuICBHZW5lcmFsRXJyb3IsXG4gIEdvbmUsXG4gIExlbmd0aFJlcXVpcmVkLFxuICBNZXRob2ROb3RBbGxvd2VkLFxuICBOb3RBY2NlcHRhYmxlLFxuICBOb3RBdXRoZW50aWNhdGVkLFxuICBOb3RGb3VuZCxcbiAgTm90SW1wbGVtZW50ZWQsXG4gIFBheW1lbnRFcnJvcixcbiAgVGltZW91dCxcbiAgVG9vTWFueVJlcXVlc3RzLFxuICBVbmF2YWlsYWJsZSxcbiAgVW5wcm9jZXNzYWJsZSxcbiAgVkVycm9yXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openagenda/verror/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@openagenda/verror/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@openagenda/verror/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(ssr)/./node_modules/@openagenda/verror/dist/index.js\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG9wZW5hZ2VuZGEvdmVycm9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDRIQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL0BvcGVuYWdlbmRhL3ZlcnJvci9pbmRleC5qcz8wNzE0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgnKS5kZWZhdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@openagenda/verror/index.js\n");

/***/ })

};
;