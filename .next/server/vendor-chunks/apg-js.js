/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/apg-js";
exports.ids = ["vendor-chunks/apg-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/api.js":
/*!************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/api.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\nmodule.exports = function api(src) {\n  const { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n  const thisFileName = 'api.js: ';\n  const thisObject = this;\n\n  /* PRIVATE PROPERTIES */\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js\");\n  const scanner = __webpack_require__(/*! ./scanner */ \"(ssr)/./node_modules/apg-js/src/apg-api/scanner.js\");\n  const parser = new (__webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/apg-js/src/apg-api/parser.js\"))();\n  const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = __webpack_require__(/*! ./attributes */ \"(ssr)/./node_modules/apg-js/src/apg-api/attributes.js\");\n  const showRules = __webpack_require__(/*! ./show-rules */ \"(ssr)/./node_modules/apg-js/src/apg-api/show-rules.js\");\n\n  /* PRIVATE MEMBERS (FUNCTIONS) */\n  /* Convert a phrase (array of character codes) to HTML. */\n  const abnfToHtml = function abnfToHtml(chars, beg, len) {\n    const NORMAL = 0;\n    const CONTROL = 1;\n    const INVALID = 2;\n    const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n    const CONTROL_END = '</span>';\n    const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n    const INVALID_END = '</span>';\n    let end;\n    let html = '';\n    const TRUE = true;\n    while (TRUE) {\n      if (!Array.isArray(chars) || chars.length === 0) {\n        break;\n      }\n      if (typeof beg !== 'number') {\n        throw new Error('abnfToHtml: beg must be type number');\n      }\n      if (beg >= chars.length) {\n        break;\n      }\n      if (typeof len !== 'number' || beg + len >= chars.length) {\n        end = chars.length;\n      } else {\n        end = beg + len;\n      }\n      let state = NORMAL;\n      for (let i = beg; i < end; i += 1) {\n        const ch = chars[i];\n        if (ch >= 32 && ch <= 126) {\n          /* normal - printable ASCII characters */\n          if (state === CONTROL) {\n            html += CONTROL_END;\n            state = NORMAL;\n          } else if (state === INVALID) {\n            html += INVALID_END;\n            state = NORMAL;\n          }\n          /* handle reserved HTML entity characters */\n          switch (ch) {\n            case 32:\n              html += '&nbsp;';\n              break;\n            case 60:\n              html += '&lt;';\n              break;\n            case 62:\n              html += '&gt;';\n              break;\n            case 38:\n              html += '&amp;';\n              break;\n            case 34:\n              html += '&quot;';\n              break;\n            case 39:\n              html += '&#039;';\n              break;\n            case 92:\n              html += '&#092;';\n              break;\n            default:\n              html += String.fromCharCode(ch);\n              break;\n          }\n        } else if (ch === 9 || ch === 10 || ch === 13) {\n          /* control characters */\n          if (state === NORMAL) {\n            html += CONTROL_BEG;\n            state = CONTROL;\n          } else if (state === INVALID) {\n            html += INVALID_END + CONTROL_BEG;\n            state = CONTROL;\n          }\n          if (ch === 9) {\n            html += 'TAB';\n          }\n          if (ch === 10) {\n            html += 'LF';\n          }\n          if (ch === 13) {\n            html += 'CR';\n          }\n        } else {\n          /* invalid characters */\n          if (state === NORMAL) {\n            html += INVALID_BEG;\n            state = INVALID;\n          } else if (state === CONTROL) {\n            html += CONTROL_END + INVALID_BEG;\n            state = INVALID;\n          }\n          /* display character as hexadecimal value */\n          html += `\\\\x${apglib.utils.charToHex(ch)}`;\n        }\n      }\n      if (state === INVALID) {\n        html += INVALID_END;\n      }\n      if (state === CONTROL) {\n        html += CONTROL_END;\n      }\n      break;\n    }\n    return html;\n  };\n  /* Convert a phrase (array of character codes) to ASCII text. */\n  const abnfToAscii = function abnfToAscii(chars, beg, len) {\n    let str = '';\n    for (let i = beg; i < beg + len; i += 1) {\n      const ch = chars[i];\n      if (ch >= 32 && ch <= 126) {\n        str += String.fromCharCode(ch);\n      } else {\n        switch (ch) {\n          case 9:\n            str += '\\\\t';\n            break;\n          case 10:\n            str += '\\\\n';\n            break;\n          case 13:\n            str += '\\\\r';\n            break;\n          default:\n            str += '\\\\unknown';\n            break;\n        }\n      }\n    }\n    return str;\n  };\n  /* translate lines (SABNF grammar) to ASCII text */\n  const linesToAscii = function linesToAscii(lines) {\n    let str = 'Annotated Input Grammar';\n    lines.forEach((val) => {\n      str += '\\n';\n      str += `line no: ${val.lineNo}`;\n      str += ` : char index: ${val.beginChar}`;\n      str += ` : length: ${val.length}`;\n      str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n    });\n    str += '\\n';\n    return str;\n  };\n  /* translate lines (SABNF grammar) to HTML */\n  const linesToHtml = function linesToHtml(lines) {\n    let html = '';\n    html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n    const title = 'Annotated Input Grammar';\n    html += `<caption>${title}</caption>\\n`;\n    html += '<tr>';\n    html += '<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>';\n    html += '</tr>\\n';\n    lines.forEach((val) => {\n      html += '<tr>';\n      html += `<td>${val.lineNo}`;\n      html += `</td><td>${val.beginChar}`;\n      html += `</td><td>${val.length}`;\n      html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n      html += '</td>';\n      html += '</tr>\\n';\n    });\n\n    html += '</table>\\n';\n    return html;\n  };\n  /* Format the error messages to HTML, for page display. */\n  const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n    const [style] = apglib;\n    let html = '';\n    const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n    html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n    if (title && typeof title === 'string') {\n      html += `<caption>${title}</caption>\\n`;\n    }\n    html += '<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n';\n    errors.forEach((val) => {\n      let line;\n      let relchar;\n      let beg;\n      let end;\n      let text;\n      let prefix = '';\n      let suffix = '';\n      if (lines.length === 0) {\n        text = errorArrow;\n        relchar = 0;\n      } else {\n        line = lines[val.line];\n        beg = line.beginChar;\n        if (val.char > beg) {\n          prefix = abnfToHtml(chars, beg, val.char - beg);\n        }\n        beg = val.char;\n        end = line.beginChar + line.length;\n        if (beg < end) {\n          suffix = abnfToHtml(chars, beg, end - beg);\n        }\n        text = prefix + errorArrow + suffix;\n        relchar = val.char - line.beginChar;\n        html += '<tr>';\n        html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n        html += '</tr>\\n';\n        html += '<tr>';\n        html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n        html += '</tr>\\n';\n      }\n    });\n    html += '</table></p>\\n';\n    return html;\n  };\n  /* Display an array of errors in ASCII text */\n  const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n    let str;\n    let line;\n    let beg;\n    let len;\n    str = '';\n    errors.forEach((error) => {\n      line = lines[error.line];\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      beg = line.beginChar;\n      len = error.char - line.beginChar;\n      str += abnfToAscii(chars, beg, len);\n      str += ' >> ';\n      beg = error.char;\n      len = line.beginChar + line.length - error.char;\n      str += abnfToAscii(chars, beg, len);\n      str += '\\n';\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      str += 'error: ';\n      str += error.msg;\n      str += '\\n';\n    });\n    return str;\n  };\n  let isScanned = false;\n  let isParsed = false;\n  let isTranslated = false;\n  let haveAttributes = false;\n  let attributeErrors = 0;\n  let lineMap;\n\n  /* PUBLIC PROPERTIES */\n  // The input SABNF grammar as a JavaScript string.\n  // this.sabnf;\n  // The input SABNF grammar as an array of character codes.\n  // this.chars;\n  // An array of line objects, defining each line of the input SABNF grammar\n  // - lineNo : the zero-based line number\n  // - beginChar : offset (into `this.chars`) of the first character in the line\n  // - length : the number of characters in the line\n  // - textLength : the number of characters of text in the line, excluding the line ending characters\n  // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n  // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n  // this.lines;\n  // An array of rule names and data.\n  // - name : the rule name\n  // - lower : the rule name in lower case\n  // - index : the index of the rule (ordered by appearance in SABNF grammar)\n  // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n  // - opcodes : array of opcodes for this rule\n  // - attrs : the rule attributes\n  // - ctrl : system data\n  // this.rules;\n  // An array of UDT names and data.\n  // this.udts;\n  // An array of errors, if any.\n  // - line : the line number containing the error\n  // - char : the character offset of the error\n  // - msg : the error message\n  this.errors = [];\n\n  /* CONSTRUCTOR */\n  if (Buffer.isBuffer(src)) {\n    this.chars = converter.decode('BINARY', src);\n  } else if (Array.isArray(src)) {\n    this.chars = src.slice();\n  } else if (typeof src === 'string') {\n    this.chars = converter.decode('STRING', src);\n  } else {\n    throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n  }\n  this.sabnf = converter.encode('STRING', this.chars);\n\n  /* PUBLIC MEMBERS (FUNCTIONS) */\n  // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n  // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n  // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n  // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n  this.scan = function scan(strict, trace) {\n    this.lines = scanner(this.chars, this.errors, strict, trace);\n    isScanned = true;\n  };\n  // Parse the input SABNF grammar for correct syntax.\n  // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n  // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n  // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n  //\n  // <i>(*)NOTE: the trace option was used primarily during development.\n  // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n  this.parse = function parse(strict, lite, trace) {\n    if (!isScanned) {\n      throw new Error(`${thisFileName}grammar not scanned`);\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict, lite, trace);\n    isParsed = true;\n  };\n  // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n  this.translate = function translate() {\n    if (!isParsed) {\n      throw new Error(`${thisFileName}grammar not scanned and parsed`);\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length === 0) {\n      this.rules = ret.rules;\n      this.udts = ret.udts;\n      lineMap = ret.lineMap;\n      isTranslated = true;\n    }\n  };\n  // Compute the attributes of each rule.\n  this.attributes = function attrs() {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n    return attributeErrors;\n  };\n  // This function will perform the full suite of steps required to generate a parser grammar object\n  // from the input SABNF grammar.\n  this.generate = function generate(strict) {\n    this.lines = scanner(this.chars, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length) {\n      return;\n    }\n    this.rules = ret.rules;\n    this.udts = ret.udts;\n    lineMap = ret.lineMap;\n\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n  };\n  // Display the rules.\n  // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  this.displayRules = function displayRules(order = 'index') {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    return showRules(this.rules, this.udts, order);\n  };\n  // Display the rule dependencies.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // Otherwise the rule dependencies are not known.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  this.displayRuleDependencies = function displayRuleDependencies(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showRuleDependencies(order);\n  };\n  // Display the attributes.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, type order (default)\n  this.displayAttributes = function displayAttributes(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      showAttributeErrors(order);\n    }\n    return showAttributes(order);\n  };\n  this.displayAttributeErrors = function displayAttributeErrors() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showAttributeErrors();\n  };\n  // Returns a parser grammar object constructor function as a JavaScript string.\n  // This object can then be used to construct a parser.\n  this.toSource = function toSource(config = undefined) {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateSource(this.chars, this.lines, this.rules, this.udts, config);\n  };\n  // Returns a parser grammar object.\n  // This grammar object may be used by the application to construct a parser.\n  this.toObject = function toObject() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateObject(this.sabnf, this.rules, this.udts);\n  };\n  // Display errors in text format, suitable for `console.log()`.\n  this.errorsToAscii = function errorsToAsciiFunc() {\n    return errorsToAscii(this.errors, this.lines, this.chars);\n  };\n  // Display errors in HTML format, suitable for web page display.\n  // (`apg-lib.css` required for proper styling)\n  this.errorsToHtml = function errorsToHtmlFunc(title) {\n    return errorsToHtml(this.errors, this.lines, this.chars, title);\n  };\n  // Generate an annotated the SABNF grammar display in text format.\n  this.linesToAscii = function linesToAsciiFunc() {\n    return linesToAscii(this.lines);\n  };\n  // Generate an annotated the SABNF grammar display in HTML format.\n  // (`apg-lib.css` required for proper styling)\n  this.linesToHtml = function linesToHtmlFunc() {\n    return linesToHtml(this.lines);\n  };\n  // This function was only used by apg.html which has been abandoned.\n  /*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBeUI7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsNEZBQTJCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLG1FQUFVO0FBQ3hDLFVBQVUsd0VBQXdFLEVBQUUsbUJBQU8sQ0FBQywyRUFBYztBQUMxRyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBYzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FB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QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0EseUJBQXlCLGFBQWEsaURBQWlELGlCQUFpQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYSxpREFBaUQsaUJBQWlCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2FwaS5qcz9kNGIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGlzIEFwcGxpY2F0aW9uIFByb2dyYW1taW5nIEludGVyZmFjZSAoQVBJKSBmb3IgKipBUEcqKiAtIHRoZSBBQk5GIFBhcnNlciBHZW5lcmF0b3IuXG4vL1xuLy8gKk5vdGUgb24gdGVtaW5vbG9neS4qXG4vLyBBUEcgaXMgYSBwYXJzZXIgZ2VuZXJhdG9yLlxuLy8gSG93ZXZlciwgaXQgcmVhbGx5IG9ubHkgZ2VuZXJhdGVzIGEgXCJncmFtbWFyIG9iamVjdFwiIChzZWUgYmVsb3cpIGZyb20gdGhlIGRlZmluaW5nIFNBQk5GIGdyYW1tYXIuXG4vLyBUaGUgZ2VuZXJhdGVkIHBhcnNlciBpcyBpbmNvbXBsZXRlIGF0IHRoaXMgc3RhZ2UuXG4vLyBSZW1haW5pbmcsIGl0IGlzIHRoZSBqb2Igb2YgdGhlIHVzZXIgdG8gZGV2ZWxvcCB0aGUgZ2VuZXJhdGVkIHBhcnNlciBmcm9tIHRoZSBncmFtbWFyIG9iamVjdCBhbmQgdGhlICoqQVBHKiogTGlicmFyeSAoKiphcGctbGliKiopLlxuLy9cbi8vIFRoZSBmb2xsb3dpbmcgdGVybWlub2xvZ3kgbXkgaGVscCBjbGVhciB1cCBhbnkgY29uZnVzaW9uIGJldHdlZW4gdGhlIGlkZWEgb2YgYSBcImdlbmVyYXRlZCBwYXJzZXJcIiB2ZXJzdXMgYSBcImdlbmVyYXRlZCBncmFtbWFyIG9iamVjdFwiLlxuXG4vLyAtIFRoZSBnZW5lcmF0aW5nIHBhcnNlcjogKipBUEcqKiBpcyBhbiAqKkFQRyoqIHBhcnNlciAoeWVzLCB0aGVyZSBpcyBhIGNpcmN1bGFyIGRlcGVuZGVuY2UgYmV0d2VlbiAqKmFwZy1hcGkqKiBhbmQgKiphcGctbGliKiopLiBXZSdsbCBjYWxsIGl0IHRoZSBnZW5lcmF0aW5nIHBhcnNlci5cbi8vIC0gVGhlIHRhcmdldCBwYXJzZXI6ICoqQVBHKioncyBnb2FsIGlzIHRvIGdlbmVyYXRlIGEgcGFyc2VyLiBXZSdsbCBjYWxsIGl0IHRoZSB0YXJnZXQgcGFyc2VyLlxuLy8gLSBUaGUgdGFyZ2V0IGdyYW1tYXI6IHRoaXMgaXMgdGhlIChBU0NJSSkgU0FCTkYgZ3JhbW1hciBkZWZpbmluZyB0aGUgdGFyZ2V0IHBhcnNlci5cbi8vIC0gVGhlIHRhcmdldCBncmFtbWFyIG9iamVjdDogKipBUEcqKiBwYXJzZXMgdGhlIFNBQk5GIGdyYW1tYXIgYW5kIGdlbmVyYXRlcyB0aGUgSmF2YVNjcmlwdCBzb3VyY2UgZm9yIGEgdGFyZ2V0IGdyYW1tYXIgb2JqZWN0IGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4vLyBhbmQvb3IgYW4gYWN0dWFsIGdyYW1tYXIgb2JqZWN0LlxuLy8gLSBUaGUgZmluYWwgdGFyZ2V0IHBhcnNlcjogVGhlIHVzZXIgdGhlbiBkZXZlbG9wcyB0aGUgZmluYWwgdGFyZ2V0IHBhcnNlciB1c2luZyB0aGUgZ2VuZXJhdGVkIHRhcmdldCBncmFtbWFyXG4vLyBvYmplY3QgYW5kIHRoZSAqKkFQRyoqIHBhcnNpbmcgbGlicmFyeSwgKiphcGctbGliKiouXG4vLyBUaHJvd3MgZXhlY2VwdGlvbnMgb24gZmF0YWwgZXJyb3JzLlxuLy9cbi8vIHNyYzogdGhlIGlucHV0IFNBQk5GIGdyYW1tYXI8YnI+XG4vLyBtYXkgYmUgb25lIG9mOlxuLy8gLSBCdWZmZXIgb2YgYnl0ZXNcbi8vIC0gSmF2YVNjcmlwdCBzdHJpbmdcbi8vIC0gQXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBpKHNyYykge1xuICBjb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdhcGkuanM6ICc7XG4gIGNvbnN0IHRoaXNPYmplY3QgPSB0aGlzO1xuXG4gIC8qIFBSSVZBVEUgUFJPUEVSVElFUyAqL1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBjb252ZXJ0ZXIgPSByZXF1aXJlKCcuLi9hcGctY29udi1hcGkvY29udmVydGVyJyk7XG4gIGNvbnN0IHNjYW5uZXIgPSByZXF1aXJlKCcuL3NjYW5uZXInKTtcbiAgY29uc3QgcGFyc2VyID0gbmV3IChyZXF1aXJlKCcuL3BhcnNlcicpKSgpO1xuICBjb25zdCB7IGF0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVzLCBzaG93QXR0cmlidXRlRXJyb3JzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9ID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG4gIGNvbnN0IHNob3dSdWxlcyA9IHJlcXVpcmUoJy4vc2hvdy1ydWxlcycpO1xuXG4gIC8qIFBSSVZBVEUgTUVNQkVSUyAoRlVOQ1RJT05TKSAqL1xuICAvKiBDb252ZXJ0IGEgcGhyYXNlIChhcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMpIHRvIEhUTUwuICovXG4gIGNvbnN0IGFibmZUb0h0bWwgPSBmdW5jdGlvbiBhYm5mVG9IdG1sKGNoYXJzLCBiZWcsIGxlbikge1xuICAgIGNvbnN0IE5PUk1BTCA9IDA7XG4gICAgY29uc3QgQ09OVFJPTCA9IDE7XG4gICAgY29uc3QgSU5WQUxJRCA9IDI7XG4gICAgY29uc3QgQ09OVFJPTF9CRUcgPSBgPHNwYW4gY2xhc3M9XCIke2FwZ2xpYi5zdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj5gO1xuICAgIGNvbnN0IENPTlRST0xfRU5EID0gJzwvc3Bhbj4nO1xuICAgIGNvbnN0IElOVkFMSURfQkVHID0gYDxzcGFuIGNsYXNzPVwiJHthcGdsaWIuc3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5gO1xuICAgIGNvbnN0IElOVkFMSURfRU5EID0gJzwvc3Bhbj4nO1xuICAgIGxldCBlbmQ7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSB8fCBjaGFycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGJlZyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm5mVG9IdG1sOiBiZWcgbXVzdCBiZSB0eXBlIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKGJlZyA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicgfHwgYmVnICsgbGVuID49IGNoYXJzLmxlbmd0aCkge1xuICAgICAgICBlbmQgPSBjaGFycy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBiZWcgKyBsZW47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdGUgPSBOT1JNQUw7XG4gICAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2ggPSBjaGFyc1tpXTtcbiAgICAgICAgaWYgKGNoID49IDMyICYmIGNoIDw9IDEyNikge1xuICAgICAgICAgIC8qIG5vcm1hbCAtIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBDT05UUk9MKSB7XG4gICAgICAgICAgICBodG1sICs9IENPTlRST0xfRU5EO1xuICAgICAgICAgICAgc3RhdGUgPSBOT1JNQUw7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gSU5WQUxJRCkge1xuICAgICAgICAgICAgaHRtbCArPSBJTlZBTElEX0VORDtcbiAgICAgICAgICAgIHN0YXRlID0gTk9STUFMO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBoYW5kbGUgcmVzZXJ2ZWQgSFRNTCBlbnRpdHkgY2hhcmFjdGVycyAqL1xuICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZuYnNwOyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJmx0Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJmd0Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJmFtcDsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIGh0bWwgKz0gJyZxdW90Oyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgaHRtbCArPSAnJiMwMzk7JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgICAgICBodG1sICs9ICcmIzA5MjsnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGh0bWwgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOSB8fCBjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7XG4gICAgICAgICAgLyogY29udHJvbCBjaGFyYWN0ZXJzICovXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBOT1JNQUwpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gQ09OVFJPTF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IENPTlRST0w7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gSU5WQUxJRCkge1xuICAgICAgICAgICAgaHRtbCArPSBJTlZBTElEX0VORCArIENPTlRST0xfQkVHO1xuICAgICAgICAgICAgc3RhdGUgPSBDT05UUk9MO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2ggPT09IDkpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJ1RBQic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaCA9PT0gMTApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJ0xGJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoID09PSAxMykge1xuICAgICAgICAgICAgaHRtbCArPSAnQ1InO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpbnZhbGlkIGNoYXJhY3RlcnMgKi9cbiAgICAgICAgICBpZiAoc3RhdGUgPT09IE5PUk1BTCkge1xuICAgICAgICAgICAgaHRtbCArPSBJTlZBTElEX0JFRztcbiAgICAgICAgICAgIHN0YXRlID0gSU5WQUxJRDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBDT05UUk9MKSB7XG4gICAgICAgICAgICBodG1sICs9IENPTlRST0xfRU5EICsgSU5WQUxJRF9CRUc7XG4gICAgICAgICAgICBzdGF0ZSA9IElOVkFMSUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGRpc3BsYXkgY2hhcmFjdGVyIGFzIGhleGFkZWNpbWFsIHZhbHVlICovXG4gICAgICAgICAgaHRtbCArPSBgXFxcXHgke2FwZ2xpYi51dGlscy5jaGFyVG9IZXgoY2gpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gSU5WQUxJRCkge1xuICAgICAgICBodG1sICs9IElOVkFMSURfRU5EO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBDT05UUk9MKSB7XG4gICAgICAgIGh0bWwgKz0gQ09OVFJPTF9FTkQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIENvbnZlcnQgYSBwaHJhc2UgKGFycmF5IG9mIGNoYXJhY3RlciBjb2RlcykgdG8gQVNDSUkgdGV4dC4gKi9cbiAgY29uc3QgYWJuZlRvQXNjaWkgPSBmdW5jdGlvbiBhYm5mVG9Bc2NpaShjaGFycywgYmVnLCBsZW4pIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjaCA9IGNoYXJzW2ldO1xuICAgICAgaWYgKGNoID49IDMyICYmIGNoIDw9IDEyNikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgc3RyICs9ICdcXFxccic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3RyICs9ICdcXFxcdW5rbm93bic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICAvKiB0cmFuc2xhdGUgbGluZXMgKFNBQk5GIGdyYW1tYXIpIHRvIEFTQ0lJIHRleHQgKi9cbiAgY29uc3QgbGluZXNUb0FzY2lpID0gZnVuY3Rpb24gbGluZXNUb0FzY2lpKGxpbmVzKSB7XG4gICAgbGV0IHN0ciA9ICdBbm5vdGF0ZWQgSW5wdXQgR3JhbW1hcic7XG4gICAgbGluZXMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICBzdHIgKz0gYGxpbmUgbm86ICR7dmFsLmxpbmVOb31gO1xuICAgICAgc3RyICs9IGAgOiBjaGFyIGluZGV4OiAke3ZhbC5iZWdpbkNoYXJ9YDtcbiAgICAgIHN0ciArPSBgIDogbGVuZ3RoOiAke3ZhbC5sZW5ndGh9YDtcbiAgICAgIHN0ciArPSBgIDogYWJuZjogJHthYm5mVG9Bc2NpaSh0aGlzT2JqZWN0LmNoYXJzLCB2YWwuYmVnaW5DaGFyLCB2YWwubGVuZ3RoKX1gO1xuICAgIH0pO1xuICAgIHN0ciArPSAnXFxuJztcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICAvKiB0cmFuc2xhdGUgbGluZXMgKFNBQk5GIGdyYW1tYXIpIHRvIEhUTUwgKi9cbiAgY29uc3QgbGluZXNUb0h0bWwgPSBmdW5jdGlvbiBsaW5lc1RvSHRtbChsaW5lcykge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSBgPHRhYmxlIGNsYXNzPVwiJHthcGdsaWIuc3R5bGUuQ0xBU1NfR1JBTU1BUn1cIj5cXG5gO1xuICAgIGNvbnN0IHRpdGxlID0gJ0Fubm90YXRlZCBJbnB1dCBHcmFtbWFyJztcbiAgICBodG1sICs9IGA8Y2FwdGlvbj4ke3RpdGxlfTwvY2FwdGlvbj5cXG5gO1xuICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgIGh0bWwgKz0gJzx0aD5saW5lPGJyPm5vLjwvdGg+PHRoPmZpcnN0PGJyPmNoYXI8L3RoPjx0aD48YnI+bGVuZ3RoPC90aD48dGg+PGJyPnRleHQ8L3RoPic7XG4gICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgIGxpbmVzLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICBodG1sICs9IGA8dGQ+JHt2YWwubGluZU5vfWA7XG4gICAgICBodG1sICs9IGA8L3RkPjx0ZD4ke3ZhbC5iZWdpbkNoYXJ9YDtcbiAgICAgIGh0bWwgKz0gYDwvdGQ+PHRkPiR7dmFsLmxlbmd0aH1gO1xuICAgICAgaHRtbCArPSBgPC90ZD48dGQ+JHthYm5mVG9IdG1sKHRoaXNPYmplY3QuY2hhcnMsIHZhbC5iZWdpbkNoYXIsIHZhbC5sZW5ndGgpfWA7XG4gICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICBodG1sICs9ICc8L3RyPlxcbic7XG4gICAgfSk7XG5cbiAgICBodG1sICs9ICc8L3RhYmxlPlxcbic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIEZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZXMgdG8gSFRNTCwgZm9yIHBhZ2UgZGlzcGxheS4gKi9cbiAgY29uc3QgZXJyb3JzVG9IdG1sID0gZnVuY3Rpb24gZXJyb3JzVG9IdG1sKGVycm9ycywgbGluZXMsIGNoYXJzLCB0aXRsZSkge1xuICAgIGNvbnN0IFtzdHlsZV0gPSBhcGdsaWI7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBjb25zdCBlcnJvckFycm93ID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiZyYXF1bzs8L3NwYW4+YDtcbiAgICBodG1sICs9IGA8cD48dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0dSQU1NQVJ9XCI+XFxuYDtcbiAgICBpZiAodGl0bGUgJiYgdHlwZW9mIHRpdGxlID09PSAnc3RyaW5nJykge1xuICAgICAgaHRtbCArPSBgPGNhcHRpb24+JHt0aXRsZX08L2NhcHRpb24+XFxuYDtcbiAgICB9XG4gICAgaHRtbCArPSAnPHRyPjx0aD5saW5lPGJyPm5vLjwvdGg+PHRoPmxpbmU8YnI+b2Zmc2V0PC90aD48dGg+ZXJyb3I8YnI+b2Zmc2V0PC90aD48dGg+PGJyPnRleHQ8L3RoPjwvdHI+XFxuJztcbiAgICBlcnJvcnMuZm9yRWFjaCgodmFsKSA9PiB7XG4gICAgICBsZXQgbGluZTtcbiAgICAgIGxldCByZWxjaGFyO1xuICAgICAgbGV0IGJlZztcbiAgICAgIGxldCBlbmQ7XG4gICAgICBsZXQgdGV4dDtcbiAgICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgIGxldCBzdWZmaXggPSAnJztcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGV4dCA9IGVycm9yQXJyb3c7XG4gICAgICAgIHJlbGNoYXIgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW3ZhbC5saW5lXTtcbiAgICAgICAgYmVnID0gbGluZS5iZWdpbkNoYXI7XG4gICAgICAgIGlmICh2YWwuY2hhciA+IGJlZykge1xuICAgICAgICAgIHByZWZpeCA9IGFibmZUb0h0bWwoY2hhcnMsIGJlZywgdmFsLmNoYXIgLSBiZWcpO1xuICAgICAgICB9XG4gICAgICAgIGJlZyA9IHZhbC5jaGFyO1xuICAgICAgICBlbmQgPSBsaW5lLmJlZ2luQ2hhciArIGxpbmUubGVuZ3RoO1xuICAgICAgICBpZiAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgc3VmZml4ID0gYWJuZlRvSHRtbChjaGFycywgYmVnLCBlbmQgLSBiZWcpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBwcmVmaXggKyBlcnJvckFycm93ICsgc3VmZml4O1xuICAgICAgICByZWxjaGFyID0gdmFsLmNoYXIgLSBsaW5lLmJlZ2luQ2hhcjtcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZD4ke3ZhbC5saW5lfTwvdGQ+PHRkPiR7bGluZS5iZWdpbkNoYXJ9PC90ZD48dGQ+JHtyZWxjaGFyfTwvdGQ+PHRkPiR7dGV4dH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICAgICAgaHRtbCArPSAnPHRyPic7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjb2xzcGFuPVwiM1wiPjwvdGQ+PHRkPiZ1YXJyOzombmJzcDske2FwZ2xpYi51dGlscy5zdHJpbmdUb0FzY2lpSHRtbCh2YWwubXNnKX08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBodG1sICs9ICc8L3RhYmxlPjwvcD5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBEaXNwbGF5IGFuIGFycmF5IG9mIGVycm9ycyBpbiBBU0NJSSB0ZXh0ICovXG4gIGNvbnN0IGVycm9yc1RvQXNjaWkgPSBmdW5jdGlvbiBlcnJvcnNUb0FzY2lpKGVycm9ycywgbGluZXMsIGNoYXJzKSB7XG4gICAgbGV0IHN0cjtcbiAgICBsZXQgbGluZTtcbiAgICBsZXQgYmVnO1xuICAgIGxldCBsZW47XG4gICAgc3RyID0gJyc7XG4gICAgZXJyb3JzLmZvckVhY2goKGVycm9yKSA9PiB7XG4gICAgICBsaW5lID0gbGluZXNbZXJyb3IubGluZV07XG4gICAgICBzdHIgKz0gYCR7bGluZS5saW5lTm99OiBgO1xuICAgICAgc3RyICs9IGAke2xpbmUuYmVnaW5DaGFyfTogYDtcbiAgICAgIHN0ciArPSBgJHtlcnJvci5jaGFyIC0gbGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgYmVnID0gbGluZS5iZWdpbkNoYXI7XG4gICAgICBsZW4gPSBlcnJvci5jaGFyIC0gbGluZS5iZWdpbkNoYXI7XG4gICAgICBzdHIgKz0gYWJuZlRvQXNjaWkoY2hhcnMsIGJlZywgbGVuKTtcbiAgICAgIHN0ciArPSAnID4+ICc7XG4gICAgICBiZWcgPSBlcnJvci5jaGFyO1xuICAgICAgbGVuID0gbGluZS5iZWdpbkNoYXIgKyBsaW5lLmxlbmd0aCAtIGVycm9yLmNoYXI7XG4gICAgICBzdHIgKz0gYWJuZlRvQXNjaWkoY2hhcnMsIGJlZywgbGVuKTtcbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgIHN0ciArPSBgJHtsaW5lLmxpbmVOb306IGA7XG4gICAgICBzdHIgKz0gYCR7bGluZS5iZWdpbkNoYXJ9OiBgO1xuICAgICAgc3RyICs9IGAke2Vycm9yLmNoYXIgLSBsaW5lLmJlZ2luQ2hhcn06IGA7XG4gICAgICBzdHIgKz0gJ2Vycm9yOiAnO1xuICAgICAgc3RyICs9IGVycm9yLm1zZztcbiAgICAgIHN0ciArPSAnXFxuJztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBsZXQgaXNTY2FubmVkID0gZmFsc2U7XG4gIGxldCBpc1BhcnNlZCA9IGZhbHNlO1xuICBsZXQgaXNUcmFuc2xhdGVkID0gZmFsc2U7XG4gIGxldCBoYXZlQXR0cmlidXRlcyA9IGZhbHNlO1xuICBsZXQgYXR0cmlidXRlRXJyb3JzID0gMDtcbiAgbGV0IGxpbmVNYXA7XG5cbiAgLyogUFVCTElDIFBST1BFUlRJRVMgKi9cbiAgLy8gVGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgYXMgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiAgLy8gdGhpcy5zYWJuZjtcbiAgLy8gVGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzLlxuICAvLyB0aGlzLmNoYXJzO1xuICAvLyBBbiBhcnJheSBvZiBsaW5lIG9iamVjdHMsIGRlZmluaW5nIGVhY2ggbGluZSBvZiB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hclxuICAvLyAtIGxpbmVObyA6IHRoZSB6ZXJvLWJhc2VkIGxpbmUgbnVtYmVyXG4gIC8vIC0gYmVnaW5DaGFyIDogb2Zmc2V0IChpbnRvIGB0aGlzLmNoYXJzYCkgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgbGluZVxuICAvLyAtIGxlbmd0aCA6IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgbGluZVxuICAvLyAtIHRleHRMZW5ndGggOiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb2YgdGV4dCBpbiB0aGUgbGluZSwgZXhjbHVkaW5nIHRoZSBsaW5lIGVuZGluZyBjaGFyYWN0ZXJzXG4gIC8vIC0gZW5kVHlwZSA6IFwiQ1JMRlwiLCBcIkxGXCIsIFwiQ1JcIiBvciBcIm5vbmVcIiBpZiB0aGUgbGFzdCBsaW5lIGhhcyBubyBsaW5lIGVuZGluZyBjaGFyYWN0ZXJzXG4gIC8vIC0gaW52YWxpZENoYXJzIDogYHRydWVgIGlmIHRoZSBsaW5lIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycywgYGZhbHNlYCBvdGhlcndpc2VcbiAgLy8gdGhpcy5saW5lcztcbiAgLy8gQW4gYXJyYXkgb2YgcnVsZSBuYW1lcyBhbmQgZGF0YS5cbiAgLy8gLSBuYW1lIDogdGhlIHJ1bGUgbmFtZVxuICAvLyAtIGxvd2VyIDogdGhlIHJ1bGUgbmFtZSBpbiBsb3dlciBjYXNlXG4gIC8vIC0gaW5kZXggOiB0aGUgaW5kZXggb2YgdGhlIHJ1bGUgKG9yZGVyZWQgYnkgYXBwZWFyYW5jZSBpbiBTQUJORiBncmFtbWFyKVxuICAvLyAtIGlzQmtyIDogYHRydWVgIGlmIHRoaXMgcnVsZSBoYXMgYmVlbiBiYWNrIHJlZmVyZW5jZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gIC8vIC0gb3Bjb2RlcyA6IGFycmF5IG9mIG9wY29kZXMgZm9yIHRoaXMgcnVsZVxuICAvLyAtIGF0dHJzIDogdGhlIHJ1bGUgYXR0cmlidXRlc1xuICAvLyAtIGN0cmwgOiBzeXN0ZW0gZGF0YVxuICAvLyB0aGlzLnJ1bGVzO1xuICAvLyBBbiBhcnJheSBvZiBVRFQgbmFtZXMgYW5kIGRhdGEuXG4gIC8vIHRoaXMudWR0cztcbiAgLy8gQW4gYXJyYXkgb2YgZXJyb3JzLCBpZiBhbnkuXG4gIC8vIC0gbGluZSA6IHRoZSBsaW5lIG51bWJlciBjb250YWluaW5nIHRoZSBlcnJvclxuICAvLyAtIGNoYXIgOiB0aGUgY2hhcmFjdGVyIG9mZnNldCBvZiB0aGUgZXJyb3JcbiAgLy8gLSBtc2cgOiB0aGUgZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVycm9ycyA9IFtdO1xuXG4gIC8qIENPTlNUUlVDVE9SICovXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3JjKSkge1xuICAgIHRoaXMuY2hhcnMgPSBjb252ZXJ0ZXIuZGVjb2RlKCdCSU5BUlknLCBzcmMpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIHRoaXMuY2hhcnMgPSBzcmMuc2xpY2UoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hhcnMgPSBjb252ZXJ0ZXIuZGVjb2RlKCdTVFJJTkcnLCBzcmMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aW5wdXQgc291cmNlIGlzIG5vdCBhIHN0cmluZywgYnl0ZSBCdWZmZXIgb3IgY2hhcmFjdGVyIGFycmF5YCk7XG4gIH1cbiAgdGhpcy5zYWJuZiA9IGNvbnZlcnRlci5lbmNvZGUoJ1NUUklORycsIHRoaXMuY2hhcnMpO1xuXG4gIC8qIFBVQkxJQyBNRU1CRVJTIChGVU5DVElPTlMpICovXG4gIC8vIFNjYW4gdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgZm9yIGludmFsaWQgY2hhcmFjdGVycyBhbmQgY2F0YWxvZyB0aGUgbGluZXMgdmlhIGB0aGlzLmxpbmVzYC5cbiAgLy8gLSBzdHJpY3QgOiAob3B0aW9uYWwpIGlmIGB0cnVlYCwgYWxsIGxpbmVzLCBpbmNsdWRpbmcgdGhlIGxhc3QgbXVzdCBlbmQgd2l0aCBDUkxGIChcXHJcXG4pLFxuICAvLyBpZiBgZmFsc2VgIChpbiBhbnkgSmF2YVNjcmlwdCBzZW5zZSkgdGhlbiBsaW5lIGVuZGluZ3MgbWF5IGJlIGFueSBtaXggb2YgQ1JMRiwgTEYsIENSLCBvciBlbmQtb2YtZmlsZS5cbiAgLy8gLSB0cmFjZSAoKikgOiAob3B0aW9uYWwpIGEgcGFyc2VyIHRyYWNlIG9iamVjdCwgd2hpY2ggd2lsbCB0cmFjZSB0aGUgcGFyc2VyIHRoYXQgZG9lcyB0aGUgc2NhblxuICB0aGlzLnNjYW4gPSBmdW5jdGlvbiBzY2FuKHN0cmljdCwgdHJhY2UpIHtcbiAgICB0aGlzLmxpbmVzID0gc2Nhbm5lcih0aGlzLmNoYXJzLCB0aGlzLmVycm9ycywgc3RyaWN0LCB0cmFjZSk7XG4gICAgaXNTY2FubmVkID0gdHJ1ZTtcbiAgfTtcbiAgLy8gUGFyc2UgdGhlIGlucHV0IFNBQk5GIGdyYW1tYXIgZm9yIGNvcnJlY3Qgc3ludGF4LlxuICAvLyAtIHN0cmljdCA6IChvcHRpb25hbCkgaWYgYHRydWVgLCB0aGUgaW5wdXQgZ3JhbW1hciBtdXN0IGJlIHN0cmljdCBBQk5GLCBjb25mb3JtaW5nIHRvIFtSRkMgNTIzNF0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUyMzQpXG4gIC8vIGFuZCBbUkZDIDc0MDVdKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NDA1KS4gTm8gc3VwZXJzZXQgZmVhdHVyZXMgYWxsb3dlZC5cbiAgLy8gLSB0cmFjZSAoXFwqKSA6IChvcHRpb25hbCkgYSBwYXJzZXIgdHJhY2Ugb2JqZWN0LCB3aGljaCB3aWxsIHRyYWNlIHRoZSBzeW50YXggcGFyc2VyXG4gIC8vXG4gIC8vIDxpPigqKU5PVEU6IHRoZSB0cmFjZSBvcHRpb24gd2FzIHVzZWQgcHJpbWFyaWx5IGR1cmluZyBkZXZlbG9wbWVudC5cbiAgLy8gRXJyb3IgZGV0ZWN0aW9uIGFuZCByZXBvcnRpbmcgaXMgbm93IGZhaXJseSByb2J1c3QgYW5kIHRyYWNpbmcgc2hvdWxkIGJlIHVubmVjZXNzYXJ5LiBVc2UgYXQgeW91ciBvd24gcGVyaWwuPC9pPlxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc3RyaWN0LCBsaXRlLCB0cmFjZSkge1xuICAgIGlmICghaXNTY2FubmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWdyYW1tYXIgbm90IHNjYW5uZWRgKTtcbiAgICB9XG4gICAgcGFyc2VyLnN5bnRheCh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLmVycm9ycywgc3RyaWN0LCBsaXRlLCB0cmFjZSk7XG4gICAgaXNQYXJzZWQgPSB0cnVlO1xuICB9O1xuICAvLyBUcmFuc2xhdGUgdGhlIFNBQk5GIGdyYW1tYXIgc3ludGF4IGludG8gdGhlIG9wY29kZXMgdGhhdCB3aWxsIGd1aWRlIHRoZSBwYXJzZXIgZm9yIHRoaXMgZ3JhbW1hci5cbiAgdGhpcy50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUoKSB7XG4gICAgaWYgKCFpc1BhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkIGFuZCBwYXJzZWRgKTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcGFyc2VyLnNlbWFudGljKHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzKTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gcmV0LnJ1bGVzO1xuICAgICAgdGhpcy51ZHRzID0gcmV0LnVkdHM7XG4gICAgICBsaW5lTWFwID0gcmV0LmxpbmVNYXA7XG4gICAgICBpc1RyYW5zbGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgLy8gQ29tcHV0ZSB0aGUgYXR0cmlidXRlcyBvZiBlYWNoIHJ1bGUuXG4gIHRoaXMuYXR0cmlidXRlcyA9IGZ1bmN0aW9uIGF0dHJzKCkge1xuICAgIGlmICghaXNUcmFuc2xhdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWdyYW1tYXIgbm90IHNjYW5uZWQsIHBhcnNlZCBhbmQgdHJhbnNsYXRlZGApO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVFcnJvcnMgPSBhdHRyaWJ1dGVzKHRoaXMucnVsZXMsIHRoaXMudWR0cywgbGluZU1hcCwgdGhpcy5lcnJvcnMpO1xuICAgIGhhdmVBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICByZXR1cm4gYXR0cmlidXRlRXJyb3JzO1xuICB9O1xuICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZnVsbCBzdWl0ZSBvZiBzdGVwcyByZXF1aXJlZCB0byBnZW5lcmF0ZSBhIHBhcnNlciBncmFtbWFyIG9iamVjdFxuICAvLyBmcm9tIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyLlxuICB0aGlzLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoc3RyaWN0KSB7XG4gICAgdGhpcy5saW5lcyA9IHNjYW5uZXIodGhpcy5jaGFycywgdGhpcy5lcnJvcnMsIHN0cmljdCk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwYXJzZXIuc3ludGF4KHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzLCBzdHJpY3QpO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gcGFyc2VyLnNlbWFudGljKHRoaXMuY2hhcnMsIHRoaXMubGluZXMsIHRoaXMuZXJyb3JzKTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucnVsZXMgPSByZXQucnVsZXM7XG4gICAgdGhpcy51ZHRzID0gcmV0LnVkdHM7XG4gICAgbGluZU1hcCA9IHJldC5saW5lTWFwO1xuXG4gICAgYXR0cmlidXRlRXJyb3JzID0gYXR0cmlidXRlcyh0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIGxpbmVNYXAsIHRoaXMuZXJyb3JzKTtcbiAgICBoYXZlQXR0cmlidXRlcyA9IHRydWU7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGVzLlxuICAvLyBNdXN0IHNjYW4sIHBhcnNlIGFuZCB0cmFuc2xhdGUgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgb3RoZXJ3aXNlIHRoZXJlIGFyZSBubyBydWxlcyB0byBkaXNwbGF5LlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICB0aGlzLmRpc3BsYXlSdWxlcyA9IGZ1bmN0aW9uIGRpc3BsYXlSdWxlcyhvcmRlciA9ICdpbmRleCcpIHtcbiAgICBpZiAoIWlzVHJhbnNsYXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ncmFtbWFyIG5vdCBzY2FubmVkLCBwYXJzZWQgYW5kIHRyYW5zbGF0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dSdWxlcyh0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIG9yZGVyKTtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMuXG4gIC8vIE11c3Qgc2NhbiwgcGFyc2UsIHRyYW5zbGF0ZSBhbmQgY29tcHV0ZSBhdHRyaWJ1dGVzIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gIC8vIE90aGVyd2lzZSB0aGUgcnVsZSBkZXBlbmRlbmNpZXMgYXJlIG5vdCBrbm93bi5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICB0aGlzLmRpc3BsYXlSdWxlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gZGlzcGxheVJ1bGVEZXBlbmRlbmNpZXMob3JkZXIgPSAnaW5kZXgnKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1ubyBhdHRyaWJ1dGVzIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dSdWxlRGVwZW5kZW5jaWVzKG9yZGVyKTtcbiAgfTtcbiAgLy8gRGlzcGxheSB0aGUgYXR0cmlidXRlcy5cbiAgLy8gTXVzdCBzY2FuLCBwYXJzZSwgdHJhbnNsYXRlIGFuZCBjb21wdXRlIGF0dHJpYnV0ZXMgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgLy8gLSBvcmRlclxuICAvLyAgICAgIC0gXCJpbmRleFwiIG9yIFwiaVwiLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgLy8gICAgICAtIFwiYWxwaGFcIiBvciBcImFcIiwgYWxwaGFiZXRpY2FsIG9yZGVyXG4gIC8vICAgICAgLSBcInR5cGVcIiBvciBcInRcIiwgb3JkZXJlZCBieSB0eXBlIChhbHBoYWJldGljYWwgd2l0aGluIGVhY2ggdHlwZS9ncm91cClcbiAgLy8gICAgICAtIG5vbmUgb2YgYWJvdmUsIHR5cGUgb3JkZXIgKGRlZmF1bHQpXG4gIHRoaXMuZGlzcGxheUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBkaXNwbGF5QXR0cmlidXRlcyhvcmRlciA9ICdpbmRleCcpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW5vIGF0dHJpYnV0ZXMgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlRXJyb3JzKSB7XG4gICAgICBzaG93QXR0cmlidXRlRXJyb3JzKG9yZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3dBdHRyaWJ1dGVzKG9yZGVyKTtcbiAgfTtcbiAgdGhpcy5kaXNwbGF5QXR0cmlidXRlRXJyb3JzID0gZnVuY3Rpb24gZGlzcGxheUF0dHJpYnV0ZUVycm9ycygpIHtcbiAgICBpZiAoIWhhdmVBdHRyaWJ1dGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfW5vIGF0dHJpYnV0ZXMgLSBtdXN0IGJlIHByZWNlZWRlZCBieSBjYWxsIHRvIGF0dHJpYnV0ZXMoKWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hvd0F0dHJpYnV0ZUVycm9ycygpO1xuICB9O1xuICAvLyBSZXR1cm5zIGEgcGFyc2VyIGdyYW1tYXIgb2JqZWN0IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGFzIGEgSmF2YVNjcmlwdCBzdHJpbmcuXG4gIC8vIFRoaXMgb2JqZWN0IGNhbiB0aGVuIGJlIHVzZWQgdG8gY29uc3RydWN0IGEgcGFyc2VyLlxuICB0aGlzLnRvU291cmNlID0gZnVuY3Rpb24gdG9Tb3VyY2UoY29uZmlnID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFoYXZlQXR0cmlidXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jYW4ndCBnZW5lcmF0ZSBwYXJzZXIgc291cmNlIC0gbXVzdCBiZSBwcmVjZWVkZWQgYnkgY2FsbCB0byBhdHRyaWJ1dGVzKClgKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZUVycm9ycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jYW4ndCBnZW5lcmF0ZSBwYXJzZXIgc291cmNlIC0gYXR0cmlidXRlcyBoYXZlICR7YXR0cmlidXRlRXJyb3JzfSBlcnJvcnNgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5nZW5lcmF0ZVNvdXJjZSh0aGlzLmNoYXJzLCB0aGlzLmxpbmVzLCB0aGlzLnJ1bGVzLCB0aGlzLnVkdHMsIGNvbmZpZyk7XG4gIH07XG4gIC8vIFJldHVybnMgYSBwYXJzZXIgZ3JhbW1hciBvYmplY3QuXG4gIC8vIFRoaXMgZ3JhbW1hciBvYmplY3QgbWF5IGJlIHVzZWQgYnkgdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnN0cnVjdCBhIHBhcnNlci5cbiAgdGhpcy50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgIGlmICghaGF2ZUF0dHJpYnV0ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIG11c3QgYmUgcHJlY2VlZGVkIGJ5IGNhbGwgdG8gYXR0cmlidXRlcygpYCk7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2FuJ3QgZ2VuZXJhdGUgcGFyc2VyIHNvdXJjZSAtIGF0dHJpYnV0ZXMgaGF2ZSAke2F0dHJpYnV0ZUVycm9yc30gZXJyb3JzYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIuZ2VuZXJhdGVPYmplY3QodGhpcy5zYWJuZiwgdGhpcy5ydWxlcywgdGhpcy51ZHRzKTtcbiAgfTtcbiAgLy8gRGlzcGxheSBlcnJvcnMgaW4gdGV4dCBmb3JtYXQsIHN1aXRhYmxlIGZvciBgY29uc29sZS5sb2coKWAuXG4gIHRoaXMuZXJyb3JzVG9Bc2NpaSA9IGZ1bmN0aW9uIGVycm9yc1RvQXNjaWlGdW5jKCkge1xuICAgIHJldHVybiBlcnJvcnNUb0FzY2lpKHRoaXMuZXJyb3JzLCB0aGlzLmxpbmVzLCB0aGlzLmNoYXJzKTtcbiAgfTtcbiAgLy8gRGlzcGxheSBlcnJvcnMgaW4gSFRNTCBmb3JtYXQsIHN1aXRhYmxlIGZvciB3ZWIgcGFnZSBkaXNwbGF5LlxuICAvLyAoYGFwZy1saWIuY3NzYCByZXF1aXJlZCBmb3IgcHJvcGVyIHN0eWxpbmcpXG4gIHRoaXMuZXJyb3JzVG9IdG1sID0gZnVuY3Rpb24gZXJyb3JzVG9IdG1sRnVuYyh0aXRsZSkge1xuICAgIHJldHVybiBlcnJvcnNUb0h0bWwodGhpcy5lcnJvcnMsIHRoaXMubGluZXMsIHRoaXMuY2hhcnMsIHRpdGxlKTtcbiAgfTtcbiAgLy8gR2VuZXJhdGUgYW4gYW5ub3RhdGVkIHRoZSBTQUJORiBncmFtbWFyIGRpc3BsYXkgaW4gdGV4dCBmb3JtYXQuXG4gIHRoaXMubGluZXNUb0FzY2lpID0gZnVuY3Rpb24gbGluZXNUb0FzY2lpRnVuYygpIHtcbiAgICByZXR1cm4gbGluZXNUb0FzY2lpKHRoaXMubGluZXMpO1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhbiBhbm5vdGF0ZWQgdGhlIFNBQk5GIGdyYW1tYXIgZGlzcGxheSBpbiBIVE1MIGZvcm1hdC5cbiAgLy8gKGBhcGctbGliLmNzc2AgcmVxdWlyZWQgZm9yIHByb3BlciBzdHlsaW5nKVxuICB0aGlzLmxpbmVzVG9IdG1sID0gZnVuY3Rpb24gbGluZXNUb0h0bWxGdW5jKCkge1xuICAgIHJldHVybiBsaW5lc1RvSHRtbCh0aGlzLmxpbmVzKTtcbiAgfTtcbiAgLy8gVGhpcyBmdW5jdGlvbiB3YXMgb25seSB1c2VkIGJ5IGFwZy5odG1sIHdoaWNoIGhhcyBiZWVuIGFiYW5kb25lZC5cbiAgLypcbiAgICB0aGlzLmdldEF0dHJpYnV0ZXNPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgKi9cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/attributes.js":
/*!*******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/attributes.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable class-methods-use-this */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are “aggregate” attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite – always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\nmodule.exports = (function exportAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const { ruleAttributes, showAttributes, showAttributeErrors } = __webpack_require__(/*! ./rule-attributes */ \"(ssr)/./node_modules/apg-js/src/apg-api/rule-attributes.js\");\n  const { ruleDependencies, showRuleDependencies } = __webpack_require__(/*! ./rule-dependencies */ \"(ssr)/./node_modules/apg-js/src/apg-api/rule-dependencies.js\");\n  class State {\n    constructor(rules, udts) {\n      this.rules = rules;\n      this.udts = udts;\n      this.ruleCount = rules.length;\n      this.udtCount = udts.length;\n      this.startRule = 0;\n      this.dependenciesComplete = false;\n      this.attributesComplete = false;\n      this.isMutuallyRecursive = false;\n      this.ruleIndexes = this.indexArray(this.ruleCount);\n      this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n      this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n      this.udtIndexes = this.indexArray(this.udtCount);\n      this.udtAlphaIndexes = this.indexArray(this.udtCount);\n      this.attrsErrorCount = 0;\n      this.attrs = [];\n      this.attrsErrors = [];\n      this.attrsWorking = [];\n      this.ruleDeps = [];\n      for (let i = 0; i < this.ruleCount; i += 1) {\n        this.attrs.push(this.attrGen(this.rules[i]));\n        this.attrsWorking.push(this.attrGen(this.rules[i]));\n        this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n      }\n      this.compRulesAlpha = this.compRulesAlpha.bind(this);\n      this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n      this.compRulesType = this.compRulesType.bind(this);\n      this.compRulesGroup = this.compRulesGroup.bind(this);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrGen(rule) {\n      return {\n        left: false,\n        nested: false,\n        right: false,\n        empty: false,\n        finite: false,\n        cyclic: false,\n        leaf: false,\n        isOpen: false,\n        isComplete: false,\n        rule,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrInit(attr) {\n      attr.left = false;\n      attr.nested = false;\n      attr.right = false;\n      attr.empty = false;\n      attr.finite = false;\n      attr.cyclic = false;\n      attr.leaf = false;\n      attr.isOpen = false;\n      attr.isComplete = false;\n    }\n\n    attrCopy(dst, src) {\n      dst.left = src.left;\n      dst.nested = src.nested;\n      dst.right = src.right;\n      dst.empty = src.empty;\n      dst.finite = src.finite;\n      dst.cyclic = src.cyclic;\n      dst.leaf = src.leaf;\n      dst.isOpen = src.isOpen;\n      dst.isComplete = src.isComplete;\n      dst.rule = src.rule;\n    }\n\n    rdGen(rule, ruleCount, udtCount) {\n      const ret = {\n        rule,\n        recursiveType: id.ATTR_N,\n        groupNumber: -1,\n        refersTo: this.falseArray(ruleCount),\n        refersToUdt: this.falseArray(udtCount),\n        referencedBy: this.falseArray(ruleCount),\n      };\n      return ret;\n    }\n\n    typeToString(recursiveType) {\n      switch (recursiveType) {\n        case id.ATTR_N:\n          return ' N';\n        case id.ATTR_R:\n          return ' R';\n        case id.ATTR_MR:\n          return 'MR';\n        default:\n          return 'UNKNOWN';\n      }\n    }\n\n    falseArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(false);\n        }\n      }\n      return ret;\n    }\n\n    falsifyArray(a) {\n      for (let i = 0; i < a.length; i += 1) {\n        a[i] = false;\n      }\n    }\n\n    indexArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(i);\n        }\n      }\n      return ret;\n    }\n\n    compRulesAlpha(left, right) {\n      if (this.rules[left].lower < this.rules[right].lower) {\n        return -1;\n      }\n      if (this.rules[left].lower > this.rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compUdtsAlpha(left, right) {\n      if (this.udts[left].lower < this.udts[right].lower) {\n        return -1;\n      }\n      if (this.udts[left].lower > this.udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesType(left, right) {\n      if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n        return -1;\n      }\n      if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesGroup(left, right) {\n      if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n        if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n          return -1;\n        }\n        if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }\n  // eslint-disable-next-line no-unused-vars\n  const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n    // let i = 0;\n    // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n    const state = new State(rules, udts);\n\n    // Determine all rule dependencies\n    //  - which rules each rule refers to\n    //  - which rules reference each rule\n    ruleDependencies(state);\n\n    // Determine the attributes for each rule.\n    ruleAttributes(state);\n    if (state.attrsErrorCount) {\n      errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });\n    }\n\n    // Return the number of attribute errors to the caller.\n    return state.attrsErrorCount;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0ZBQXdCO0FBQzdDLFVBQVUsc0RBQXNELEVBQUUsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDN0YsVUFBVSx5Q0FBeUMsRUFBRSxtQkFBTyxDQUFDLHlGQUFxQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQix1QkFBdUIsbUJBQW1CO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL2F0dHJpYnV0ZXMuanM/ZDAzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzICovXG4vKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBBdHRyaWJ1dGVzIFZhbGlkYXRpb25cbi8vXG4vLyBJdCBpcyB3ZWxsIGtub3duIHRoYXQgcmVjdXJzaXZlLWRlc2NlbnQgcGFyc2VycyB3aWxsIGZhaWwgaWYgYSBydWxlIGlzIGxlZnQgcmVjdXJzaXZlLlxuLy8gQmVzaWRlcyBsZWZ0IHJlY3Vyc2lvbiwgdGhlcmUgYXJlIGEgY291cGxlIG9mIG90aGVyIGZhdGFsIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHRvIGJlIGRpc2Nsb3NlZCBhcyB3ZWxsLlxuLy8gVGhlcmUgYXJlIHNldmVyYWwgbm9uLWZhdGFsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgb2YgaW50ZXJlc3QgYWxzby5cbi8vIFRoaXMgbW9kdWxlIHdpbGwgZGV0ZXJtaW5lIHNpeCBkaWZmZXJlbnQgYXR0cmlidXRlcyBsaXN0ZWQgaGVyZSB3aXRoIHNpbXBsZSBleGFtcGxlcy5cbi8vXG4vLyAqKmZhdGFsIGF0dHJpYnV0ZXMqKjxicj5cbi8vIGxlZnQgcmVjdXJzaW9uPGJyPlxuLy8gUyA9IFMgXCJ4XCIgLyBcInlcIlxuLy9cbi8vIGN5Y2xpYzxicj5cbi8vIFMgPSBTXG4vL1xuLy8gaW5maW5pdGU8YnI+XG4vLyBTID0gXCJ5XCIgU1xuLy9cbi8vICoqbm9uLWZhdGFsIGF0dHJpYnV0ZXMqKiAoYnV0IG5pY2UgdG8ga25vdyk8YnI+XG4vLyBuZXN0ZWQgcmVjdXJzaW9uPGJyPlxuLy8gUyA9IFwiYVwiIFMgXCJiXCIgLyBcInlcIlxuLy9cbi8vIHJpZ2h0IHJlY3Vyc2lvbjxicj5cbi8vIFMgPSBcInhcIiBTIC8gXCJ5XCJcbi8vXG4vLyBlbXB0eSBzdHJpbmc8YnI+XG4vLyBTID0gXCJ4XCIgUyAvIFwiXCJcbi8vXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXJlIOKAnGFnZ3JlZ2F0ZeKAnSBhdHRyaWJ1dGVzLCBpbiB0aGF0IGlmIHRoZSBhdHRyaWJ1dGUgaXMgdHJ1ZSBpdCBvbmx5IG1lYW5zIHRoYXQgaXQgY2FuIGJlIHRydWUsXG4vLyBub3QgdGhhdCBpdCB3aWxsIGFsd2F5cyBiZSB0cnVlIGZvciBldmVyeSBpbnB1dCBzdHJpbmcuXG4vLyBJbiB0aGUgc2ltcGxlIGV4YW1wbGVzIGFib3ZlIHRoZSBhdHRyaWJ1dGVzIG1heSBiZSBvYnZpb3VzIGFuZCBkZWZpbml0ZSDigJMgYWx3YXlzIHRydWUgb3IgZmFsc2UuXG4vLyBIb3dldmVyLCBmb3IgYSBsYXJnZSBncmFtbWFyIHdpdGggcG9zc2libHkgaHVuZHJlZHMgb2YgcnVsZXMgYW5kIHBhcnNlIHRyZWUgYnJhbmNoZXMsXG4vLyBpdCBjYW4gYmUgb2JzY3VyZSB3aGljaCBicmFuY2hlcyBsZWFkIHRvIHdoaWNoIGF0dHJpYnV0ZXMuXG4vLyBGdXJ0aGVybW9yZSwgZGlmZmVyZW50IGlucHV0IHN0cmluZ3Mgd2lsbCBsZWFkIHRoZSBwYXJzZXIgZG93biBkaWZmZXJlbnQgYnJhbmNoZXMuXG4vLyBPbmUgaW5wdXQgc3RyaW5nIG1heSBwYXJzZSBwZXJmZWN0bHkgd2hpbGUgYW5vdGhlciB3aWxsIGhpdCBhIGxlZnQtcmVjdXJzaXZlIGJyYW5jaCBhbmQgYm90dG9tIG91dCB0aGUgY2FsbCBzdGFjay5cbi8vXG4vLyBJdCBpcyBmb3IgdGhpcyByZWFzb24gdGhhdCB0aGUgQVBHIHBhcnNlciBnZW5lcmF0b3IgY29tcHV0ZXMgdGhlc2UgYXR0cmlidXRlcy5cbi8vIFdoZW4gdXNpbmcgdGhlIEFQSSB0aGUgYXR0cmlidXRlcyBjYWxsIGlzIG9wdGlvbmFsIGJ1dCBnZW5lcmF0aW5nIGEgcGFyc2VyIHdpdGhvdXQgY2hlY2tpbmcgdGhlIGF0dHJpYnV0ZXMgLSBwcm9jZWVkIGF0IHlvdXIgb3duIHBlcmlsLlxuLy9cbi8vIEFkZGl0aW9uYWxseSwgdGhlIGF0dHJpYnV0ZSBwaGFzZSB3aWxsIGlkZW50aWZ5IHJ1bGUgZGVwZW5kZW5jaWVzIGFuZCBtdXR1YWxseS1yZWN1cnNpdmUgZ3JvdXBzLiBGb3IgZXhhbXBsZSxcbi8vXG4vLyBTID0gXCJhXCIgQSBcImJcIiAvIFwieVwiPGJyPlxuLy8gQSA9IFwieFwiXG4vL1xuLy8gUyBpcyBkZXBlbmRlbnQgb24gQSBidXQgQSBpcyBub3QgZGVwZW5kZW50IG9uIFMuXG4vL1xuLy8gUyA9IFwiYVwiIEEgXCJiXCIgLyBcImNcIjxicj5cbi8vIEEgPSBcInhcIiBTIFwieVwiIC8gXCJ6XCJcbi8vXG4vLyBTIGFuZCBBIGFyZSBkZXBlbmRlbnQgb24gb25lIGFub3RoZXIgYW5kIGFyZSBtdXR1YWxseSByZWN1cnNpdmUuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiBleHBvcnRBdHRyaWJ1dGVzKCkge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4uL2FwZy1saWIvaWRlbnRpZmllcnMnKTtcbiAgY29uc3QgeyBydWxlQXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMgfSA9IHJlcXVpcmUoJy4vcnVsZS1hdHRyaWJ1dGVzJyk7XG4gIGNvbnN0IHsgcnVsZURlcGVuZGVuY2llcywgc2hvd1J1bGVEZXBlbmRlbmNpZXMgfSA9IHJlcXVpcmUoJy4vcnVsZS1kZXBlbmRlbmNpZXMnKTtcbiAgY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHJ1bGVzLCB1ZHRzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICB0aGlzLnVkdHMgPSB1ZHRzO1xuICAgICAgdGhpcy5ydWxlQ291bnQgPSBydWxlcy5sZW5ndGg7XG4gICAgICB0aGlzLnVkdENvdW50ID0gdWR0cy5sZW5ndGg7XG4gICAgICB0aGlzLnN0YXJ0UnVsZSA9IDA7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc011dHVhbGx5UmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnJ1bGVJbmRleGVzID0gdGhpcy5pbmRleEFycmF5KHRoaXMucnVsZUNvdW50KTtcbiAgICAgIHRoaXMucnVsZUFscGhhSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnJ1bGVDb3VudCk7XG4gICAgICB0aGlzLnJ1bGVUeXBlSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnJ1bGVDb3VudCk7XG4gICAgICB0aGlzLnVkdEluZGV4ZXMgPSB0aGlzLmluZGV4QXJyYXkodGhpcy51ZHRDb3VudCk7XG4gICAgICB0aGlzLnVkdEFscGhhSW5kZXhlcyA9IHRoaXMuaW5kZXhBcnJheSh0aGlzLnVkdENvdW50KTtcbiAgICAgIHRoaXMuYXR0cnNFcnJvckNvdW50ID0gMDtcbiAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cnNFcnJvcnMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cnNXb3JraW5nID0gW107XG4gICAgICB0aGlzLnJ1bGVEZXBzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5hdHRycy5wdXNoKHRoaXMuYXR0ckdlbih0aGlzLnJ1bGVzW2ldKSk7XG4gICAgICAgIHRoaXMuYXR0cnNXb3JraW5nLnB1c2godGhpcy5hdHRyR2VuKHRoaXMucnVsZXNbaV0pKTtcbiAgICAgICAgdGhpcy5ydWxlRGVwcy5wdXNoKHRoaXMucmRHZW4ocnVsZXNbaV0sIHRoaXMucnVsZUNvdW50LCB0aGlzLnVkdENvdW50KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXBSdWxlc0FscGhhID0gdGhpcy5jb21wUnVsZXNBbHBoYS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jb21wVWR0c0FscGhhID0gdGhpcy5jb21wVWR0c0FscGhhLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNvbXBSdWxlc1R5cGUgPSB0aGlzLmNvbXBSdWxlc1R5cGUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY29tcFJ1bGVzR3JvdXAgPSB0aGlzLmNvbXBSdWxlc0dyb3VwLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBhdHRyR2VuKHJ1bGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgICAgICByaWdodDogZmFsc2UsXG4gICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgZmluaXRlOiBmYWxzZSxcbiAgICAgICAgY3ljbGljOiBmYWxzZSxcbiAgICAgICAgbGVhZjogZmFsc2UsXG4gICAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICAgIGlzQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICBydWxlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgIGF0dHJJbml0KGF0dHIpIHtcbiAgICAgIGF0dHIubGVmdCA9IGZhbHNlO1xuICAgICAgYXR0ci5uZXN0ZWQgPSBmYWxzZTtcbiAgICAgIGF0dHIucmlnaHQgPSBmYWxzZTtcbiAgICAgIGF0dHIuZW1wdHkgPSBmYWxzZTtcbiAgICAgIGF0dHIuZmluaXRlID0gZmFsc2U7XG4gICAgICBhdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgYXR0ci5sZWFmID0gZmFsc2U7XG4gICAgICBhdHRyLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgYXR0ci5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYXR0ckNvcHkoZHN0LCBzcmMpIHtcbiAgICAgIGRzdC5sZWZ0ID0gc3JjLmxlZnQ7XG4gICAgICBkc3QubmVzdGVkID0gc3JjLm5lc3RlZDtcbiAgICAgIGRzdC5yaWdodCA9IHNyYy5yaWdodDtcbiAgICAgIGRzdC5lbXB0eSA9IHNyYy5lbXB0eTtcbiAgICAgIGRzdC5maW5pdGUgPSBzcmMuZmluaXRlO1xuICAgICAgZHN0LmN5Y2xpYyA9IHNyYy5jeWNsaWM7XG4gICAgICBkc3QubGVhZiA9IHNyYy5sZWFmO1xuICAgICAgZHN0LmlzT3BlbiA9IHNyYy5pc09wZW47XG4gICAgICBkc3QuaXNDb21wbGV0ZSA9IHNyYy5pc0NvbXBsZXRlO1xuICAgICAgZHN0LnJ1bGUgPSBzcmMucnVsZTtcbiAgICB9XG5cbiAgICByZEdlbihydWxlLCBydWxlQ291bnQsIHVkdENvdW50KSB7XG4gICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgIHJ1bGUsXG4gICAgICAgIHJlY3Vyc2l2ZVR5cGU6IGlkLkFUVFJfTixcbiAgICAgICAgZ3JvdXBOdW1iZXI6IC0xLFxuICAgICAgICByZWZlcnNUbzogdGhpcy5mYWxzZUFycmF5KHJ1bGVDb3VudCksXG4gICAgICAgIHJlZmVyc1RvVWR0OiB0aGlzLmZhbHNlQXJyYXkodWR0Q291bnQpLFxuICAgICAgICByZWZlcmVuY2VkQnk6IHRoaXMuZmFsc2VBcnJheShydWxlQ291bnQpLFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdHlwZVRvU3RyaW5nKHJlY3Vyc2l2ZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAocmVjdXJzaXZlVHlwZSkge1xuICAgICAgICBjYXNlIGlkLkFUVFJfTjpcbiAgICAgICAgICByZXR1cm4gJyBOJztcbiAgICAgICAgY2FzZSBpZC5BVFRSX1I6XG4gICAgICAgICAgcmV0dXJuICcgUic7XG4gICAgICAgIGNhc2UgaWQuQVRUUl9NUjpcbiAgICAgICAgICByZXR1cm4gJ01SJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ1VOS05PV04nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlQXJyYXkobGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICByZXQucHVzaChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgZmFsc2lmeUFycmF5KGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhW2ldID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXhBcnJheShsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHJldC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNvbXBSdWxlc0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5ydWxlc1tsZWZ0XS5sb3dlciA8IHRoaXMucnVsZXNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJ1bGVzW2xlZnRdLmxvd2VyID4gdGhpcy5ydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb21wVWR0c0FscGhhKGxlZnQsIHJpZ2h0KSB7XG4gICAgICBpZiAodGhpcy51ZHRzW2xlZnRdLmxvd2VyIDwgdGhpcy51ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51ZHRzW2xlZnRdLmxvd2VyID4gdGhpcy51ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbXBSdWxlc1R5cGUobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLnJlY3Vyc2l2ZVR5cGUgPCB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5yZWN1cnNpdmVUeXBlKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLnJlY3Vyc2l2ZVR5cGUgPiB0aGlzLnJ1bGVEZXBzW3JpZ2h0XS5yZWN1cnNpdmVUeXBlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29tcFJ1bGVzR3JvdXAobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLnJlY3Vyc2l2ZVR5cGUgPT09IGlkLkFUVFJfTVIgJiYgdGhpcy5ydWxlRGVwc1tyaWdodF0ucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9NUikge1xuICAgICAgICBpZiAodGhpcy5ydWxlRGVwc1tsZWZ0XS5ncm91cE51bWJlciA8IHRoaXMucnVsZURlcHNbcmlnaHRdLmdyb3VwTnVtYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGVEZXBzW2xlZnRdLmdyb3VwTnVtYmVyID4gdGhpcy5ydWxlRGVwc1tyaWdodF0uZ3JvdXBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBhdHRyaWJ1dGVzID0gZnVuY3Rpb24gYXR0cmlidXRlcyhydWxlcyA9IFtdLCB1ZHRzID0gW10sIGxpbmVNYXAgPSBbXSwgZXJyb3JzID0gW10pIHtcbiAgICAvLyBsZXQgaSA9IDA7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuIFRoZSBzdGF0ZSBvZiB0aGUgY29tcHV0YXRpb24gZ2V0IHBhc3NlZCBhcm91bmQgdG8gbXVsdGlwbGUgZnVuY3Rpb25zIGluIG11bHRpcGxlIGZpbGVzLlxuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKHJ1bGVzLCB1ZHRzKTtcblxuICAgIC8vIERldGVybWluZSBhbGwgcnVsZSBkZXBlbmRlbmNpZXNcbiAgICAvLyAgLSB3aGljaCBydWxlcyBlYWNoIHJ1bGUgcmVmZXJzIHRvXG4gICAgLy8gIC0gd2hpY2ggcnVsZXMgcmVmZXJlbmNlIGVhY2ggcnVsZVxuICAgIHJ1bGVEZXBlbmRlbmNpZXMoc3RhdGUpO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBhdHRyaWJ1dGVzIGZvciBlYWNoIHJ1bGUuXG4gICAgcnVsZUF0dHJpYnV0ZXMoc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5hdHRyc0Vycm9yQ291bnQpIHtcbiAgICAgIGVycm9ycy5wdXNoKHsgbGluZTogMCwgY2hhcjogMCwgbXNnOiBgJHtzdGF0ZS5hdHRyc0Vycm9yQ291bnR9IGF0dHJpYnV0ZSBlcnJvcnNgIH0pO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGF0dHJpYnV0ZSBlcnJvcnMgdG8gdGhlIGNhbGxlci5cbiAgICByZXR1cm4gc3RhdGUuYXR0cnNFcnJvckNvdW50O1xuICB9O1xuXG4gIC8qIERlc3RydWN0dXJpbmcgYXNzaWdubWVudCAtIHNlZSBNRE4gV2ViIERvY3MgKi9cbiAgcmV0dXJuIHsgYXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMsIHNob3dSdWxlRGVwZW5kZW5jaWVzIH07XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/attributes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\nmodule.exports = function exportParser() {\n  const thisFileName = 'parser: ';\n  const ApgLib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = ApgLib.ids;\n  const syn = new (__webpack_require__(/*! ./syntax-callbacks */ \"(ssr)/./node_modules/apg-js/src/apg-api/syntax-callbacks.js\"))();\n  const sem = new (__webpack_require__(/*! ./semantic-callbacks */ \"(ssr)/./node_modules/apg-js/src/apg-api/semantic-callbacks.js\"))();\n  const sabnfGrammar = new (__webpack_require__(/*! ./sabnf-grammar */ \"(ssr)/./node_modules/apg-js/src/apg-api/sabnf-grammar.js\"))();\n  // eslint-disable-next-line new-cap\n  const parser = new ApgLib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new ApgLib.ast();\n  parser.callbacks = syn.callbacks;\n  parser.ast.callbacks = sem.callbacks;\n\n  /* find the line containing the given character index */\n  const findLine = function findLine(lines, charIndex, charLength) {\n    if (charIndex < 0 || charIndex >= charLength) {\n      /* return error if out of range */\n      return -1;\n    }\n    for (let i = 0; i < lines.length; i += 1) {\n      if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n        return i;\n      }\n    }\n    /* should never reach here */\n    return -1;\n  };\n  const translateIndex = function translateIndex(map, index) {\n    let ret = -1;\n    if (index < map.length) {\n      for (let i = index; i < map.length; i += 1) {\n        if (map[i] !== null) {\n          ret = map[i];\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  /* helper function when removing redundant opcodes */\n  const reduceOpcodes = function reduceOpcodes(rules) {\n    rules.forEach((rule) => {\n      const opcodes = [];\n      const map = [];\n      let reducedIndex = 0;\n      rule.opcodes.forEach((op) => {\n        if (op.type === id.ALT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.CAT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n          map.push(null);\n        } else {\n          map.push(reducedIndex);\n          opcodes.push(op);\n          reducedIndex += 1;\n        }\n      });\n      map.push(reducedIndex);\n      /* translate original opcode indexes to the reduced set. */\n      opcodes.forEach((op) => {\n        if (op.type === id.ALT || op.type === id.CAT) {\n          for (let i = 0; i < op.children.length; i += 1) {\n            op.children[i] = translateIndex(map, op.children[i]);\n          }\n        }\n      });\n      rule.opcodes = opcodes;\n    });\n  };\n  /* Parse the grammar - the syntax phase. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.syntax = function syntax(chars, lines, errors, strict, lite, trace) {\n    if (trace) {\n      if (trace.traceObject !== 'traceObject') {\n        throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n      }\n      parser.trace = trace;\n    }\n    const data = {};\n    data.errors = errors;\n    data.strict = !!strict;\n    data.lite = !!lite;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    data.ruleCount = 0;\n    const result = parser.parse(sabnfGrammar, 'file', chars, data);\n    if (!result.success) {\n      errors.push({\n        line: 0,\n        char: 0,\n        msg: 'syntax analysis of input grammar failed',\n      });\n    }\n  };\n  /* Parse the grammar - the semantic phase, translates the AST. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.semantic = function semantic(chars, lines, errors) {\n    const data = {};\n    data.errors = errors;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    parser.ast.translate(data);\n    if (errors.length) {\n      return null;\n    }\n    /* Remove unneeded operators. */\n    /* ALT operators with a single alternate */\n    /* CAT operators with a single phrase to concatenate */\n    /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */\n    reduceOpcodes(data.rules);\n    return {\n      rules: data.rules,\n      udts: data.udts,\n      lineMap: data.rulesLineMap,\n    };\n  };\n  // Generate a grammar constructor function.\n  // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n  this.generateSource = function generateSource(chars, lines, rules, udts, config) {\n    let source = '';\n    let typescript = false;\n    let lite = false;\n    // config may have multiple grammar object type options in which case\n    // --typescript > --lite  > no options\n    if (config) {\n      if (config.typescript) {\n        typescript = true;\n        lite = false;\n      } else if (config.lite) {\n        typescript = false;\n        lite = true;\n      }\n    }\n    let i;\n    let bkrname;\n    let bkrlower;\n    let opcodeCount = 0;\n    let charCodeMin = Infinity;\n    let charCodeMax = 0;\n    const ruleNames = [];\n    const udtNames = [];\n    let alt = 0;\n    let cat = 0;\n    let rnm = 0;\n    let udt = 0;\n    let rep = 0;\n    let and = 0;\n    let not = 0;\n    let tls = 0;\n    let tbs = 0;\n    let trg = 0;\n    let bkr = 0;\n    let bka = 0;\n    let bkn = 0;\n    let abg = 0;\n    let aen = 0;\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n      opcodeCount += rule.opcodes.length;\n      rule.opcodes.forEach((op) => {\n        switch (op.type) {\n          case id.ALT:\n            alt += 1;\n            break;\n          case id.CAT:\n            cat += 1;\n            break;\n          case id.RNM:\n            rnm += 1;\n            break;\n          case id.UDT:\n            udt += 1;\n            break;\n          case id.REP:\n            rep += 1;\n            break;\n          case id.AND:\n            and += 1;\n            break;\n          case id.NOT:\n            not += 1;\n            break;\n          case id.BKA:\n            bka += 1;\n            break;\n          case id.BKN:\n            bkn += 1;\n            break;\n          case id.BKR:\n            bkr += 1;\n            break;\n          case id.ABG:\n            abg += 1;\n            break;\n          case id.AEN:\n            aen += 1;\n            break;\n          case id.TLS:\n            tls += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TBS:\n            tbs += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TRG:\n            trg += 1;\n            if (op.min < charCodeMin) {\n              charCodeMin = op.min;\n            }\n            if (op.max > charCodeMax) {\n              charCodeMax = op.max;\n            }\n            break;\n          default:\n            throw new Error('generateSource: unrecognized opcode');\n        }\n      });\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    source += '// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\\n';\n    source += '//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n';\n    source += '//\\n';\n    source += '// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\\n';\n    if (config) {\n      if (config.funcName) {\n        source += `const ${config.funcName} = function grammar(){\\n`;\n      } else if (typescript) {\n        source += 'export function grammar(){\\n';\n      } else if (lite) {\n        source += 'export default function grammar(){\\n';\n      } else {\n        source += `module.exports = function grammar(){\\n`;\n      }\n    } else {\n      source += `module.exports = function grammar(){\\n`;\n    }\n    source += '  // ```\\n';\n    source += '  // SUMMARY\\n';\n    source += `  //      rules = ${rules.length}\\n`;\n    source += `  //       udts = ${udts.length}\\n`;\n    source += `  //    opcodes = ${opcodeCount}\\n`;\n    source += '  //        ---   ABNF original opcodes\\n';\n    source += `  //        ALT = ${alt}\\n`;\n    source += `  //        CAT = ${cat}\\n`;\n    source += `  //        REP = ${rep}\\n`;\n    source += `  //        RNM = ${rnm}\\n`;\n    source += `  //        TLS = ${tls}\\n`;\n    source += `  //        TBS = ${tbs}\\n`;\n    source += `  //        TRG = ${trg}\\n`;\n    source += '  //        ---   SABNF superset opcodes\\n';\n    source += `  //        UDT = ${udt}\\n`;\n    source += `  //        AND = ${and}\\n`;\n    source += `  //        NOT = ${not}\\n`;\n    if (!lite) {\n      source += `  //        BKA = ${bka}\\n`;\n      source += `  //        BKN = ${bkn}\\n`;\n      source += `  //        BKR = ${bkr}\\n`;\n      source += `  //        ABG = ${abg}\\n`;\n      source += `  //        AEN = ${aen}\\n`;\n    }\n    source += '  // characters = [';\n    if (tls + tbs + trg === 0) {\n      source += ' none defined ]';\n    } else {\n      source += `${charCodeMin} - ${charCodeMax}]`;\n    }\n    if (udt > 0) {\n      source += ' + user defined';\n    }\n    source += '\\n';\n    source += '  // ```\\n';\n    source += '  /* OBJECT IDENTIFIER (for internal parser use) */\\n';\n    source += \"  this.grammarObject = 'grammarObject';\\n\";\n    source += '\\n';\n    source += '  /* RULES */\\n';\n    source += '  this.rules = [];\\n';\n    rules.forEach((rule, ii) => {\n      let thisRule = '  this.rules[';\n      thisRule += ii;\n      thisRule += \"] = { name: '\";\n      thisRule += rule.name;\n      thisRule += \"', lower: '\";\n      thisRule += rule.lower;\n      thisRule += \"', index: \";\n      thisRule += rule.index;\n      thisRule += ', isBkr: ';\n      thisRule += rule.isBkr;\n      thisRule += ' };\\n';\n      source += thisRule;\n    });\n    source += '\\n';\n    source += '  /* UDTS */\\n';\n    source += '  this.udts = [];\\n';\n    if (udts.length > 0) {\n      udts.forEach((udtFunc, ii) => {\n        let thisUdt = '  this.udts[';\n        thisUdt += ii;\n        thisUdt += \"] = { name: '\";\n        thisUdt += udtFunc.name;\n        thisUdt += \"', lower: '\";\n        thisUdt += udtFunc.lower;\n        thisUdt += \"', index: \";\n        thisUdt += udtFunc.index;\n        thisUdt += ', empty: ';\n        thisUdt += udtFunc.empty;\n        thisUdt += ', isBkr: ';\n        thisUdt += udtFunc.isBkr;\n        thisUdt += ' };\\n';\n        source += thisUdt;\n      });\n    }\n    source += '\\n';\n    source += '  /* OPCODES */\\n';\n    rules.forEach((rule, ruleIndex) => {\n      if (ruleIndex > 0) {\n        source += '\\n';\n      }\n      source += `  /* ${rule.name} */\\n`;\n      source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n      rule.opcodes.forEach((op, opIndex) => {\n        let prefix;\n        switch (op.type) {\n          case id.ALT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, children: [${op.children.toString()}] };// ALT\\n`;\n            break;\n          case id.CAT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, children: [${op.children.toString()}] };// CAT\\n`;\n            break;\n          case id.RNM:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, index: ${\n              op.index\n            } };// RNM(${rules[op.index].name})\\n`;\n            break;\n          case id.BKR:\n            if (op.index >= rules.length) {\n              bkrname = udts[op.index - rules.length].name;\n              bkrlower = udts[op.index - rules.length].lower;\n            } else {\n              bkrname = rules[op.index].name;\n              bkrlower = rules[op.index].lower;\n            }\n            prefix = '%i';\n            if (op.bkrCase === id.BKR_MODE_CS) {\n              prefix = '%s';\n            }\n            if (op.bkrMode === id.BKR_MODE_UM) {\n              prefix += '%u';\n            } else {\n              prefix += '%p';\n            }\n            bkrname = prefix + bkrname;\n            source +=\n              `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` +\n              `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode} };// BKR(\\\\${bkrname})\\n`;\n            break;\n          case id.UDT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, empty: ${\n              op.empty\n            }, index: ${op.index} };// UDT(${udts[op.index].name})\\n`;\n            break;\n          case id.REP:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, min: ${op.min}, max: ${op.max} };// REP\\n`;\n            break;\n          case id.AND:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// AND\\n`;\n            break;\n          case id.NOT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// NOT\\n`;\n            break;\n          case id.ABG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// ABG(%^)\\n`;\n            break;\n          case id.AEN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// AEN(%$)\\n`;\n            break;\n          case id.BKA:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// BKA\\n`;\n            break;\n          case id.BKN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// BKN\\n`;\n            break;\n          case id.TLS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, string: [${op.string.toString()}] };// TLS\\n`;\n            break;\n          case id.TBS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, string: [${op.string.toString()}] };// TBS\\n`;\n            break;\n          case id.TRG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, min: ${op.min}, max: ${op.max} };// TRG\\n`;\n            break;\n          default:\n            throw new Error('parser.js: ~143: unrecognized opcode');\n        }\n      });\n    });\n    source += '\\n';\n    source += '  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n';\n    source += '  this.toString = function toString(){\\n';\n    source += '    let str = \"\";\\n';\n    let str;\n    lines.forEach((line) => {\n      const end = line.beginChar + line.length;\n      str = '';\n      source += '    str += \"';\n      for (let ii = line.beginChar; ii < end; ii += 1) {\n        switch (chars[ii]) {\n          case 9:\n            str = ' ';\n            break;\n          case 10:\n            str = '\\\\n';\n            break;\n          case 13:\n            str = '\\\\r';\n            break;\n          case 34:\n            str = '\\\\\"';\n            break;\n          case 92:\n            str = '\\\\\\\\';\n            break;\n          default:\n            str = String.fromCharCode(chars[ii]);\n            break;\n        }\n        source += str;\n      }\n      source += '\";\\n';\n    });\n    source += '    return str;\\n';\n    source += '  }\\n';\n    source += '}\\n';\n    return source;\n  };\n  // Generate a grammar file object.\n  // Returns the same object as instantiating the constructor function returned by<br>\n  // `this.generateSource()`.<br>\n  this.generateObject = function generateObject(stringArg, rules, udts) {\n    const obj = {};\n    const ruleNames = [];\n    const udtNames = [];\n    const string = stringArg.slice(0);\n    obj.grammarObject = 'grammarObject';\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    obj.callbacks = [];\n    ruleNames.forEach((name) => {\n      obj.callbacks[name] = false;\n    });\n    if (udts.length > 0) {\n      udtNames.forEach((name) => {\n        obj.callbacks[name] = false;\n      });\n    }\n    obj.rules = rules;\n    obj.udts = udts;\n    obj.toString = function toStringFunc() {\n      return string;\n    };\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFvQjtBQUMvQyxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBc0I7QUFDakQsNEJBQTRCLG1CQUFPLENBQUMsaUZBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLHFCQUFxQjtBQUNqRSxRQUFRO0FBQ1IsNkNBQTZDO0FBQzdDLFFBQVE7QUFDUixxREFBcUQ7QUFDckQsUUFBUTtBQUNSLHVEQUF1RDtBQUN2RDtBQUNBLE1BQU07QUFDTixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQsbUNBQW1DLFlBQVk7QUFDL0MsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QyxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDLG1DQUFtQyxJQUFJO0FBQ3ZDO0FBQ0EscUNBQXFDLElBQUk7QUFDekMscUNBQXFDLElBQUk7QUFDekMscUNBQXFDLElBQUk7QUFDekMscUNBQXFDLElBQUk7QUFDekMscUNBQXFDLElBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CLGFBQWEsSUFBSSxZQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkMsZ0NBQWdDLFVBQVUsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxNQUFNO0FBQzFFO0FBQ0EsYUFBYSxlQUFlLHVCQUF1QixJQUFJO0FBQ3ZEO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsTUFBTTtBQUMxRTtBQUNBLGFBQWEsZUFBZSx1QkFBdUIsSUFBSTtBQUN2RDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLE1BQU0sUUFBUSxRQUFRO0FBQzFGO0FBQ0EsZ0JBQWdCLFNBQVMscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFVBQVUsWUFBWSxRQUFRLE1BQU0sUUFBUSxRQUFRLFdBQVcsU0FBUyxZQUFZLFNBQVM7QUFDM0gsNEJBQTRCLFdBQVcsYUFBYSxjQUFjLFdBQVcsUUFBUTtBQUNyRjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLE1BQU0sUUFBUSxRQUFRO0FBQzFGO0FBQ0EsYUFBYSxXQUFXLFlBQVksU0FBUyxvQkFBb0I7QUFDakU7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxNQUFNLFFBQVEsUUFBUSxTQUFTLE9BQU8sU0FBUyxVQUFVO0FBQzdIO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsTUFBTSxRQUFRLFdBQVc7QUFDN0Y7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxNQUFNLFFBQVEsV0FBVztBQUM3RjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLE1BQU0sUUFBUSxXQUFXO0FBQzdGO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsTUFBTSxRQUFRLFdBQVc7QUFDN0Y7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxNQUFNLFFBQVEsV0FBVztBQUM3RjtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLE1BQU0sUUFBUSxXQUFXO0FBQzdGO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxZQUFZLFFBQVEsTUFBTTtBQUMxRTtBQUNBLGFBQWEsYUFBYSxxQkFBcUIsSUFBSTtBQUNuRDtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsWUFBWSxRQUFRLE1BQU07QUFDMUU7QUFDQSxhQUFhLGFBQWEscUJBQXFCLElBQUk7QUFDbkQ7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLFlBQVksUUFBUSxNQUFNLFFBQVEsUUFBUSxTQUFTLE9BQU8sU0FBUyxVQUFVO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWFwaS9wYXJzZXIuanM/NTBjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBjb252ZXJ0cyBhbiBpbnB1dCBTQUJORiBncmFtbWFyIHRleHQgZmlsZSBpbnRvIGFcbi8vIGdyYW1tYXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBgYXBnLWxpYmAgaW4gYW4gYXBwbGljYXRpb24gcGFyc2VyLlxuLy8gKiphcGcqKiBpcywgaW4gZmFjdCBpdHNlbGYsIGFuIEFCTkYgcGFyc2VyIHRoYXQgZ2VuZXJhdGVzIGFuIFNBQk5GIHBhcnNlci5cbi8vIEl0IGlzIGJhc2VkIG9uIHRoZSBncmFtbWFyPGJyPlxuLy8gYC4vZGlzdC9hYm5mLWZvci1zYWJuZi1ncmFtbWFyLmJuZmAuPGJyPlxuLy8gSW4gaXRzIHN5bnRheCBwaGFzZSwgKiphcGcqKiBhbmFseXplcyB0aGUgdXNlcidzIGlucHV0IFNBQk5GIGdyYW1tYXIgZm9yIGNvcnJlY3Qgc3ludGF4LCBnZW5lcmF0aW5nIGFuIEFTVCBhcyBpdCBnb2VzLlxuLy8gSW4gaXRzIHNlbWFudGljIHBoYXNlLCAqKmFwZyoqIHRyYW5zbGF0ZXMgdGhlIEFTVCB0byBnZW5lcmF0ZSB0aGUgcGFyc2VyIGZvciB0aGUgaW5wdXQgZ3JhbW1hci5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhwb3J0UGFyc2VyKCkge1xuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAncGFyc2VyOiAnO1xuICBjb25zdCBBcGdMaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBpZCA9IEFwZ0xpYi5pZHM7XG4gIGNvbnN0IHN5biA9IG5ldyAocmVxdWlyZSgnLi9zeW50YXgtY2FsbGJhY2tzJykpKCk7XG4gIGNvbnN0IHNlbSA9IG5ldyAocmVxdWlyZSgnLi9zZW1hbnRpYy1jYWxsYmFja3MnKSkoKTtcbiAgY29uc3Qgc2FibmZHcmFtbWFyID0gbmV3IChyZXF1aXJlKCcuL3NhYm5mLWdyYW1tYXInKSkoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgY29uc3QgcGFyc2VyID0gbmV3IEFwZ0xpYi5wYXJzZXIoKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgcGFyc2VyLmFzdCA9IG5ldyBBcGdMaWIuYXN0KCk7XG4gIHBhcnNlci5jYWxsYmFja3MgPSBzeW4uY2FsbGJhY2tzO1xuICBwYXJzZXIuYXN0LmNhbGxiYWNrcyA9IHNlbS5jYWxsYmFja3M7XG5cbiAgLyogZmluZCB0aGUgbGluZSBjb250YWluaW5nIHRoZSBnaXZlbiBjaGFyYWN0ZXIgaW5kZXggKi9cbiAgY29uc3QgZmluZExpbmUgPSBmdW5jdGlvbiBmaW5kTGluZShsaW5lcywgY2hhckluZGV4LCBjaGFyTGVuZ3RoKSB7XG4gICAgaWYgKGNoYXJJbmRleCA8IDAgfHwgY2hhckluZGV4ID49IGNoYXJMZW5ndGgpIHtcbiAgICAgIC8qIHJldHVybiBlcnJvciBpZiBvdXQgb2YgcmFuZ2UgKi9cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGNoYXJJbmRleCA+PSBsaW5lc1tpXS5iZWdpbkNoYXIgJiYgY2hhckluZGV4IDwgbGluZXNbaV0uYmVnaW5DaGFyICsgbGluZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAgIHJldHVybiAtMTtcbiAgfTtcbiAgY29uc3QgdHJhbnNsYXRlSW5kZXggPSBmdW5jdGlvbiB0cmFuc2xhdGVJbmRleChtYXAsIGluZGV4KSB7XG4gICAgbGV0IHJldCA9IC0xO1xuICAgIGlmIChpbmRleCA8IG1hcC5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IG1hcC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobWFwW2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0ID0gbWFwW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIC8qIGhlbHBlciBmdW5jdGlvbiB3aGVuIHJlbW92aW5nIHJlZHVuZGFudCBvcGNvZGVzICovXG4gIGNvbnN0IHJlZHVjZU9wY29kZXMgPSBmdW5jdGlvbiByZWR1Y2VPcGNvZGVzKHJ1bGVzKSB7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgY29uc3Qgb3Bjb2RlcyA9IFtdO1xuICAgICAgY29uc3QgbWFwID0gW107XG4gICAgICBsZXQgcmVkdWNlZEluZGV4ID0gMDtcbiAgICAgIHJ1bGUub3Bjb2Rlcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICBpZiAob3AudHlwZSA9PT0gaWQuQUxUICYmIG9wLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG1hcC5wdXNoKG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wLnR5cGUgPT09IGlkLkNBVCAmJiBvcC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBtYXAucHVzaChudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcC50eXBlID09PSBpZC5SRVAgJiYgb3AubWluID09PSAxICYmIG9wLm1heCA9PT0gMSkge1xuICAgICAgICAgIG1hcC5wdXNoKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcC5wdXNoKHJlZHVjZWRJbmRleCk7XG4gICAgICAgICAgb3Bjb2Rlcy5wdXNoKG9wKTtcbiAgICAgICAgICByZWR1Y2VkSW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtYXAucHVzaChyZWR1Y2VkSW5kZXgpO1xuICAgICAgLyogdHJhbnNsYXRlIG9yaWdpbmFsIG9wY29kZSBpbmRleGVzIHRvIHRoZSByZWR1Y2VkIHNldC4gKi9cbiAgICAgIG9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgaWYgKG9wLnR5cGUgPT09IGlkLkFMVCB8fCBvcC50eXBlID09PSBpZC5DQVQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBvcC5jaGlsZHJlbltpXSA9IHRyYW5zbGF0ZUluZGV4KG1hcCwgb3AuY2hpbGRyZW5baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBydWxlLm9wY29kZXMgPSBvcGNvZGVzO1xuICAgIH0pO1xuICB9O1xuICAvKiBQYXJzZSB0aGUgZ3JhbW1hciAtIHRoZSBzeW50YXggcGhhc2UuICovXG4gIC8qIFNBQk5GIGdyYW1tYXIgc3ludGF4IGVycm9ycyBhcmUgY2F1Z2h0IGFuZCByZXBvcnRlZCBoZXJlLiAqL1xuICB0aGlzLnN5bnRheCA9IGZ1bmN0aW9uIHN5bnRheChjaGFycywgbGluZXMsIGVycm9ycywgc3RyaWN0LCBsaXRlLCB0cmFjZSkge1xuICAgIGlmICh0cmFjZSkge1xuICAgICAgaWYgKHRyYWNlLnRyYWNlT2JqZWN0ICE9PSAndHJhY2VPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXRyYWNlIGFyZ3VtZW50IGlzIG5vdCBhIHRyYWNlIG9iamVjdGApO1xuICAgICAgfVxuICAgICAgcGFyc2VyLnRyYWNlID0gdHJhY2U7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBkYXRhLmVycm9ycyA9IGVycm9ycztcbiAgICBkYXRhLnN0cmljdCA9ICEhc3RyaWN0O1xuICAgIGRhdGEubGl0ZSA9ICEhbGl0ZTtcbiAgICBkYXRhLmxpbmVzID0gbGluZXM7XG4gICAgZGF0YS5maW5kTGluZSA9IGZpbmRMaW5lO1xuICAgIGRhdGEuY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgZGF0YS5ydWxlQ291bnQgPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShzYWJuZkdyYW1tYXIsICdmaWxlJywgY2hhcnMsIGRhdGEpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY2hhcjogMCxcbiAgICAgICAgbXNnOiAnc3ludGF4IGFuYWx5c2lzIG9mIGlucHV0IGdyYW1tYXIgZmFpbGVkJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyogUGFyc2UgdGhlIGdyYW1tYXIgLSB0aGUgc2VtYW50aWMgcGhhc2UsIHRyYW5zbGF0ZXMgdGhlIEFTVC4gKi9cbiAgLyogU0FCTkYgZ3JhbW1hciBzeW50YXggZXJyb3JzIGFyZSBjYXVnaHQgYW5kIHJlcG9ydGVkIGhlcmUuICovXG4gIHRoaXMuc2VtYW50aWMgPSBmdW5jdGlvbiBzZW1hbnRpYyhjaGFycywgbGluZXMsIGVycm9ycykge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICBkYXRhLmVycm9ycyA9IGVycm9ycztcbiAgICBkYXRhLmxpbmVzID0gbGluZXM7XG4gICAgZGF0YS5maW5kTGluZSA9IGZpbmRMaW5lO1xuICAgIGRhdGEuY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgcGFyc2VyLmFzdC50cmFuc2xhdGUoZGF0YSk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgdW5uZWVkZWQgb3BlcmF0b3JzLiAqL1xuICAgIC8qIEFMVCBvcGVyYXRvcnMgd2l0aCBhIHNpbmdsZSBhbHRlcm5hdGUgKi9cbiAgICAvKiBDQVQgb3BlcmF0b3JzIHdpdGggYSBzaW5nbGUgcGhyYXNlIHRvIGNvbmNhdGVuYXRlICovXG4gICAgLyogUkVQKDEsMSkgb3BlcmF0b3JzIChgMSoxUnVsZU5hbWVgIG9yIGAxUnVsZU5hbWVgIGlzIHRoZSBzYW1lIGFzIGp1c3QgYFJ1bGVOYW1lYC4pICovXG4gICAgcmVkdWNlT3Bjb2RlcyhkYXRhLnJ1bGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcnVsZXM6IGRhdGEucnVsZXMsXG4gICAgICB1ZHRzOiBkYXRhLnVkdHMsXG4gICAgICBsaW5lTWFwOiBkYXRhLnJ1bGVzTGluZU1hcCxcbiAgICB9O1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhIGdyYW1tYXIgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gIC8vIEFuIG9iamVjdCBpbnN0YW50aWF0ZWQgZnJvbSB0aGlzIGNvbnN0cnVjdG9yIGlzIHVzZWQgd2l0aCB0aGUgYGFwZy1saWJgIGBwYXJzZXIoKWAgZnVuY3Rpb24uXG4gIHRoaXMuZ2VuZXJhdGVTb3VyY2UgPSBmdW5jdGlvbiBnZW5lcmF0ZVNvdXJjZShjaGFycywgbGluZXMsIHJ1bGVzLCB1ZHRzLCBjb25maWcpIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgbGV0IHR5cGVzY3JpcHQgPSBmYWxzZTtcbiAgICBsZXQgbGl0ZSA9IGZhbHNlO1xuICAgIC8vIGNvbmZpZyBtYXkgaGF2ZSBtdWx0aXBsZSBncmFtbWFyIG9iamVjdCB0eXBlIG9wdGlvbnMgaW4gd2hpY2ggY2FzZVxuICAgIC8vIC0tdHlwZXNjcmlwdCA+IC0tbGl0ZSAgPiBubyBvcHRpb25zXG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgaWYgKGNvbmZpZy50eXBlc2NyaXB0KSB7XG4gICAgICAgIHR5cGVzY3JpcHQgPSB0cnVlO1xuICAgICAgICBsaXRlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5saXRlKSB7XG4gICAgICAgIHR5cGVzY3JpcHQgPSBmYWxzZTtcbiAgICAgICAgbGl0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpO1xuICAgIGxldCBia3JuYW1lO1xuICAgIGxldCBia3Jsb3dlcjtcbiAgICBsZXQgb3Bjb2RlQ291bnQgPSAwO1xuICAgIGxldCBjaGFyQ29kZU1pbiA9IEluZmluaXR5O1xuICAgIGxldCBjaGFyQ29kZU1heCA9IDA7XG4gICAgY29uc3QgcnVsZU5hbWVzID0gW107XG4gICAgY29uc3QgdWR0TmFtZXMgPSBbXTtcbiAgICBsZXQgYWx0ID0gMDtcbiAgICBsZXQgY2F0ID0gMDtcbiAgICBsZXQgcm5tID0gMDtcbiAgICBsZXQgdWR0ID0gMDtcbiAgICBsZXQgcmVwID0gMDtcbiAgICBsZXQgYW5kID0gMDtcbiAgICBsZXQgbm90ID0gMDtcbiAgICBsZXQgdGxzID0gMDtcbiAgICBsZXQgdGJzID0gMDtcbiAgICBsZXQgdHJnID0gMDtcbiAgICBsZXQgYmtyID0gMDtcbiAgICBsZXQgYmthID0gMDtcbiAgICBsZXQgYmtuID0gMDtcbiAgICBsZXQgYWJnID0gMDtcbiAgICBsZXQgYWVuID0gMDtcbiAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICBydWxlTmFtZXMucHVzaChydWxlLmxvd2VyKTtcbiAgICAgIG9wY29kZUNvdW50ICs9IHJ1bGUub3Bjb2Rlcy5sZW5ndGg7XG4gICAgICBydWxlLm9wY29kZXMuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgICAgICBhbHQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQ0FUOlxuICAgICAgICAgICAgY2F0ICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIHJubSArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgICB1ZHQgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgICAgcmVwICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICAgIGFuZCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICAgICAgICBub3QgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgICAgYmthICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgICAgIGJrbiArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgICBia3IgKz0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQUJHOlxuICAgICAgICAgICAgYWJnICs9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICAgIGFlbiArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgICB0bHMgKz0gMTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcC5zdHJpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnN0cmluZ1tpXSA8IGNoYXJDb2RlTWluKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVNaW4gPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wLnN0cmluZ1tpXSA+IGNoYXJDb2RlTWF4KSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVNYXggPSBvcC5zdHJpbmdbaV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgICAgICAgdGJzICs9IDE7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3Auc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPCBjaGFyQ29kZU1pbikge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChvcC5zdHJpbmdbaV0gPiBjaGFyQ29kZU1heCkge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICAgIHRyZyArPSAxO1xuICAgICAgICAgICAgaWYgKG9wLm1pbiA8IGNoYXJDb2RlTWluKSB7XG4gICAgICAgICAgICAgIGNoYXJDb2RlTWluID0gb3AubWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wLm1heCA+IGNoYXJDb2RlTWF4KSB7XG4gICAgICAgICAgICAgIGNoYXJDb2RlTWF4ID0gb3AubWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJhdGVTb3VyY2U6IHVucmVjb2duaXplZCBvcGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcnVsZU5hbWVzLnNvcnQoKTtcbiAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1ZHRzLmZvckVhY2goKHVkdEZ1bmMpID0+IHtcbiAgICAgICAgdWR0TmFtZXMucHVzaCh1ZHRGdW5jLmxvd2VyKTtcbiAgICAgIH0pO1xuICAgICAgdWR0TmFtZXMuc29ydCgpO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJy8vIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDI0IExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWQ8YnI+XFxuJztcbiAgICBzb3VyY2UgKz0gJy8vICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSk8YnI+XFxuJztcbiAgICBzb3VyY2UgKz0gJy8vXFxuJztcbiAgICBzb3VyY2UgKz0gJy8vIEdlbmVyYXRlZCBieSBhcGctanMsIFZlcnNpb24gNC40LjAgW2FwZy1qc10oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcylcXG4nO1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuZnVuY05hbWUpIHtcbiAgICAgICAgc291cmNlICs9IGBjb25zdCAke2NvbmZpZy5mdW5jTmFtZX0gPSBmdW5jdGlvbiBncmFtbWFyKCl7XFxuYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZXNjcmlwdCkge1xuICAgICAgICBzb3VyY2UgKz0gJ2V4cG9ydCBmdW5jdGlvbiBncmFtbWFyKCl7XFxuJztcbiAgICAgIH0gZWxzZSBpZiAobGl0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gJ2V4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyYW1tYXIoKXtcXG4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlICs9IGBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdyYW1tYXIoKXtcXG5gO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgKz0gYG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xcbmA7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnICAvLyBgYGBcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvLyBTVU1NQVJZXFxuJztcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICBydWxlcyA9ICR7cnVsZXMubGVuZ3RofVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgIHVkdHMgPSAke3VkdHMubGVuZ3RofVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgIG9wY29kZXMgPSAke29wY29kZUNvdW50fVxcbmA7XG4gICAgc291cmNlICs9ICcgIC8vICAgICAgICAtLS0gICBBQk5GIG9yaWdpbmFsIG9wY29kZXNcXG4nO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgQUxUID0gJHthbHR9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIENBVCA9ICR7Y2F0fVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBSRVAgPSAke3JlcH1cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgUk5NID0gJHtybm19XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIFRMUyA9ICR7dGxzfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBUQlMgPSAke3Ric31cXG5gO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgVFJHID0gJHt0cmd9XFxuYDtcbiAgICBzb3VyY2UgKz0gJyAgLy8gICAgICAgIC0tLSAgIFNBQk5GIHN1cGVyc2V0IG9wY29kZXNcXG4nO1xuICAgIHNvdXJjZSArPSBgICAvLyAgICAgICAgVURUID0gJHt1ZHR9XFxuYDtcbiAgICBzb3VyY2UgKz0gYCAgLy8gICAgICAgIEFORCA9ICR7YW5kfVxcbmA7XG4gICAgc291cmNlICs9IGAgIC8vICAgICAgICBOT1QgPSAke25vdH1cXG5gO1xuICAgIGlmICghbGl0ZSkge1xuICAgICAgc291cmNlICs9IGAgIC8vICAgICAgICBCS0EgPSAke2JrYX1cXG5gO1xuICAgICAgc291cmNlICs9IGAgIC8vICAgICAgICBCS04gPSAke2Jrbn1cXG5gO1xuICAgICAgc291cmNlICs9IGAgIC8vICAgICAgICBCS1IgPSAke2Jrcn1cXG5gO1xuICAgICAgc291cmNlICs9IGAgIC8vICAgICAgICBBQkcgPSAke2FiZ31cXG5gO1xuICAgICAgc291cmNlICs9IGAgIC8vICAgICAgICBBRU4gPSAke2Flbn1cXG5gO1xuICAgIH1cbiAgICBzb3VyY2UgKz0gJyAgLy8gY2hhcmFjdGVycyA9IFsnO1xuICAgIGlmICh0bHMgKyB0YnMgKyB0cmcgPT09IDApIHtcbiAgICAgIHNvdXJjZSArPSAnIG5vbmUgZGVmaW5lZCBdJztcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlICs9IGAke2NoYXJDb2RlTWlufSAtICR7Y2hhckNvZGVNYXh9XWA7XG4gICAgfVxuICAgIGlmICh1ZHQgPiAwKSB7XG4gICAgICBzb3VyY2UgKz0gJyArIHVzZXIgZGVmaW5lZCc7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLy8gYGBgXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLyogT0JKRUNUIElERU5USUZJRVIgKGZvciBpbnRlcm5hbCBwYXJzZXIgdXNlKSAqL1xcbic7XG4gICAgc291cmNlICs9IFwiICB0aGlzLmdyYW1tYXJPYmplY3QgPSAnZ3JhbW1hck9iamVjdCc7XFxuXCI7XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvKiBSVUxFUyAqL1xcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMucnVsZXMgPSBbXTtcXG4nO1xuICAgIHJ1bGVzLmZvckVhY2goKHJ1bGUsIGlpKSA9PiB7XG4gICAgICBsZXQgdGhpc1J1bGUgPSAnICB0aGlzLnJ1bGVzWyc7XG4gICAgICB0aGlzUnVsZSArPSBpaTtcbiAgICAgIHRoaXNSdWxlICs9IFwiXSA9IHsgbmFtZTogJ1wiO1xuICAgICAgdGhpc1J1bGUgKz0gcnVsZS5uYW1lO1xuICAgICAgdGhpc1J1bGUgKz0gXCInLCBsb3dlcjogJ1wiO1xuICAgICAgdGhpc1J1bGUgKz0gcnVsZS5sb3dlcjtcbiAgICAgIHRoaXNSdWxlICs9IFwiJywgaW5kZXg6IFwiO1xuICAgICAgdGhpc1J1bGUgKz0gcnVsZS5pbmRleDtcbiAgICAgIHRoaXNSdWxlICs9ICcsIGlzQmtyOiAnO1xuICAgICAgdGhpc1J1bGUgKz0gcnVsZS5pc0JrcjtcbiAgICAgIHRoaXNSdWxlICs9ICcgfTtcXG4nO1xuICAgICAgc291cmNlICs9IHRoaXNSdWxlO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICBzb3VyY2UgKz0gJyAgLyogVURUUyAqL1xcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMudWR0cyA9IFtdO1xcbic7XG4gICAgaWYgKHVkdHMubGVuZ3RoID4gMCkge1xuICAgICAgdWR0cy5mb3JFYWNoKCh1ZHRGdW5jLCBpaSkgPT4ge1xuICAgICAgICBsZXQgdGhpc1VkdCA9ICcgIHRoaXMudWR0c1snO1xuICAgICAgICB0aGlzVWR0ICs9IGlpO1xuICAgICAgICB0aGlzVWR0ICs9IFwiXSA9IHsgbmFtZTogJ1wiO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMubmFtZTtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGxvd2VyOiAnXCI7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5sb3dlcjtcbiAgICAgICAgdGhpc1VkdCArPSBcIicsIGluZGV4OiBcIjtcbiAgICAgICAgdGhpc1VkdCArPSB1ZHRGdW5jLmluZGV4O1xuICAgICAgICB0aGlzVWR0ICs9ICcsIGVtcHR5OiAnO1xuICAgICAgICB0aGlzVWR0ICs9IHVkdEZ1bmMuZW1wdHk7XG4gICAgICAgIHRoaXNVZHQgKz0gJywgaXNCa3I6ICc7XG4gICAgICAgIHRoaXNVZHQgKz0gdWR0RnVuYy5pc0JrcjtcbiAgICAgICAgdGhpc1VkdCArPSAnIH07XFxuJztcbiAgICAgICAgc291cmNlICs9IHRoaXNVZHQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc291cmNlICs9ICdcXG4nO1xuICAgIHNvdXJjZSArPSAnICAvKiBPUENPREVTICovXFxuJztcbiAgICBydWxlcy5mb3JFYWNoKChydWxlLCBydWxlSW5kZXgpID0+IHtcbiAgICAgIGlmIChydWxlSW5kZXggPiAwKSB7XG4gICAgICAgIHNvdXJjZSArPSAnXFxuJztcbiAgICAgIH1cbiAgICAgIHNvdXJjZSArPSBgICAvKiAke3J1bGUubmFtZX0gKi9cXG5gO1xuICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzID0gW107XFxuYDtcbiAgICAgIHJ1bGUub3Bjb2Rlcy5mb3JFYWNoKChvcCwgb3BJbmRleCkgPT4ge1xuICAgICAgICBsZXQgcHJlZml4O1xuICAgICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIGlkLkFMVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFske29wLmNoaWxkcmVuLnRvU3RyaW5nKCl9XSB9Oy8vIEFMVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtcbiAgICAgICAgICAgICAgb3AudHlwZVxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFske29wLmNoaWxkcmVuLnRvU3RyaW5nKCl9XSB9Oy8vIENBVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlJOTTpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSwgaW5kZXg6ICR7XG4gICAgICAgICAgICAgIG9wLmluZGV4XG4gICAgICAgICAgICB9IH07Ly8gUk5NKCR7cnVsZXNbb3AuaW5kZXhdLm5hbWV9KVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkJLUjpcbiAgICAgICAgICAgIGlmIChvcC5pbmRleCA+PSBydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYmtybmFtZSA9IHVkdHNbb3AuaW5kZXggLSBydWxlcy5sZW5ndGhdLm5hbWU7XG4gICAgICAgICAgICAgIGJrcmxvd2VyID0gdWR0c1tvcC5pbmRleCAtIHJ1bGVzLmxlbmd0aF0ubG93ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBia3JuYW1lID0gcnVsZXNbb3AuaW5kZXhdLm5hbWU7XG4gICAgICAgICAgICAgIGJrcmxvd2VyID0gcnVsZXNbb3AuaW5kZXhdLmxvd2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZml4ID0gJyVpJztcbiAgICAgICAgICAgIGlmIChvcC5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DUykge1xuICAgICAgICAgICAgICBwcmVmaXggPSAnJXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wLmJrck1vZGUgPT09IGlkLkJLUl9NT0RFX1VNKSB7XG4gICAgICAgICAgICAgIHByZWZpeCArPSAnJXUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJlZml4ICs9ICclcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBia3JuYW1lID0gcHJlZml4ICsgYmtybmFtZTtcbiAgICAgICAgICAgIHNvdXJjZSArPVxuICAgICAgICAgICAgICBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSwgaW5kZXg6ICR7b3AuaW5kZXh9LCBsb3dlcjogJyR7YmtybG93ZXJ9J2AgK1xuICAgICAgICAgICAgICBgLCBia3JDYXNlOiAke29wLmJrckNhc2V9LCBia3JNb2RlOiAke29wLmJrck1vZGV9IH07Ly8gQktSKFxcXFwke2Jrcm5hbWV9KVxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSwgZW1wdHk6ICR7XG4gICAgICAgICAgICAgIG9wLmVtcHR5XG4gICAgICAgICAgICB9LCBpbmRleDogJHtvcC5pbmRleH0gfTsvLyBVRFQoJHt1ZHRzW29wLmluZGV4XS5uYW1lfSlcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7IHR5cGU6ICR7b3AudHlwZX0sIG1pbjogJHtvcC5taW59LCBtYXg6ICR7b3AubWF4fSB9Oy8vIFJFUFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSB9Oy8vIEFORFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLk5PVDpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSB9Oy8vIE5PVFxcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSB9Oy8vIEFCRyglXilcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5BRU46XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7IHR5cGU6ICR7b3AudHlwZX0gfTsvLyBBRU4oJSQpXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0geyB0eXBlOiAke29wLnR5cGV9IH07Ly8gQktBXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0geyB0eXBlOiAke29wLnR5cGV9IH07Ly8gQktOXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgICAgc291cmNlICs9IGAgIHRoaXMucnVsZXNbJHtydWxlSW5kZXh9XS5vcGNvZGVzWyR7b3BJbmRleH1dID0geyB0eXBlOiAke1xuICAgICAgICAgICAgICBvcC50eXBlXG4gICAgICAgICAgICB9LCBzdHJpbmc6IFske29wLnN0cmluZy50b1N0cmluZygpfV0gfTsvLyBUTFNcXG5gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgICBzb3VyY2UgKz0gYCAgdGhpcy5ydWxlc1ske3J1bGVJbmRleH1dLm9wY29kZXNbJHtvcEluZGV4fV0gPSB7IHR5cGU6ICR7XG4gICAgICAgICAgICAgIG9wLnR5cGVcbiAgICAgICAgICAgIH0sIHN0cmluZzogWyR7b3Auc3RyaW5nLnRvU3RyaW5nKCl9XSB9Oy8vIFRCU1xcbmA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICAgIHNvdXJjZSArPSBgICB0aGlzLnJ1bGVzWyR7cnVsZUluZGV4fV0ub3Bjb2Rlc1ske29wSW5kZXh9XSA9IHsgdHlwZTogJHtvcC50eXBlfSwgbWluOiAke29wLm1pbn0sIG1heDogJHtvcC5tYXh9IH07Ly8gVFJHXFxuYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnNlci5qczogfjE0MzogdW5yZWNvZ25pemVkIG9wY29kZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gJ1xcbic7XG4gICAgc291cmNlICs9ICcgIC8vIFRoZSBgdG9TdHJpbmcoKWAgZnVuY3Rpb24gd2lsbCBkaXNwbGF5IHRoZSBvcmlnaW5hbCBncmFtbWFyIGZpbGUocykgdGhhdCBwcm9kdWNlZCB0aGVzZSBvcGNvZGVzLlxcbic7XG4gICAgc291cmNlICs9ICcgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xcbic7XG4gICAgc291cmNlICs9ICcgICAgbGV0IHN0ciA9IFwiXCI7XFxuJztcbiAgICBsZXQgc3RyO1xuICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGVuZCA9IGxpbmUuYmVnaW5DaGFyICsgbGluZS5sZW5ndGg7XG4gICAgICBzdHIgPSAnJztcbiAgICAgIHNvdXJjZSArPSAnICAgIHN0ciArPSBcIic7XG4gICAgICBmb3IgKGxldCBpaSA9IGxpbmUuYmVnaW5DaGFyOyBpaSA8IGVuZDsgaWkgKz0gMSkge1xuICAgICAgICBzd2l0Y2ggKGNoYXJzW2lpXSkge1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHN0ciA9ICcgJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBzdHIgPSAnXFxcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHN0ciA9ICdcXFxccic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgc3RyID0gJ1xcXFxcIic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgICAgc3RyID0gJ1xcXFxcXFxcJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJzW2lpXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgKz0gc3RyO1xuICAgICAgfVxuICAgICAgc291cmNlICs9ICdcIjtcXG4nO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSAnICAgIHJldHVybiBzdHI7XFxuJztcbiAgICBzb3VyY2UgKz0gJyAgfVxcbic7XG4gICAgc291cmNlICs9ICd9XFxuJztcbiAgICByZXR1cm4gc291cmNlO1xuICB9O1xuICAvLyBHZW5lcmF0ZSBhIGdyYW1tYXIgZmlsZSBvYmplY3QuXG4gIC8vIFJldHVybnMgdGhlIHNhbWUgb2JqZWN0IGFzIGluc3RhbnRpYXRpbmcgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHJldHVybmVkIGJ5PGJyPlxuICAvLyBgdGhpcy5nZW5lcmF0ZVNvdXJjZSgpYC48YnI+XG4gIHRoaXMuZ2VuZXJhdGVPYmplY3QgPSBmdW5jdGlvbiBnZW5lcmF0ZU9iamVjdChzdHJpbmdBcmcsIHJ1bGVzLCB1ZHRzKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgY29uc3QgcnVsZU5hbWVzID0gW107XG4gICAgY29uc3QgdWR0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBzdHJpbmcgPSBzdHJpbmdBcmcuc2xpY2UoMCk7XG4gICAgb2JqLmdyYW1tYXJPYmplY3QgPSAnZ3JhbW1hck9iamVjdCc7XG4gICAgcnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgcnVsZU5hbWVzLnB1c2gocnVsZS5sb3dlcik7XG4gICAgfSk7XG4gICAgcnVsZU5hbWVzLnNvcnQoKTtcbiAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1ZHRzLmZvckVhY2goKHVkdEZ1bmMpID0+IHtcbiAgICAgICAgdWR0TmFtZXMucHVzaCh1ZHRGdW5jLmxvd2VyKTtcbiAgICAgIH0pO1xuICAgICAgdWR0TmFtZXMuc29ydCgpO1xuICAgIH1cbiAgICBvYmouY2FsbGJhY2tzID0gW107XG4gICAgcnVsZU5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIG9iai5jYWxsYmFja3NbbmFtZV0gPSBmYWxzZTtcbiAgICB9KTtcbiAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1ZHROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIG9iai5jYWxsYmFja3NbbmFtZV0gPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBvYmoucnVsZXMgPSBydWxlcztcbiAgICBvYmoudWR0cyA9IHVkdHM7XG4gICAgb2JqLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmdGdW5jKCkge1xuICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIHJldHVybiBvYmo7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/rule-attributes.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/rule-attributes.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module does the heavy lifting for attribute generation.\nmodule.exports = (function exportRuleAttributes() {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const thisFile = 'rule-attributes.js';\n  let state = null;\n  function isEmptyOnly(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return false;\n    }\n    return attr.empty;\n  }\n  function isRecursive(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return true;\n    }\n    return false;\n  }\n  function isCatNested(attrs, count) {\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    /* 1. if any child is nested, CAT is nested */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].nested) {\n        return true;\n      }\n    }\n    /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].right && !attrs[i].leaf) {\n        for (j = i + 1; j < count; j += 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */\n    for (i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].left && !attrs[i].leaf) {\n        for (j = i - 1; j >= 0; j -= 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */\n    for (i = 0; i < count; i += 1) {\n      if (!attrs[i].empty && !isRecursive(attrs[i])) {\n        for (j = i + 1; j < count; j += 1) {\n          if (isRecursive(attrs[j])) {\n            for (k = j + 1; k < count; k += 1) {\n              if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /* none of the above */\n    return false;\n  }\n  function isCatCyclic(attrs, count) {\n    /* if all children are cyclic, CAT is cyclic */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].cyclic) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatLeft(attrs, count) {\n    /* if the left-most non-empty is left, CAT is left */\n    for (let i = 0; i < count; i += 1) {\n      if (attrs[i].left) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false; /* all left-most are empty */\n  }\n  function isCatRight(attrs, count) {\n    /* if the right-most non-empty is right, CAT is right */\n    for (let i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].right) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false;\n  }\n  function isCatEmpty(attrs, count) {\n    /* if all children are empty, CAT is empty */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].empty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatFinite(attrs, count) {\n    /* if all children are finite, CAT is finite */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].finite) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function cat(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opCat = opcodes[opIndex];\n    const count = opCat.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n    }\n    iAttr.left = isCatLeft(childAttrs, count);\n    iAttr.right = isCatRight(childAttrs, count);\n    iAttr.nested = isCatNested(childAttrs, count);\n    iAttr.empty = isCatEmpty(childAttrs, count);\n    iAttr.finite = isCatFinite(childAttrs, count);\n    iAttr.cyclic = isCatCyclic(childAttrs, count);\n  }\n  function alt(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opAlt = opcodes[opIndex];\n    const count = opAlt.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n    }\n\n    /* if any child attribute is true, ALT is true */\n    iAttr.left = false;\n    iAttr.right = false;\n    iAttr.nested = false;\n    iAttr.empty = false;\n    iAttr.finite = false;\n    iAttr.cyclic = false;\n    for (i = 0; i < count; i += 1) {\n      if (childAttrs[i].left) {\n        iAttr.left = true;\n      }\n      if (childAttrs[i].nested) {\n        iAttr.nested = true;\n      }\n      if (childAttrs[i].right) {\n        iAttr.right = true;\n      }\n      if (childAttrs[i].empty) {\n        iAttr.empty = true;\n      }\n      if (childAttrs[i].finite) {\n        iAttr.finite = true;\n      }\n      if (childAttrs[i].cyclic) {\n        iAttr.cyclic = true;\n      }\n    }\n  }\n  function bkr(stateArg, opcodes, opIndex, iAttr) {\n    const opBkr = opcodes[opIndex];\n    if (opBkr.index >= stateArg.ruleCount) {\n      /* use UDT values */\n      iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n      iAttr.finite = true;\n    } else {\n      /* use the empty and finite values from the back referenced rule */\n      // eslint-disable-next-line no-use-before-define\n      ruleAttrsEval(stateArg, opBkr.index, iAttr);\n\n      /* however, this is a terminal node like TLS */\n      iAttr.left = false;\n      iAttr.nested = false;\n      iAttr.right = false;\n      iAttr.cyclic = false;\n    }\n  }\n\n  function opEval(stateArg, opcodes, opIndex, iAttr) {\n    stateArg.attrInit(iAttr);\n    const opi = opcodes[opIndex];\n    switch (opi.type) {\n      case id.ALT:\n        alt(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.CAT:\n        cat(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.REP:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        if (opi.min === 0) {\n          iAttr.empty = true;\n          iAttr.finite = true;\n        }\n        break;\n      case id.RNM:\n        // eslint-disable-next-line no-use-before-define\n        ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n        break;\n      case id.BKR:\n        bkr(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.AND:\n      case id.NOT:\n      case id.BKA:\n      case id.BKN:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        iAttr.empty = true;\n        break;\n      case id.TLS:\n        iAttr.empty = !opcodes[opIndex].string.length;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.TBS:\n      case id.TRG:\n        iAttr.empty = false;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.UDT:\n        iAttr.empty = opi.empty;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.ABG:\n      case id.AEN:\n        iAttr.empty = true;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      default:\n        throw new Error(`unknown opcode type: ${opi}`);\n    }\n  }\n  // The main logic for handling rules that:\n  //  - have already be evaluated\n  //  - have not been evaluated and is the first occurrence on this branch\n  //  - second occurrence on this branch for the start rule\n  //  - second occurrence on this branch for non-start rules\n  function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n    const attri = stateArg.attrsWorking[ruleIndex];\n    if (attri.isComplete) {\n      /* just use the completed values */\n      stateArg.attrCopy(iAttr, attri);\n    } else if (!attri.isOpen) {\n      /* open the rule and traverse it */\n      attri.isOpen = true;\n      opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n      /* complete this rule's attributes */\n      attri.left = iAttr.left;\n      attri.right = iAttr.right;\n      attri.nested = iAttr.nested;\n      attri.empty = iAttr.empty;\n      attri.finite = iAttr.finite;\n      attri.cyclic = iAttr.cyclic;\n      attri.leaf = false;\n      attri.isOpen = false;\n      attri.isComplete = true;\n    } else if (ruleIndex === stateArg.startRule) {\n      /* use recursive leaf values */\n      if (ruleIndex === stateArg.startRule) {\n        iAttr.left = true;\n        iAttr.right = true;\n        iAttr.cyclic = true;\n        iAttr.leaf = true;\n      }\n    } else {\n      /* non-start rule terminal leaf */\n      iAttr.finite = true;\n    }\n  }\n  // The main driver for the attribute generation.\n  const ruleAttributes = (stateArg) => {\n    state = stateArg;\n    let i = 0;\n    let j = 0;\n    const iAttr = state.attrGen();\n    for (i = 0; i < state.ruleCount; i += 1) {\n      /* initialize working attributes */\n      for (j = 0; j < state.ruleCount; j += 1) {\n        state.attrInit(state.attrsWorking[j]);\n      }\n      state.startRule = i;\n      ruleAttrsEval(state, i, iAttr);\n\n      /* save off the working attributes for this rule */\n      state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n    }\n    state.attributesComplete = true;\n    let attri = null;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      attri = state.attrs[i];\n      if (attri.left || !attri.finite || attri.cyclic) {\n        const temp = state.attrGen(attri.rule);\n        state.attrCopy(temp, attri);\n        state.attrsErrors.push(temp);\n        state.attrsErrorCount += 1;\n      }\n    }\n  };\n  const truth = (val) => (val ? 't' : 'f');\n  const tError = (val) => (val ? 'e' : 'f');\n  const fError = (val) => (val ? 't' : 'e');\n  const showAttr = (seq, index, attr, dep) => {\n    let str = `${seq}:${index}:`;\n    str += `${tError(attr.left)} `;\n    str += `${truth(attr.nested)} `;\n    str += `${truth(attr.right)} `;\n    str += `${tError(attr.cyclic)} `;\n    str += `${fError(attr.finite)} `;\n    str += `${truth(attr.empty)}:`;\n    str += `${state.typeToString(dep.recursiveType)}:`;\n    str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : '-';\n    str += `:${attr.rule.name}\\n`;\n    return str;\n  };\n\n  const showLegend = () => {\n    let str = 'LEGEND - t=true, f=false, e=error\\n';\n    str += 'sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n';\n    return str;\n  };\n  const showAttributeErrors = () => {\n    let attri = null;\n    let depi = null;\n    let str = '';\n    str += 'RULE ATTRIBUTES WITH ERRORS\\n';\n    str += showLegend();\n    if (state.attrsErrorCount) {\n      for (let i = 0; i < state.attrsErrorCount; i += 1) {\n        attri = state.attrsErrors[i];\n        depi = state.ruleDeps[attri.rule.index];\n        str += showAttr(i, attri.rule.index, attri, depi);\n      }\n    } else {\n      str += '<none>\\n';\n    }\n    return str;\n  };\n\n  const show = (type) => {\n    let i = 0;\n    let ii = 0;\n    let attri = null;\n    let depi = null;\n    let str = '';\n    let { ruleIndexes } = state;\n    // let udtIndexes = state.udtIndexes;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    }\n    /* show all attributes */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      ii = ruleIndexes[i];\n      attri = state.attrs[ii];\n      depi = state.ruleDeps[ii];\n      str += showAttr(i, ii, attri, depi);\n    }\n    return str;\n  };\n\n  // Display the rule attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showAttributes = (order = 'index') => {\n    if (!state.attributesComplete) {\n      throw new Error(`${thisFile}:showAttributes: attributes not available`);\n    }\n    let str = '';\n    const leader = 'RULE ATTRIBUTES\\n';\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += leader;\n      str += showLegend();\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += leader;\n      str += showLegend();\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += leader;\n      str += showLegend();\n      str += show();\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleAttributes, showAttributes, showAttributeErrors };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0ZBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLEdBQUcsTUFBTTtBQUM5QixjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLHNDQUFzQztBQUNwRDtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtYXR0cmlidXRlcy5qcz9jMWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGRvZXMgdGhlIGhlYXZ5IGxpZnRpbmcgZm9yIGF0dHJpYnV0ZSBnZW5lcmF0aW9uLlxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gZXhwb3J0UnVsZUF0dHJpYnV0ZXMoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9pZGVudGlmaWVycycpO1xuICBjb25zdCB0aGlzRmlsZSA9ICdydWxlLWF0dHJpYnV0ZXMuanMnO1xuICBsZXQgc3RhdGUgPSBudWxsO1xuICBmdW5jdGlvbiBpc0VtcHR5T25seShhdHRyKSB7XG4gICAgaWYgKGF0dHIubGVmdCB8fCBhdHRyLm5lc3RlZCB8fCBhdHRyLnJpZ2h0IHx8IGF0dHIuY3ljbGljKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhdHRyLmVtcHR5O1xuICB9XG4gIGZ1bmN0aW9uIGlzUmVjdXJzaXZlKGF0dHIpIHtcbiAgICBpZiAoYXR0ci5sZWZ0IHx8IGF0dHIubmVzdGVkIHx8IGF0dHIucmlnaHQgfHwgYXR0ci5jeWNsaWMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXROZXN0ZWQoYXR0cnMsIGNvdW50KSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgayA9IDA7XG4gICAgLyogMS4gaWYgYW55IGNoaWxkIGlzIG5lc3RlZCwgQ0FUIGlzIG5lc3RlZCAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ubmVzdGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiAyLikgdGhlIGxlZnQtbW9zdCByaWdodCByZWN1cnNpdmUgY2hpbGRcbiAgICAgICAgICAgICAgIGlzIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBub24tZW1wdHkgY2hpbGQgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLnJpZ2h0ICYmICFhdHRyc1tpXS5sZWFmKSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgY291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmICghaXNFbXB0eU9ubHkoYXR0cnNbal0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogMy4pIHRoZSByaWdodC1tb3N0IGxlZnQgcmVjdXJzaXZlIGNoaWxkXG4gICAgICAgICAgICAgICBpcyBwcmVjZWRlZCBieSBhdCBsZWFzdCBvbmUgbm9uLWVtcHR5IGNoaWxkICovXG4gICAgZm9yIChpID0gY291bnQgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLmxlZnQgJiYgIWF0dHJzW2ldLmxlYWYpIHtcbiAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgaWYgKCFpc0VtcHR5T25seShhdHRyc1tqXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiA0LiB0aGVyZSBpcyBhdCBsZWFzZSBvbmUgcmVjdXJzaXZlIGNoaWxkIGJldHdlZW5cbiAgICAgICAgICAgICAgdGhlIGxlZnQtbW9zdCBhbmQgcmlnaHQtbW9zdCBub24tcmVjdXJzaXZlLCBub24tZW1wdHkgY2hpbGRyZW4gKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5lbXB0eSAmJiAhaXNSZWN1cnNpdmUoYXR0cnNbaV0pKSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgY291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChpc1JlY3Vyc2l2ZShhdHRyc1tqXSkpIHtcbiAgICAgICAgICAgIGZvciAoayA9IGogKyAxOyBrIDwgY291bnQ7IGsgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAoIWF0dHJzW2tdLmVtcHR5ICYmICFpc1JlY3Vyc2l2ZShhdHRyc1trXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qIG5vbmUgb2YgdGhlIGFib3ZlICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0Q3ljbGljKGF0dHJzLCBjb3VudCkge1xuICAgIC8qIGlmIGFsbCBjaGlsZHJlbiBhcmUgY3ljbGljLCBDQVQgaXMgY3ljbGljICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoIWF0dHJzW2ldLmN5Y2xpYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIGlzQ2F0TGVmdChhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiB0aGUgbGVmdC1tb3N0IG5vbi1lbXB0eSBpcyBsZWZ0LCBDQVQgaXMgbGVmdCAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGF0dHJzW2ldLmxlZnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIGtlZXAgbG9va2luZyAqL1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7IC8qIGFsbCBsZWZ0LW1vc3QgYXJlIGVtcHR5ICovXG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRSaWdodChhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiB0aGUgcmlnaHQtbW9zdCBub24tZW1wdHkgaXMgcmlnaHQsIENBVCBpcyByaWdodCAqL1xuICAgIGZvciAobGV0IGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAoYXR0cnNbaV0ucmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJzW2ldLmVtcHR5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8qIGtlZXAgbG9va2luZyAqL1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaXNDYXRFbXB0eShhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiBhbGwgY2hpbGRyZW4gYXJlIGVtcHR5LCBDQVQgaXMgZW1wdHkgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlmICghYXR0cnNbaV0uZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBpc0NhdEZpbml0ZShhdHRycywgY291bnQpIHtcbiAgICAvKiBpZiBhbGwgY2hpbGRyZW4gYXJlIGZpbml0ZSwgQ0FUIGlzIGZpbml0ZSAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaWYgKCFhdHRyc1tpXS5maW5pdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBjYXQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IG9wQ2F0ID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBjb3VudCA9IG9wQ2F0LmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIC8qIGdlbmVyYXRlIGFuIGVtcHR5IGFycmF5IG9mIGNoaWxkIGF0dHJpYnV0ZXMgKi9cbiAgICBjb25zdCBjaGlsZEF0dHJzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGNoaWxkQXR0cnMucHVzaChzdGF0ZUFyZy5hdHRyR2VuKCkpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBvcEV2YWwoc3RhdGVBcmcsIG9wY29kZXMsIG9wQ2F0LmNoaWxkcmVuW2ldLCBjaGlsZEF0dHJzW2ldKTtcbiAgICB9XG4gICAgaUF0dHIubGVmdCA9IGlzQ2F0TGVmdChjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIucmlnaHQgPSBpc0NhdFJpZ2h0KGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5uZXN0ZWQgPSBpc0NhdE5lc3RlZChjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIuZW1wdHkgPSBpc0NhdEVtcHR5KGNoaWxkQXR0cnMsIGNvdW50KTtcbiAgICBpQXR0ci5maW5pdGUgPSBpc0NhdEZpbml0ZShjaGlsZEF0dHJzLCBjb3VudCk7XG4gICAgaUF0dHIuY3ljbGljID0gaXNDYXRDeWNsaWMoY2hpbGRBdHRycywgY291bnQpO1xuICB9XG4gIGZ1bmN0aW9uIGFsdChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCwgaUF0dHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgY29uc3Qgb3BBbHQgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IGNvdW50ID0gb3BBbHQuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLyogZ2VuZXJhdGUgYW4gZW1wdHkgYXJyYXkgb2YgY2hpbGQgYXR0cmlidXRlcyAqL1xuICAgIGNvbnN0IGNoaWxkQXR0cnMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgY2hpbGRBdHRycy5wdXNoKHN0YXRlQXJnLmF0dHJHZW4oKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BBbHQuY2hpbGRyZW5baV0sIGNoaWxkQXR0cnNbaV0pO1xuICAgIH1cblxuICAgIC8qIGlmIGFueSBjaGlsZCBhdHRyaWJ1dGUgaXMgdHJ1ZSwgQUxUIGlzIHRydWUgKi9cbiAgICBpQXR0ci5sZWZ0ID0gZmFsc2U7XG4gICAgaUF0dHIucmlnaHQgPSBmYWxzZTtcbiAgICBpQXR0ci5uZXN0ZWQgPSBmYWxzZTtcbiAgICBpQXR0ci5lbXB0eSA9IGZhbHNlO1xuICAgIGlBdHRyLmZpbml0ZSA9IGZhbHNlO1xuICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5sZWZ0KSB7XG4gICAgICAgIGlBdHRyLmxlZnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQXR0cnNbaV0ubmVzdGVkKSB7XG4gICAgICAgIGlBdHRyLm5lc3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5yaWdodCkge1xuICAgICAgICBpQXR0ci5yaWdodCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5lbXB0eSkge1xuICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRBdHRyc1tpXS5maW5pdGUpIHtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEF0dHJzW2ldLmN5Y2xpYykge1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBia3Ioc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKSB7XG4gICAgY29uc3Qgb3BCa3IgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGlmIChvcEJrci5pbmRleCA+PSBzdGF0ZUFyZy5ydWxlQ291bnQpIHtcbiAgICAgIC8qIHVzZSBVRFQgdmFsdWVzICovXG4gICAgICBpQXR0ci5lbXB0eSA9IHN0YXRlQXJnLnVkdHNbb3BCa3IuaW5kZXggLSBzdGF0ZUFyZy5ydWxlQ291bnRdLmVtcHR5O1xuICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogdXNlIHRoZSBlbXB0eSBhbmQgZmluaXRlIHZhbHVlcyBmcm9tIHRoZSBiYWNrIHJlZmVyZW5jZWQgcnVsZSAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBydWxlQXR0cnNFdmFsKHN0YXRlQXJnLCBvcEJrci5pbmRleCwgaUF0dHIpO1xuXG4gICAgICAvKiBob3dldmVyLCB0aGlzIGlzIGEgdGVybWluYWwgbm9kZSBsaWtlIFRMUyAqL1xuICAgICAgaUF0dHIubGVmdCA9IGZhbHNlO1xuICAgICAgaUF0dHIubmVzdGVkID0gZmFsc2U7XG4gICAgICBpQXR0ci5yaWdodCA9IGZhbHNlO1xuICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cikge1xuICAgIHN0YXRlQXJnLmF0dHJJbml0KGlBdHRyKTtcbiAgICBjb25zdCBvcGkgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIHN3aXRjaCAob3BpLnR5cGUpIHtcbiAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICBhbHQoc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgY2F0KHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4LCBpQXR0cik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgIG9wRXZhbChzdGF0ZUFyZywgb3Bjb2Rlcywgb3BJbmRleCArIDEsIGlBdHRyKTtcbiAgICAgICAgaWYgKG9waS5taW4gPT09IDApIHtcbiAgICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcnVsZUF0dHJzRXZhbChzdGF0ZUFyZywgb3Bjb2Rlc1tvcEluZGV4XS5pbmRleCwgaUF0dHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICBia3Ioc3RhdGVBcmcsIG9wY29kZXMsIG9wSW5kZXgsIGlBdHRyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkFORDpcbiAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgY2FzZSBpZC5CS0E6XG4gICAgICBjYXNlIGlkLkJLTjpcbiAgICAgICAgb3BFdmFsKHN0YXRlQXJnLCBvcGNvZGVzLCBvcEluZGV4ICsgMSwgaUF0dHIpO1xuICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gIW9wY29kZXNbb3BJbmRleF0uc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgaUF0dHIuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgaUF0dHIuZmluaXRlID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgIGlBdHRyLmVtcHR5ID0gb3BpLmVtcHR5O1xuICAgICAgICBpQXR0ci5maW5pdGUgPSB0cnVlO1xuICAgICAgICBpQXR0ci5jeWNsaWMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkFCRzpcbiAgICAgIGNhc2UgaWQuQUVOOlxuICAgICAgICBpQXR0ci5lbXB0eSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgICAgIGlBdHRyLmN5Y2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBvcGNvZGUgdHlwZTogJHtvcGl9YCk7XG4gICAgfVxuICB9XG4gIC8vIFRoZSBtYWluIGxvZ2ljIGZvciBoYW5kbGluZyBydWxlcyB0aGF0OlxuICAvLyAgLSBoYXZlIGFscmVhZHkgYmUgZXZhbHVhdGVkXG4gIC8vICAtIGhhdmUgbm90IGJlZW4gZXZhbHVhdGVkIGFuZCBpcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvbiB0aGlzIGJyYW5jaFxuICAvLyAgLSBzZWNvbmQgb2NjdXJyZW5jZSBvbiB0aGlzIGJyYW5jaCBmb3IgdGhlIHN0YXJ0IHJ1bGVcbiAgLy8gIC0gc2Vjb25kIG9jY3VycmVuY2Ugb24gdGhpcyBicmFuY2ggZm9yIG5vbi1zdGFydCBydWxlc1xuICBmdW5jdGlvbiBydWxlQXR0cnNFdmFsKHN0YXRlQXJnLCBydWxlSW5kZXgsIGlBdHRyKSB7XG4gICAgY29uc3QgYXR0cmkgPSBzdGF0ZUFyZy5hdHRyc1dvcmtpbmdbcnVsZUluZGV4XTtcbiAgICBpZiAoYXR0cmkuaXNDb21wbGV0ZSkge1xuICAgICAgLyoganVzdCB1c2UgdGhlIGNvbXBsZXRlZCB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlQXJnLmF0dHJDb3B5KGlBdHRyLCBhdHRyaSk7XG4gICAgfSBlbHNlIGlmICghYXR0cmkuaXNPcGVuKSB7XG4gICAgICAvKiBvcGVuIHRoZSBydWxlIGFuZCB0cmF2ZXJzZSBpdCAqL1xuICAgICAgYXR0cmkuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIG9wRXZhbChzdGF0ZUFyZywgYXR0cmkucnVsZS5vcGNvZGVzLCAwLCBpQXR0cik7XG4gICAgICAvKiBjb21wbGV0ZSB0aGlzIHJ1bGUncyBhdHRyaWJ1dGVzICovXG4gICAgICBhdHRyaS5sZWZ0ID0gaUF0dHIubGVmdDtcbiAgICAgIGF0dHJpLnJpZ2h0ID0gaUF0dHIucmlnaHQ7XG4gICAgICBhdHRyaS5uZXN0ZWQgPSBpQXR0ci5uZXN0ZWQ7XG4gICAgICBhdHRyaS5lbXB0eSA9IGlBdHRyLmVtcHR5O1xuICAgICAgYXR0cmkuZmluaXRlID0gaUF0dHIuZmluaXRlO1xuICAgICAgYXR0cmkuY3ljbGljID0gaUF0dHIuY3ljbGljO1xuICAgICAgYXR0cmkubGVhZiA9IGZhbHNlO1xuICAgICAgYXR0cmkuaXNPcGVuID0gZmFsc2U7XG4gICAgICBhdHRyaS5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJ1bGVJbmRleCA9PT0gc3RhdGVBcmcuc3RhcnRSdWxlKSB7XG4gICAgICAvKiB1c2UgcmVjdXJzaXZlIGxlYWYgdmFsdWVzICovXG4gICAgICBpZiAocnVsZUluZGV4ID09PSBzdGF0ZUFyZy5zdGFydFJ1bGUpIHtcbiAgICAgICAgaUF0dHIubGVmdCA9IHRydWU7XG4gICAgICAgIGlBdHRyLnJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIuY3ljbGljID0gdHJ1ZTtcbiAgICAgICAgaUF0dHIubGVhZiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIG5vbi1zdGFydCBydWxlIHRlcm1pbmFsIGxlYWYgKi9cbiAgICAgIGlBdHRyLmZpbml0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIFRoZSBtYWluIGRyaXZlciBmb3IgdGhlIGF0dHJpYnV0ZSBnZW5lcmF0aW9uLlxuICBjb25zdCBydWxlQXR0cmlidXRlcyA9IChzdGF0ZUFyZykgPT4ge1xuICAgIHN0YXRlID0gc3RhdGVBcmc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBjb25zdCBpQXR0ciA9IHN0YXRlLmF0dHJHZW4oKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIC8qIGluaXRpYWxpemUgd29ya2luZyBhdHRyaWJ1dGVzICovXG4gICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUucnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgc3RhdGUuYXR0ckluaXQoc3RhdGUuYXR0cnNXb3JraW5nW2pdKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnN0YXJ0UnVsZSA9IGk7XG4gICAgICBydWxlQXR0cnNFdmFsKHN0YXRlLCBpLCBpQXR0cik7XG5cbiAgICAgIC8qIHNhdmUgb2ZmIHRoZSB3b3JraW5nIGF0dHJpYnV0ZXMgZm9yIHRoaXMgcnVsZSAqL1xuICAgICAgc3RhdGUuYXR0ckNvcHkoc3RhdGUuYXR0cnNbaV0sIHN0YXRlLmF0dHJzV29ya2luZ1tpXSk7XG4gICAgfVxuICAgIHN0YXRlLmF0dHJpYnV0ZXNDb21wbGV0ZSA9IHRydWU7XG4gICAgbGV0IGF0dHJpID0gbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGF0dHJpID0gc3RhdGUuYXR0cnNbaV07XG4gICAgICBpZiAoYXR0cmkubGVmdCB8fCAhYXR0cmkuZmluaXRlIHx8IGF0dHJpLmN5Y2xpYykge1xuICAgICAgICBjb25zdCB0ZW1wID0gc3RhdGUuYXR0ckdlbihhdHRyaS5ydWxlKTtcbiAgICAgICAgc3RhdGUuYXR0ckNvcHkodGVtcCwgYXR0cmkpO1xuICAgICAgICBzdGF0ZS5hdHRyc0Vycm9ycy5wdXNoKHRlbXApO1xuICAgICAgICBzdGF0ZS5hdHRyc0Vycm9yQ291bnQgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHRydXRoID0gKHZhbCkgPT4gKHZhbCA/ICd0JyA6ICdmJyk7XG4gIGNvbnN0IHRFcnJvciA9ICh2YWwpID0+ICh2YWwgPyAnZScgOiAnZicpO1xuICBjb25zdCBmRXJyb3IgPSAodmFsKSA9PiAodmFsID8gJ3QnIDogJ2UnKTtcbiAgY29uc3Qgc2hvd0F0dHIgPSAoc2VxLCBpbmRleCwgYXR0ciwgZGVwKSA9PiB7XG4gICAgbGV0IHN0ciA9IGAke3NlcX06JHtpbmRleH06YDtcbiAgICBzdHIgKz0gYCR7dEVycm9yKGF0dHIubGVmdCl9IGA7XG4gICAgc3RyICs9IGAke3RydXRoKGF0dHIubmVzdGVkKX0gYDtcbiAgICBzdHIgKz0gYCR7dHJ1dGgoYXR0ci5yaWdodCl9IGA7XG4gICAgc3RyICs9IGAke3RFcnJvcihhdHRyLmN5Y2xpYyl9IGA7XG4gICAgc3RyICs9IGAke2ZFcnJvcihhdHRyLmZpbml0ZSl9IGA7XG4gICAgc3RyICs9IGAke3RydXRoKGF0dHIuZW1wdHkpfTpgO1xuICAgIHN0ciArPSBgJHtzdGF0ZS50eXBlVG9TdHJpbmcoZGVwLnJlY3Vyc2l2ZVR5cGUpfTpgO1xuICAgIHN0ciArPSBkZXAucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9NUiA/IGRlcC5ncm91cE51bWJlciA6ICctJztcbiAgICBzdHIgKz0gYDoke2F0dHIucnVsZS5uYW1lfVxcbmA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBjb25zdCBzaG93TGVnZW5kID0gKCkgPT4ge1xuICAgIGxldCBzdHIgPSAnTEVHRU5EIC0gdD10cnVlLCBmPWZhbHNlLCBlPWVycm9yXFxuJztcbiAgICBzdHIgKz0gJ3NlcXVlbmNlOnJ1bGUgaW5kZXg6bGVmdCBuZXN0ZWQgcmlnaHQgY3ljbGljIGZpbml0ZSBlbXB0eTp0eXBlOmdyb3VwIG51bWJlcjpydWxlIG5hbWVcXG4nO1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIGNvbnN0IHNob3dBdHRyaWJ1dGVFcnJvcnMgPSAoKSA9PiB7XG4gICAgbGV0IGF0dHJpID0gbnVsbDtcbiAgICBsZXQgZGVwaSA9IG51bGw7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIHN0ciArPSAnUlVMRSBBVFRSSUJVVEVTIFdJVEggRVJST1JTXFxuJztcbiAgICBzdHIgKz0gc2hvd0xlZ2VuZCgpO1xuICAgIGlmIChzdGF0ZS5hdHRyc0Vycm9yQ291bnQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuYXR0cnNFcnJvckNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgYXR0cmkgPSBzdGF0ZS5hdHRyc0Vycm9yc1tpXTtcbiAgICAgICAgZGVwaSA9IHN0YXRlLnJ1bGVEZXBzW2F0dHJpLnJ1bGUuaW5kZXhdO1xuICAgICAgICBzdHIgKz0gc2hvd0F0dHIoaSwgYXR0cmkucnVsZS5pbmRleCwgYXR0cmksIGRlcGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJzxub25lPlxcbic7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgY29uc3Qgc2hvdyA9ICh0eXBlKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBpaSA9IDA7XG4gICAgbGV0IGF0dHJpID0gbnVsbDtcbiAgICBsZXQgZGVwaSA9IG51bGw7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCB7IHJ1bGVJbmRleGVzIH0gPSBzdGF0ZTtcbiAgICAvLyBsZXQgdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEluZGV4ZXM7XG4gICAgaWYgKHR5cGUgPT09IDk3KSB7XG4gICAgICBydWxlSW5kZXhlcyA9IHN0YXRlLnJ1bGVBbHBoYUluZGV4ZXM7XG4gICAgICAvLyB1ZHRJbmRleGVzID0gc3RhdGUudWR0QWxwaGFJbmRleGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTE2KSB7XG4gICAgICBydWxlSW5kZXhlcyA9IHN0YXRlLnJ1bGVUeXBlSW5kZXhlcztcbiAgICAgIC8vIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfVxuICAgIC8qIHNob3cgYWxsIGF0dHJpYnV0ZXMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIGlpID0gcnVsZUluZGV4ZXNbaV07XG4gICAgICBhdHRyaSA9IHN0YXRlLmF0dHJzW2lpXTtcbiAgICAgIGRlcGkgPSBzdGF0ZS5ydWxlRGVwc1tpaV07XG4gICAgICBzdHIgKz0gc2hvd0F0dHIoaSwgaWksIGF0dHJpLCBkZXBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvLyBEaXNwbGF5IHRoZSBydWxlIGF0dHJpYnV0ZXMuXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gXCJ0eXBlXCIgb3IgXCJ0XCIsIG9yZGVyZWQgYnkgdHlwZSAoYWxwaGFiZXRpY2FsIHdpdGhpbiBlYWNoIHR5cGUvZ3JvdXApXG4gIC8vICAgICAgLSBub25lIG9mIGFib3ZlLCBpbmRleCBvcmRlciAoZGVmYXVsdClcbiAgY29uc3Qgc2hvd0F0dHJpYnV0ZXMgPSAob3JkZXIgPSAnaW5kZXgnKSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5hdHRyaWJ1dGVzQ29tcGxldGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZX06c2hvd0F0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMgbm90IGF2YWlsYWJsZWApO1xuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgY29uc3QgbGVhZGVyID0gJ1JVTEUgQVRUUklCVVRFU1xcbic7XG4gICAgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDk3KSB7XG4gICAgICBzdHIgKz0gJ2FscGhhYmV0aWNhbCBieSBydWxlIG5hbWVcXG4nO1xuICAgICAgc3RyICs9IGxlYWRlcjtcbiAgICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgICBzdHIgKz0gc2hvdyg5Nyk7XG4gICAgfSBlbHNlIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSAxMTYpIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIHR5cGVcXG4nO1xuICAgICAgc3RyICs9IGxlYWRlcjtcbiAgICAgIHN0ciArPSBzaG93TGVnZW5kKCk7XG4gICAgICBzdHIgKz0gc2hvdygxMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJ29yZGVyZWQgYnkgcnVsZSBpbmRleFxcbic7XG4gICAgICBzdHIgKz0gbGVhZGVyO1xuICAgICAgc3RyICs9IHNob3dMZWdlbmQoKTtcbiAgICAgIHN0ciArPSBzaG93KCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyogRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IC0gc2VlIE1ETiBXZWIgRG9jcyAqL1xuICByZXR1cm4geyBydWxlQXR0cmlidXRlcywgc2hvd0F0dHJpYnV0ZXMsIHNob3dBdHRyaWJ1dGVFcnJvcnMgfTtcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/rule-attributes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/rule-dependencies.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/rule-dependencies.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\nmodule.exports = (() => {\n  const id = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  let state = null; /* keep a global reference to the state for the show functions */\n\n  /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */\n  const scan = (ruleCount, ruleDeps, index, isScanned) => {\n    let i = 0;\n    let j = 0;\n    const rdi = ruleDeps[index];\n    isScanned[index] = true;\n    const op = rdi.rule.opcodes;\n    for (i = 0; i < op.length; i += 1) {\n      const opi = op[i];\n      if (opi.type === id.RNM) {\n        rdi.refersTo[opi.index] = true;\n        if (!isScanned[opi.index]) {\n          scan(ruleCount, ruleDeps, opi.index, isScanned);\n        }\n        for (j = 0; j < ruleCount; j += 1) {\n          if (ruleDeps[opi.index].refersTo[j]) {\n            rdi.refersTo[j] = true;\n          }\n        }\n      } else if (opi.type === id.UDT) {\n        rdi.refersToUdt[opi.index] = true;\n      } else if (opi.type === id.BKR) {\n        if (opi.index < ruleCount) {\n          rdi.refersTo[opi.index] = true;\n          if (!isScanned[opi.index]) {\n            scan(ruleCount, ruleDeps, opi.index, isScanned);\n          }\n        } else {\n          rdi.refersToUdt[ruleCount - opi.index] = true;\n        }\n      }\n    }\n  };\n  // Determine the rule dependencies, types and mutually recursive groups.\n  const ruleDependencies = (stateArg) => {\n    state = stateArg; /* make it global */\n    let i = 0;\n    let j = 0;\n    let groupCount = 0;\n    let rdi = null;\n    let rdj = null;\n    let newGroup = false;\n    state.dependenciesComplete = false;\n\n    /* make a working array of rule scanned markers */\n    const isScanned = state.falseArray(state.ruleCount);\n\n    /* discover the rule dependencies */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.falsifyArray(isScanned);\n      scan(state.ruleCount, state.ruleDeps, i, isScanned);\n    }\n    /* discover all rules referencing each rule */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (i !== j) {\n          if (state.ruleDeps[j].refersTo[i]) {\n            state.ruleDeps[i].referencedBy[j] = true;\n          }\n        }\n      }\n    }\n    /* find the non-recursive and recursive types */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.ruleDeps[i].recursiveType = id.ATTR_N;\n      if (state.ruleDeps[i].refersTo[i]) {\n        state.ruleDeps[i].recursiveType = id.ATTR_R;\n      }\n    }\n\n    /* find the mutually-recursive groups, if any */\n    groupCount = -1;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[i];\n      if (rdi.recursiveType === id.ATTR_R) {\n        newGroup = true;\n        for (j = 0; j < state.ruleCount; j += 1) {\n          if (i !== j) {\n            rdj = state.ruleDeps[j];\n            if (rdj.recursiveType === id.ATTR_R) {\n              if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                if (newGroup) {\n                  groupCount += 1;\n                  rdi.recursiveType = id.ATTR_MR;\n                  rdi.groupNumber = groupCount;\n                  newGroup = false;\n                }\n                rdj.recursiveType = id.ATTR_MR;\n                rdj.groupNumber = groupCount;\n              }\n            }\n          }\n        }\n      }\n    }\n    state.isMutuallyRecursive = groupCount > -1;\n\n    /* sort the rules/UDTS */\n    state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesType);\n    if (state.isMutuallyRecursive) {\n      state.ruleTypeIndexes.sort(state.compRulesGroup);\n    }\n    if (state.udtCount) {\n      state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n    }\n\n    state.dependenciesComplete = true;\n  };\n  const show = (type = null) => {\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    let startSeg = 0;\n    const maxRule = state.ruleCount - 1;\n    const maxUdt = state.udtCount - 1;\n    const lineLength = 100;\n    let str = '';\n    let pre = '';\n    const toArrow = '=> ';\n    const byArrow = '<= ';\n    let first = false;\n    let rdi = null;\n    let { ruleIndexes } = state;\n    let { udtIndexes } = state;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    }\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[ruleIndexes[i]];\n      pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n      if (state.isMutuallyRecursive) {\n        pre += rdi.groupNumber > -1 ? rdi.groupNumber : '-';\n        pre += ':';\n      }\n      pre += ' ';\n      str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.refersTo[ruleIndexes[j]]) {\n          if (first) {\n            str += toArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (state.udtCount) {\n        for (j = 0; j < state.udtCount; j += 1) {\n          if (rdi.refersToUdt[udtIndexes[j]]) {\n            if (first) {\n              str += toArrow;\n              first = false;\n              str += state.udts[udtIndexes[j]].name;\n            } else {\n              str += `, ${state.udts[udtIndexes[j]].name}`;\n            }\n            count += 1;\n          }\n          if (str.length - startSeg > lineLength && j !== maxUdt) {\n            str += `\\n${pre}${toArrow}`;\n            startSeg = str.length;\n          }\n        }\n      }\n      if (count === 0) {\n        str += '=> <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.referencedBy[ruleIndexes[j]]) {\n          if (first) {\n            str += byArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (count === 0) {\n        str += '<= <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      str += '\\n';\n    }\n    return str;\n  };\n  // Display the rule dependencies.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showRuleDependencies = (order = 'index') => {\n    let str = 'RULE DEPENDENCIES(index:type:[group number:])\\n';\n    str += '=> refers to rule names\\n';\n    str += '<= referenced by rule names\\n';\n    if (!state.dependenciesComplete) {\n      return str;\n    }\n\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += show(null);\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleDependencies, showRuleDependencies };\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3J1bGUtZGVwZW5kZW5jaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHNGQUF3QjtBQUM3QyxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsZUFBZSxlQUFlLEdBQUcsc0NBQXNDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJLEVBQUUsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSSxFQUFFLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvcnVsZS1kZXBlbmRlbmNpZXMuanM/MjcyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBEZXRlcm1pbmUgcnVsZSBkZXBlbmRlbmNpZXMgYW5kIHR5cGVzLlxuLy8gRm9yIGVhY2ggcnVsZSwgZGV0ZXJtaW5lIHdoaWNoIG90aGVyIHJ1bGVzIGl0IHJlZmVycyB0b1xuLy8gYW5kIHdoaWNoIG9mIHRoZSBvdGhlciBydWxlcyByZWZlciBiYWNrIHRvIGl0LlxuLy9cbi8vIFJ1bGUgdHlwZXMgYXJlOlxuLy8gIC0gbm9uLXJlY3Vyc2l2ZSAtIHRoZSBydWxlIG5ldmVyIHJlZmVycyB0byBpdHNlbGYsIGV2ZW4gaW5kaXJlY3RseVxuLy8gIC0gcmVjdXJzaXZlIC0gdGhlIHJ1bGUgcmVmZXJzIHRvIGl0c2VsZiwgcG9zc2libHkgaW5kaXJlY3RseVxuLy8gIC0gbXV0dWFsbHktcmVjdXJzaXZlIC0gYmVsb25ncyB0byBhIGdyb3VwIG9mIHR3byBvciBtb3JlIHJ1bGVzLCBlYWNoIG9mIHdoaWNoIHJlZmVycyB0byBldmVyeSBvdGhlciBydWxlIGluIHRoZSBncm91cCwgaW5jbHVkaW5nIGl0c2VsZi5cbm1vZHVsZS5leHBvcnRzID0gKCgpID0+IHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuLi9hcGctbGliL2lkZW50aWZpZXJzJyk7XG4gIGxldCBzdGF0ZSA9IG51bGw7IC8qIGtlZXAgYSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBzdGF0ZSBmb3IgdGhlIHNob3cgZnVuY3Rpb25zICovXG5cbiAgLyogc2NhbiB0aGUgb3Bjb2RlcyBvZiB0aGUgaW5kZXhlZCBydWxlIGFuZCBkaXNjb3ZlciB3aGljaCBydWxlcyBpdCByZWZlcmVuY2VzIGFuZCB3aGljaCBydWxlIHJlZmVyIGJhY2sgdG8gaXQgKi9cbiAgY29uc3Qgc2NhbiA9IChydWxlQ291bnQsIHJ1bGVEZXBzLCBpbmRleCwgaXNTY2FubmVkKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBjb25zdCByZGkgPSBydWxlRGVwc1tpbmRleF07XG4gICAgaXNTY2FubmVkW2luZGV4XSA9IHRydWU7XG4gICAgY29uc3Qgb3AgPSByZGkucnVsZS5vcGNvZGVzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgb3BpID0gb3BbaV07XG4gICAgICBpZiAob3BpLnR5cGUgPT09IGlkLlJOTSkge1xuICAgICAgICByZGkucmVmZXJzVG9bb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICAgIGlmICghaXNTY2FubmVkW29waS5pbmRleF0pIHtcbiAgICAgICAgICBzY2FuKHJ1bGVDb3VudCwgcnVsZURlcHMsIG9waS5pbmRleCwgaXNTY2FubmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgcnVsZUNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAocnVsZURlcHNbb3BpLmluZGV4XS5yZWZlcnNUb1tqXSkge1xuICAgICAgICAgICAgcmRpLnJlZmVyc1RvW2pdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3BpLnR5cGUgPT09IGlkLlVEVCkge1xuICAgICAgICByZGkucmVmZXJzVG9VZHRbb3BpLmluZGV4XSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG9waS50eXBlID09PSBpZC5CS1IpIHtcbiAgICAgICAgaWYgKG9waS5pbmRleCA8IHJ1bGVDb3VudCkge1xuICAgICAgICAgIHJkaS5yZWZlcnNUb1tvcGkuaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIWlzU2Nhbm5lZFtvcGkuaW5kZXhdKSB7XG4gICAgICAgICAgICBzY2FuKHJ1bGVDb3VudCwgcnVsZURlcHMsIG9waS5pbmRleCwgaXNTY2FubmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmRpLnJlZmVyc1RvVWR0W3J1bGVDb3VudCAtIG9waS5pbmRleF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBEZXRlcm1pbmUgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzLCB0eXBlcyBhbmQgbXV0dWFsbHkgcmVjdXJzaXZlIGdyb3Vwcy5cbiAgY29uc3QgcnVsZURlcGVuZGVuY2llcyA9IChzdGF0ZUFyZykgPT4ge1xuICAgIHN0YXRlID0gc3RhdGVBcmc7IC8qIG1ha2UgaXQgZ2xvYmFsICovXG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgZ3JvdXBDb3VudCA9IDA7XG4gICAgbGV0IHJkaSA9IG51bGw7XG4gICAgbGV0IHJkaiA9IG51bGw7XG4gICAgbGV0IG5ld0dyb3VwID0gZmFsc2U7XG4gICAgc3RhdGUuZGVwZW5kZW5jaWVzQ29tcGxldGUgPSBmYWxzZTtcblxuICAgIC8qIG1ha2UgYSB3b3JraW5nIGFycmF5IG9mIHJ1bGUgc2Nhbm5lZCBtYXJrZXJzICovXG4gICAgY29uc3QgaXNTY2FubmVkID0gc3RhdGUuZmFsc2VBcnJheShzdGF0ZS5ydWxlQ291bnQpO1xuXG4gICAgLyogZGlzY292ZXIgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzICovXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBzdGF0ZS5mYWxzaWZ5QXJyYXkoaXNTY2FubmVkKTtcbiAgICAgIHNjYW4oc3RhdGUucnVsZUNvdW50LCBzdGF0ZS5ydWxlRGVwcywgaSwgaXNTY2FubmVkKTtcbiAgICB9XG4gICAgLyogZGlzY292ZXIgYWxsIHJ1bGVzIHJlZmVyZW5jaW5nIGVhY2ggcnVsZSAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGF0ZS5ydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJ1bGVEZXBzW2pdLnJlZmVyc1RvW2ldKSB7XG4gICAgICAgICAgICBzdGF0ZS5ydWxlRGVwc1tpXS5yZWZlcmVuY2VkQnlbal0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBmaW5kIHRoZSBub24tcmVjdXJzaXZlIGFuZCByZWN1cnNpdmUgdHlwZXMgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhdGUucnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgIHN0YXRlLnJ1bGVEZXBzW2ldLnJlY3Vyc2l2ZVR5cGUgPSBpZC5BVFRSX047XG4gICAgICBpZiAoc3RhdGUucnVsZURlcHNbaV0ucmVmZXJzVG9baV0pIHtcbiAgICAgICAgc3RhdGUucnVsZURlcHNbaV0ucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBmaW5kIHRoZSBtdXR1YWxseS1yZWN1cnNpdmUgZ3JvdXBzLCBpZiBhbnkgKi9cbiAgICBncm91cENvdW50ID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICByZGkgPSBzdGF0ZS5ydWxlRGVwc1tpXTtcbiAgICAgIGlmIChyZGkucmVjdXJzaXZlVHlwZSA9PT0gaWQuQVRUUl9SKSB7XG4gICAgICAgIG5ld0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0YXRlLnJ1bGVDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHJkaiA9IHN0YXRlLnJ1bGVEZXBzW2pdO1xuICAgICAgICAgICAgaWYgKHJkai5yZWN1cnNpdmVUeXBlID09PSBpZC5BVFRSX1IpIHtcbiAgICAgICAgICAgICAgaWYgKHJkaS5yZWZlcnNUb1tqXSAmJiByZGoucmVmZXJzVG9baV0pIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3R3JvdXApIHtcbiAgICAgICAgICAgICAgICAgIGdyb3VwQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgIHJkaS5yZWN1cnNpdmVUeXBlID0gaWQuQVRUUl9NUjtcbiAgICAgICAgICAgICAgICAgIHJkaS5ncm91cE51bWJlciA9IGdyb3VwQ291bnQ7XG4gICAgICAgICAgICAgICAgICBuZXdHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZGoucmVjdXJzaXZlVHlwZSA9IGlkLkFUVFJfTVI7XG4gICAgICAgICAgICAgICAgcmRqLmdyb3VwTnVtYmVyID0gZ3JvdXBDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5pc011dHVhbGx5UmVjdXJzaXZlID0gZ3JvdXBDb3VudCA+IC0xO1xuXG4gICAgLyogc29ydCB0aGUgcnVsZXMvVURUUyAqL1xuICAgIHN0YXRlLnJ1bGVBbHBoYUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNBbHBoYSk7XG4gICAgc3RhdGUucnVsZVR5cGVJbmRleGVzLnNvcnQoc3RhdGUuY29tcFJ1bGVzQWxwaGEpO1xuICAgIHN0YXRlLnJ1bGVUeXBlSW5kZXhlcy5zb3J0KHN0YXRlLmNvbXBSdWxlc1R5cGUpO1xuICAgIGlmIChzdGF0ZS5pc011dHVhbGx5UmVjdXJzaXZlKSB7XG4gICAgICBzdGF0ZS5ydWxlVHlwZUluZGV4ZXMuc29ydChzdGF0ZS5jb21wUnVsZXNHcm91cCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS51ZHRDb3VudCkge1xuICAgICAgc3RhdGUudWR0QWxwaGFJbmRleGVzLnNvcnQoc3RhdGUuY29tcFVkdHNBbHBoYSk7XG4gICAgfVxuXG4gICAgc3RhdGUuZGVwZW5kZW5jaWVzQ29tcGxldGUgPSB0cnVlO1xuICB9O1xuICBjb25zdCBzaG93ID0gKHR5cGUgPSBudWxsKSA9PiB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBqID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBzdGFydFNlZyA9IDA7XG4gICAgY29uc3QgbWF4UnVsZSA9IHN0YXRlLnJ1bGVDb3VudCAtIDE7XG4gICAgY29uc3QgbWF4VWR0ID0gc3RhdGUudWR0Q291bnQgLSAxO1xuICAgIGNvbnN0IGxpbmVMZW5ndGggPSAxMDA7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBwcmUgPSAnJztcbiAgICBjb25zdCB0b0Fycm93ID0gJz0+ICc7XG4gICAgY29uc3QgYnlBcnJvdyA9ICc8PSAnO1xuICAgIGxldCBmaXJzdCA9IGZhbHNlO1xuICAgIGxldCByZGkgPSBudWxsO1xuICAgIGxldCB7IHJ1bGVJbmRleGVzIH0gPSBzdGF0ZTtcbiAgICBsZXQgeyB1ZHRJbmRleGVzIH0gPSBzdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gOTcpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZUFscGhhSW5kZXhlcztcbiAgICAgIHVkdEluZGV4ZXMgPSBzdGF0ZS51ZHRBbHBoYUluZGV4ZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxMTYpIHtcbiAgICAgIHJ1bGVJbmRleGVzID0gc3RhdGUucnVsZVR5cGVJbmRleGVzO1xuICAgICAgdWR0SW5kZXhlcyA9IHN0YXRlLnVkdEFscGhhSW5kZXhlcztcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXRlLnJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICByZGkgPSBzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tpXV07XG4gICAgICBwcmUgPSBgJHtydWxlSW5kZXhlc1tpXX06JHtzdGF0ZS50eXBlVG9TdHJpbmcocmRpLnJlY3Vyc2l2ZVR5cGUpfTpgO1xuICAgICAgaWYgKHN0YXRlLmlzTXV0dWFsbHlSZWN1cnNpdmUpIHtcbiAgICAgICAgcHJlICs9IHJkaS5ncm91cE51bWJlciA+IC0xID8gcmRpLmdyb3VwTnVtYmVyIDogJy0nO1xuICAgICAgICBwcmUgKz0gJzonO1xuICAgICAgfVxuICAgICAgcHJlICs9ICcgJztcbiAgICAgIHN0ciArPSBgJHtwcmUgKyBzdGF0ZS5ydWxlc1tydWxlSW5kZXhlc1tpXV0ubmFtZX1cXG5gO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgY291bnQgPSAwO1xuICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgc3RyICs9IHByZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBpZiAocmRpLnJlZmVyc1RvW3J1bGVJbmRleGVzW2pdXSkge1xuICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgc3RyICs9IHRvQXJyb3c7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyICs9IHN0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBgLCAke3N0YXRlLnJ1bGVEZXBzW3J1bGVJbmRleGVzW2pdXS5ydWxlLm5hbWV9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAtIHN0YXJ0U2VnID4gbGluZUxlbmd0aCAmJiBqICE9PSBtYXhSdWxlKSB7XG4gICAgICAgICAgc3RyICs9IGBcXG4ke3ByZX0ke3RvQXJyb3d9YDtcbiAgICAgICAgICBzdGFydFNlZyA9IHN0ci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS51ZHRDb3VudCkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RhdGUudWR0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgIGlmIChyZGkucmVmZXJzVG9VZHRbdWR0SW5kZXhlc1tqXV0pIHtcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICBzdHIgKz0gdG9BcnJvdztcbiAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc3RyICs9IHN0YXRlLnVkdHNbdWR0SW5kZXhlc1tqXV0ubmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBgLCAke3N0YXRlLnVkdHNbdWR0SW5kZXhlc1tqXV0ubmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5sZW5ndGggLSBzdGFydFNlZyA+IGxpbmVMZW5ndGggJiYgaiAhPT0gbWF4VWR0KSB7XG4gICAgICAgICAgICBzdHIgKz0gYFxcbiR7cHJlfSR7dG9BcnJvd31gO1xuICAgICAgICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHN0ciArPSAnPT4gPG5vbmU+XFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChmaXJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgY291bnQgPSAwO1xuICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgc3RyICs9IHByZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBzdGF0ZS5ydWxlQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBpZiAocmRpLnJlZmVyZW5jZWRCeVtydWxlSW5kZXhlc1tqXV0pIHtcbiAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgIHN0ciArPSBieUFycm93O1xuICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0ciArPSBzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tqXV0ucnVsZS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gYCwgJHtzdGF0ZS5ydWxlRGVwc1tydWxlSW5kZXhlc1tqXV0ucnVsZS5uYW1lfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5sZW5ndGggLSBzdGFydFNlZyA+IGxpbmVMZW5ndGggJiYgaiAhPT0gbWF4UnVsZSkge1xuICAgICAgICAgIHN0ciArPSBgXFxuJHtwcmV9JHt0b0Fycm93fWA7XG4gICAgICAgICAgc3RhcnRTZWcgPSBzdHIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgc3RyICs9ICc8PSA8bm9uZT5cXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0ID09PSBmYWxzZSkge1xuICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gJ1xcbic7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIC8vIERpc3BsYXkgdGhlIHJ1bGUgZGVwZW5kZW5jaWVzLlxuICAvLyAtIG9yZGVyXG4gIC8vICAgICAgLSBcImluZGV4XCIgb3IgXCJpXCIsIGluZGV4IG9yZGVyIChkZWZhdWx0KVxuICAvLyAgICAgIC0gXCJhbHBoYVwiIG9yIFwiYVwiLCBhbHBoYWJldGljYWwgb3JkZXJcbiAgLy8gICAgICAtIFwidHlwZVwiIG9yIFwidFwiLCBvcmRlcmVkIGJ5IHR5cGUgKGFscGhhYmV0aWNhbCB3aXRoaW4gZWFjaCB0eXBlL2dyb3VwKVxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIGNvbnN0IHNob3dSdWxlRGVwZW5kZW5jaWVzID0gKG9yZGVyID0gJ2luZGV4JykgPT4ge1xuICAgIGxldCBzdHIgPSAnUlVMRSBERVBFTkRFTkNJRVMoaW5kZXg6dHlwZTpbZ3JvdXAgbnVtYmVyOl0pXFxuJztcbiAgICBzdHIgKz0gJz0+IHJlZmVycyB0byBydWxlIG5hbWVzXFxuJztcbiAgICBzdHIgKz0gJzw9IHJlZmVyZW5jZWQgYnkgcnVsZSBuYW1lc1xcbic7XG4gICAgaWYgKCFzdGF0ZS5kZXBlbmRlbmNpZXNDb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBpZiAob3JkZXIuY2hhckNvZGVBdCgwKSA9PT0gOTcpIHtcbiAgICAgIHN0ciArPSAnYWxwaGFiZXRpY2FsIGJ5IHJ1bGUgbmFtZVxcbic7XG4gICAgICBzdHIgKz0gc2hvdyg5Nyk7XG4gICAgfSBlbHNlIGlmIChvcmRlci5jaGFyQ29kZUF0KDApID09PSAxMTYpIHtcbiAgICAgIHN0ciArPSAnb3JkZXJlZCBieSBydWxlIHR5cGVcXG4nO1xuICAgICAgc3RyICs9IHNob3coMTE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICdvcmRlcmVkIGJ5IHJ1bGUgaW5kZXhcXG4nO1xuICAgICAgc3RyICs9IHNob3cobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyogRGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50IC0gc2VlIE1ETiBXZWIgRG9jcyAqL1xuICByZXR1cm4geyBydWxlRGVwZW5kZW5jaWVzLCBzaG93UnVsZURlcGVuZGVuY2llcyB9O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/rule-dependencies.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/sabnf-grammar.js":
/*!**********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/sabnf-grammar.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 95\n  //       udts = 0\n  //    opcodes = 372\n  //        ---   ABNF original opcodes\n  //        ALT = 43\n  //        CAT = 48\n  //        REP = 34\n  //        RNM = 149\n  //        TLS = 2\n  //        TBS = 61\n  //        TRG = 35\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [9 - 126]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = { name: 'File', lower: 'file', index: 0, isBkr: false };\n  this.rules[1] = { name: 'BlankLine', lower: 'blankline', index: 1, isBkr: false };\n  this.rules[2] = { name: 'Rule', lower: 'rule', index: 2, isBkr: false };\n  this.rules[3] = { name: 'RuleLookup', lower: 'rulelookup', index: 3, isBkr: false };\n  this.rules[4] = { name: 'RuleNameTest', lower: 'rulenametest', index: 4, isBkr: false };\n  this.rules[5] = { name: 'RuleName', lower: 'rulename', index: 5, isBkr: false };\n  this.rules[6] = { name: 'RuleNameError', lower: 'rulenameerror', index: 6, isBkr: false };\n  this.rules[7] = { name: 'DefinedAsTest', lower: 'definedastest', index: 7, isBkr: false };\n  this.rules[8] = { name: 'DefinedAsError', lower: 'definedaserror', index: 8, isBkr: false };\n  this.rules[9] = { name: 'DefinedAs', lower: 'definedas', index: 9, isBkr: false };\n  this.rules[10] = { name: 'Defined', lower: 'defined', index: 10, isBkr: false };\n  this.rules[11] = { name: 'IncAlt', lower: 'incalt', index: 11, isBkr: false };\n  this.rules[12] = { name: 'RuleError', lower: 'ruleerror', index: 12, isBkr: false };\n  this.rules[13] = { name: 'LineEndError', lower: 'lineenderror', index: 13, isBkr: false };\n  this.rules[14] = { name: 'Alternation', lower: 'alternation', index: 14, isBkr: false };\n  this.rules[15] = { name: 'Concatenation', lower: 'concatenation', index: 15, isBkr: false };\n  this.rules[16] = { name: 'Repetition', lower: 'repetition', index: 16, isBkr: false };\n  this.rules[17] = { name: 'Modifier', lower: 'modifier', index: 17, isBkr: false };\n  this.rules[18] = { name: 'Predicate', lower: 'predicate', index: 18, isBkr: false };\n  this.rules[19] = { name: 'BasicElement', lower: 'basicelement', index: 19, isBkr: false };\n  this.rules[20] = { name: 'BasicElementErr', lower: 'basicelementerr', index: 20, isBkr: false };\n  this.rules[21] = { name: 'Group', lower: 'group', index: 21, isBkr: false };\n  this.rules[22] = { name: 'GroupError', lower: 'grouperror', index: 22, isBkr: false };\n  this.rules[23] = { name: 'GroupOpen', lower: 'groupopen', index: 23, isBkr: false };\n  this.rules[24] = { name: 'GroupClose', lower: 'groupclose', index: 24, isBkr: false };\n  this.rules[25] = { name: 'Option', lower: 'option', index: 25, isBkr: false };\n  this.rules[26] = { name: 'OptionError', lower: 'optionerror', index: 26, isBkr: false };\n  this.rules[27] = { name: 'OptionOpen', lower: 'optionopen', index: 27, isBkr: false };\n  this.rules[28] = { name: 'OptionClose', lower: 'optionclose', index: 28, isBkr: false };\n  this.rules[29] = { name: 'RnmOp', lower: 'rnmop', index: 29, isBkr: false };\n  this.rules[30] = { name: 'BkrOp', lower: 'bkrop', index: 30, isBkr: false };\n  this.rules[31] = { name: 'bkrModifier', lower: 'bkrmodifier', index: 31, isBkr: false };\n  this.rules[32] = { name: 'cs', lower: 'cs', index: 32, isBkr: false };\n  this.rules[33] = { name: 'ci', lower: 'ci', index: 33, isBkr: false };\n  this.rules[34] = { name: 'um', lower: 'um', index: 34, isBkr: false };\n  this.rules[35] = { name: 'pm', lower: 'pm', index: 35, isBkr: false };\n  this.rules[36] = { name: 'bkr-name', lower: 'bkr-name', index: 36, isBkr: false };\n  this.rules[37] = { name: 'rname', lower: 'rname', index: 37, isBkr: false };\n  this.rules[38] = { name: 'uname', lower: 'uname', index: 38, isBkr: false };\n  this.rules[39] = { name: 'ename', lower: 'ename', index: 39, isBkr: false };\n  this.rules[40] = { name: 'UdtOp', lower: 'udtop', index: 40, isBkr: false };\n  this.rules[41] = { name: 'udt-non-empty', lower: 'udt-non-empty', index: 41, isBkr: false };\n  this.rules[42] = { name: 'udt-empty', lower: 'udt-empty', index: 42, isBkr: false };\n  this.rules[43] = { name: 'RepOp', lower: 'repop', index: 43, isBkr: false };\n  this.rules[44] = { name: 'AltOp', lower: 'altop', index: 44, isBkr: false };\n  this.rules[45] = { name: 'CatOp', lower: 'catop', index: 45, isBkr: false };\n  this.rules[46] = { name: 'StarOp', lower: 'starop', index: 46, isBkr: false };\n  this.rules[47] = { name: 'AndOp', lower: 'andop', index: 47, isBkr: false };\n  this.rules[48] = { name: 'NotOp', lower: 'notop', index: 48, isBkr: false };\n  this.rules[49] = { name: 'BkaOp', lower: 'bkaop', index: 49, isBkr: false };\n  this.rules[50] = { name: 'BknOp', lower: 'bknop', index: 50, isBkr: false };\n  this.rules[51] = { name: 'AbgOp', lower: 'abgop', index: 51, isBkr: false };\n  this.rules[52] = { name: 'AenOp', lower: 'aenop', index: 52, isBkr: false };\n  this.rules[53] = { name: 'TrgOp', lower: 'trgop', index: 53, isBkr: false };\n  this.rules[54] = { name: 'TbsOp', lower: 'tbsop', index: 54, isBkr: false };\n  this.rules[55] = { name: 'TlsOp', lower: 'tlsop', index: 55, isBkr: false };\n  this.rules[56] = { name: 'TlsCase', lower: 'tlscase', index: 56, isBkr: false };\n  this.rules[57] = { name: 'TlsOpen', lower: 'tlsopen', index: 57, isBkr: false };\n  this.rules[58] = { name: 'TlsClose', lower: 'tlsclose', index: 58, isBkr: false };\n  this.rules[59] = { name: 'TlsString', lower: 'tlsstring', index: 59, isBkr: false };\n  this.rules[60] = { name: 'StringTab', lower: 'stringtab', index: 60, isBkr: false };\n  this.rules[61] = { name: 'ClsOp', lower: 'clsop', index: 61, isBkr: false };\n  this.rules[62] = { name: 'ClsOpen', lower: 'clsopen', index: 62, isBkr: false };\n  this.rules[63] = { name: 'ClsClose', lower: 'clsclose', index: 63, isBkr: false };\n  this.rules[64] = { name: 'ClsString', lower: 'clsstring', index: 64, isBkr: false };\n  this.rules[65] = { name: 'ProsVal', lower: 'prosval', index: 65, isBkr: false };\n  this.rules[66] = { name: 'ProsValOpen', lower: 'prosvalopen', index: 66, isBkr: false };\n  this.rules[67] = { name: 'ProsValString', lower: 'prosvalstring', index: 67, isBkr: false };\n  this.rules[68] = { name: 'ProsValClose', lower: 'prosvalclose', index: 68, isBkr: false };\n  this.rules[69] = { name: 'rep-min', lower: 'rep-min', index: 69, isBkr: false };\n  this.rules[70] = { name: 'rep-min-max', lower: 'rep-min-max', index: 70, isBkr: false };\n  this.rules[71] = { name: 'rep-max', lower: 'rep-max', index: 71, isBkr: false };\n  this.rules[72] = { name: 'rep-num', lower: 'rep-num', index: 72, isBkr: false };\n  this.rules[73] = { name: 'dString', lower: 'dstring', index: 73, isBkr: false };\n  this.rules[74] = { name: 'xString', lower: 'xstring', index: 74, isBkr: false };\n  this.rules[75] = { name: 'bString', lower: 'bstring', index: 75, isBkr: false };\n  this.rules[76] = { name: 'Dec', lower: 'dec', index: 76, isBkr: false };\n  this.rules[77] = { name: 'Hex', lower: 'hex', index: 77, isBkr: false };\n  this.rules[78] = { name: 'Bin', lower: 'bin', index: 78, isBkr: false };\n  this.rules[79] = { name: 'dmin', lower: 'dmin', index: 79, isBkr: false };\n  this.rules[80] = { name: 'dmax', lower: 'dmax', index: 80, isBkr: false };\n  this.rules[81] = { name: 'bmin', lower: 'bmin', index: 81, isBkr: false };\n  this.rules[82] = { name: 'bmax', lower: 'bmax', index: 82, isBkr: false };\n  this.rules[83] = { name: 'xmin', lower: 'xmin', index: 83, isBkr: false };\n  this.rules[84] = { name: 'xmax', lower: 'xmax', index: 84, isBkr: false };\n  this.rules[85] = { name: 'dnum', lower: 'dnum', index: 85, isBkr: false };\n  this.rules[86] = { name: 'bnum', lower: 'bnum', index: 86, isBkr: false };\n  this.rules[87] = { name: 'xnum', lower: 'xnum', index: 87, isBkr: false };\n  this.rules[88] = { name: 'alphanum', lower: 'alphanum', index: 88, isBkr: false };\n  this.rules[89] = { name: 'owsp', lower: 'owsp', index: 89, isBkr: false };\n  this.rules[90] = { name: 'wsp', lower: 'wsp', index: 90, isBkr: false };\n  this.rules[91] = { name: 'space', lower: 'space', index: 91, isBkr: false };\n  this.rules[92] = { name: 'comment', lower: 'comment', index: 92, isBkr: false };\n  this.rules[93] = { name: 'LineEnd', lower: 'lineend', index: 93, isBkr: false };\n  this.rules[94] = { name: 'LineContinue', lower: 'linecontinue', index: 94, isBkr: false };\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* File */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[0].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[0].opcodes[2] = { type: 4, index: 1 };// RNM(BlankLine)\n  this.rules[0].opcodes[3] = { type: 4, index: 2 };// RNM(Rule)\n  this.rules[0].opcodes[4] = { type: 4, index: 12 };// RNM(RuleError)\n\n  /* BlankLine */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = { type: 2, children: [1,5,7] };// CAT\n  this.rules[1].opcodes[1] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[1].opcodes[2] = { type: 1, children: [3,4] };// ALT\n  this.rules[1].opcodes[3] = { type: 6, string: [32] };// TBS\n  this.rules[1].opcodes[4] = { type: 6, string: [9] };// TBS\n  this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[1].opcodes[6] = { type: 4, index: 92 };// RNM(comment)\n  this.rules[1].opcodes[7] = { type: 4, index: 93 };// RNM(LineEnd)\n\n  /* Rule */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = { type: 2, children: [1,2,3,4] };// CAT\n  this.rules[2].opcodes[1] = { type: 4, index: 3 };// RNM(RuleLookup)\n  this.rules[2].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[2].opcodes[3] = { type: 4, index: 14 };// RNM(Alternation)\n  this.rules[2].opcodes[4] = { type: 1, children: [5,8] };// ALT\n  this.rules[2].opcodes[5] = { type: 2, children: [6,7] };// CAT\n  this.rules[2].opcodes[6] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[2].opcodes[7] = { type: 4, index: 93 };// RNM(LineEnd)\n  this.rules[2].opcodes[8] = { type: 2, children: [9,10] };// CAT\n  this.rules[2].opcodes[9] = { type: 4, index: 13 };// RNM(LineEndError)\n  this.rules[2].opcodes[10] = { type: 4, index: 93 };// RNM(LineEnd)\n\n  /* RuleLookup */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[3].opcodes[1] = { type: 4, index: 4 };// RNM(RuleNameTest)\n  this.rules[3].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[3].opcodes[3] = { type: 4, index: 7 };// RNM(DefinedAsTest)\n\n  /* RuleNameTest */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[4].opcodes[1] = { type: 4, index: 5 };// RNM(RuleName)\n  this.rules[4].opcodes[2] = { type: 4, index: 6 };// RNM(RuleNameError)\n\n  /* RuleName */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* RuleNameError */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[6].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 };// TRG\n  this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 };// TRG\n\n  /* DefinedAsTest */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[7].opcodes[1] = { type: 4, index: 9 };// RNM(DefinedAs)\n  this.rules[7].opcodes[2] = { type: 4, index: 8 };// RNM(DefinedAsError)\n\n  /* DefinedAsError */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 };// REP\n  this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 };// TRG\n\n  /* DefinedAs */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[9].opcodes[1] = { type: 4, index: 11 };// RNM(IncAlt)\n  this.rules[9].opcodes[2] = { type: 4, index: 10 };// RNM(Defined)\n\n  /* Defined */\n  this.rules[10].opcodes = [];\n  this.rules[10].opcodes[0] = { type: 6, string: [61] };// TBS\n\n  /* IncAlt */\n  this.rules[11].opcodes = [];\n  this.rules[11].opcodes[0] = { type: 6, string: [61,47] };// TBS\n\n  /* RuleError */\n  this.rules[12].opcodes = [];\n  this.rules[12].opcodes[0] = { type: 2, children: [1,6] };// CAT\n  this.rules[12].opcodes[1] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[12].opcodes[2] = { type: 1, children: [3,4,5] };// ALT\n  this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[12].opcodes[4] = { type: 6, string: [9] };// TBS\n  this.rules[12].opcodes[5] = { type: 4, index: 94 };// RNM(LineContinue)\n  this.rules[12].opcodes[6] = { type: 4, index: 93 };// RNM(LineEnd)\n\n  /* LineEndError */\n  this.rules[13].opcodes = [];\n  this.rules[13].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[13].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[13].opcodes[3] = { type: 6, string: [9] };// TBS\n  this.rules[13].opcodes[4] = { type: 4, index: 94 };// RNM(LineContinue)\n\n  /* Alternation */\n  this.rules[14].opcodes = [];\n  this.rules[14].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[14].opcodes[1] = { type: 4, index: 15 };// RNM(Concatenation)\n  this.rules[14].opcodes[2] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[14].opcodes[3] = { type: 2, children: [4,5,6] };// CAT\n  this.rules[14].opcodes[4] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[14].opcodes[5] = { type: 4, index: 44 };// RNM(AltOp)\n  this.rules[14].opcodes[6] = { type: 4, index: 15 };// RNM(Concatenation)\n\n  /* Concatenation */\n  this.rules[15].opcodes = [];\n  this.rules[15].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[15].opcodes[1] = { type: 4, index: 16 };// RNM(Repetition)\n  this.rules[15].opcodes[2] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[15].opcodes[3] = { type: 2, children: [4,5] };// CAT\n  this.rules[15].opcodes[4] = { type: 4, index: 45 };// RNM(CatOp)\n  this.rules[15].opcodes[5] = { type: 4, index: 16 };// RNM(Repetition)\n\n  /* Repetition */\n  this.rules[16].opcodes = [];\n  this.rules[16].opcodes[0] = { type: 2, children: [1,3] };// CAT\n  this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[16].opcodes[2] = { type: 4, index: 17 };// RNM(Modifier)\n  this.rules[16].opcodes[3] = { type: 1, children: [4,5,6,7] };// ALT\n  this.rules[16].opcodes[4] = { type: 4, index: 21 };// RNM(Group)\n  this.rules[16].opcodes[5] = { type: 4, index: 25 };// RNM(Option)\n  this.rules[16].opcodes[6] = { type: 4, index: 19 };// RNM(BasicElement)\n  this.rules[16].opcodes[7] = { type: 4, index: 20 };// RNM(BasicElementErr)\n\n  /* Modifier */\n  this.rules[17].opcodes = [];\n  this.rules[17].opcodes[0] = { type: 1, children: [1,5] };// ALT\n  this.rules[17].opcodes[1] = { type: 2, children: [2,3] };// CAT\n  this.rules[17].opcodes[2] = { type: 4, index: 18 };// RNM(Predicate)\n  this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[17].opcodes[4] = { type: 4, index: 43 };// RNM(RepOp)\n  this.rules[17].opcodes[5] = { type: 4, index: 43 };// RNM(RepOp)\n\n  /* Predicate */\n  this.rules[18].opcodes = [];\n  this.rules[18].opcodes[0] = { type: 1, children: [1,2,3,4] };// ALT\n  this.rules[18].opcodes[1] = { type: 4, index: 49 };// RNM(BkaOp)\n  this.rules[18].opcodes[2] = { type: 4, index: 50 };// RNM(BknOp)\n  this.rules[18].opcodes[3] = { type: 4, index: 47 };// RNM(AndOp)\n  this.rules[18].opcodes[4] = { type: 4, index: 48 };// RNM(NotOp)\n\n  /* BasicElement */\n  this.rules[19].opcodes = [];\n  this.rules[19].opcodes[0] = { type: 1, children: [1,2,3,4,5,6,7,8,9,10] };// ALT\n  this.rules[19].opcodes[1] = { type: 4, index: 40 };// RNM(UdtOp)\n  this.rules[19].opcodes[2] = { type: 4, index: 29 };// RNM(RnmOp)\n  this.rules[19].opcodes[3] = { type: 4, index: 53 };// RNM(TrgOp)\n  this.rules[19].opcodes[4] = { type: 4, index: 54 };// RNM(TbsOp)\n  this.rules[19].opcodes[5] = { type: 4, index: 55 };// RNM(TlsOp)\n  this.rules[19].opcodes[6] = { type: 4, index: 61 };// RNM(ClsOp)\n  this.rules[19].opcodes[7] = { type: 4, index: 30 };// RNM(BkrOp)\n  this.rules[19].opcodes[8] = { type: 4, index: 51 };// RNM(AbgOp)\n  this.rules[19].opcodes[9] = { type: 4, index: 52 };// RNM(AenOp)\n  this.rules[19].opcodes[10] = { type: 4, index: 65 };// RNM(ProsVal)\n\n  /* BasicElementErr */\n  this.rules[20].opcodes = [];\n  this.rules[20].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[20].opcodes[1] = { type: 1, children: [2,3,4,5] };// ALT\n  this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 };// TRG\n  this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 };// TRG\n  this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 };// TRG\n  this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 };// TRG\n\n  /* Group */\n  this.rules[21].opcodes = [];\n  this.rules[21].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[21].opcodes[1] = { type: 4, index: 23 };// RNM(GroupOpen)\n  this.rules[21].opcodes[2] = { type: 4, index: 14 };// RNM(Alternation)\n  this.rules[21].opcodes[3] = { type: 1, children: [4,5] };// ALT\n  this.rules[21].opcodes[4] = { type: 4, index: 24 };// RNM(GroupClose)\n  this.rules[21].opcodes[5] = { type: 4, index: 22 };// RNM(GroupError)\n\n  /* GroupError */\n  this.rules[22].opcodes = [];\n  this.rules[22].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[22].opcodes[1] = { type: 1, children: [2,3,4,5] };// ALT\n  this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 };// TRG\n  this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 };// TRG\n  this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 };// TRG\n  this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 };// TRG\n\n  /* GroupOpen */\n  this.rules[23].opcodes = [];\n  this.rules[23].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[23].opcodes[1] = { type: 6, string: [40] };// TBS\n  this.rules[23].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n\n  /* GroupClose */\n  this.rules[24].opcodes = [];\n  this.rules[24].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[24].opcodes[1] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[24].opcodes[2] = { type: 6, string: [41] };// TBS\n\n  /* Option */\n  this.rules[25].opcodes = [];\n  this.rules[25].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[25].opcodes[1] = { type: 4, index: 27 };// RNM(OptionOpen)\n  this.rules[25].opcodes[2] = { type: 4, index: 14 };// RNM(Alternation)\n  this.rules[25].opcodes[3] = { type: 1, children: [4,5] };// ALT\n  this.rules[25].opcodes[4] = { type: 4, index: 28 };// RNM(OptionClose)\n  this.rules[25].opcodes[5] = { type: 4, index: 26 };// RNM(OptionError)\n\n  /* OptionError */\n  this.rules[26].opcodes = [];\n  this.rules[26].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[26].opcodes[1] = { type: 1, children: [2,3,4,5] };// ALT\n  this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 };// TRG\n  this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 };// TRG\n  this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 };// TRG\n  this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 };// TRG\n\n  /* OptionOpen */\n  this.rules[27].opcodes = [];\n  this.rules[27].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[27].opcodes[1] = { type: 6, string: [91] };// TBS\n  this.rules[27].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n\n  /* OptionClose */\n  this.rules[28].opcodes = [];\n  this.rules[28].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[28].opcodes[1] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[28].opcodes[2] = { type: 6, string: [93] };// TBS\n\n  /* RnmOp */\n  this.rules[29].opcodes = [];\n  this.rules[29].opcodes[0] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* BkrOp */\n  this.rules[30].opcodes = [];\n  this.rules[30].opcodes[0] = { type: 2, children: [1,2,4] };// CAT\n  this.rules[30].opcodes[1] = { type: 6, string: [92] };// TBS\n  this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[30].opcodes[3] = { type: 4, index: 31 };// RNM(bkrModifier)\n  this.rules[30].opcodes[4] = { type: 4, index: 36 };// RNM(bkr-name)\n\n  /* bkrModifier */\n  this.rules[31].opcodes = [];\n  this.rules[31].opcodes[0] = { type: 1, children: [1,7,13,19] };// ALT\n  this.rules[31].opcodes[1] = { type: 2, children: [2,3] };// CAT\n  this.rules[31].opcodes[2] = { type: 4, index: 32 };// RNM(cs)\n  this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[4] = { type: 1, children: [5,6] };// ALT\n  this.rules[31].opcodes[5] = { type: 4, index: 34 };// RNM(um)\n  this.rules[31].opcodes[6] = { type: 4, index: 35 };// RNM(pm)\n  this.rules[31].opcodes[7] = { type: 2, children: [8,9] };// CAT\n  this.rules[31].opcodes[8] = { type: 4, index: 33 };// RNM(ci)\n  this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[10] = { type: 1, children: [11,12] };// ALT\n  this.rules[31].opcodes[11] = { type: 4, index: 34 };// RNM(um)\n  this.rules[31].opcodes[12] = { type: 4, index: 35 };// RNM(pm)\n  this.rules[31].opcodes[13] = { type: 2, children: [14,15] };// CAT\n  this.rules[31].opcodes[14] = { type: 4, index: 34 };// RNM(um)\n  this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[16] = { type: 1, children: [17,18] };// ALT\n  this.rules[31].opcodes[17] = { type: 4, index: 32 };// RNM(cs)\n  this.rules[31].opcodes[18] = { type: 4, index: 33 };// RNM(ci)\n  this.rules[31].opcodes[19] = { type: 2, children: [20,21] };// CAT\n  this.rules[31].opcodes[20] = { type: 4, index: 35 };// RNM(pm)\n  this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[22] = { type: 1, children: [23,24] };// ALT\n  this.rules[31].opcodes[23] = { type: 4, index: 32 };// RNM(cs)\n  this.rules[31].opcodes[24] = { type: 4, index: 33 };// RNM(ci)\n\n  /* cs */\n  this.rules[32].opcodes = [];\n  this.rules[32].opcodes[0] = { type: 6, string: [37,115] };// TBS\n\n  /* ci */\n  this.rules[33].opcodes = [];\n  this.rules[33].opcodes[0] = { type: 6, string: [37,105] };// TBS\n\n  /* um */\n  this.rules[34].opcodes = [];\n  this.rules[34].opcodes[0] = { type: 6, string: [37,117] };// TBS\n\n  /* pm */\n  this.rules[35].opcodes = [];\n  this.rules[35].opcodes[0] = { type: 6, string: [37,112] };// TBS\n\n  /* bkr-name */\n  this.rules[36].opcodes = [];\n  this.rules[36].opcodes[0] = { type: 1, children: [1,2,3] };// ALT\n  this.rules[36].opcodes[1] = { type: 4, index: 38 };// RNM(uname)\n  this.rules[36].opcodes[2] = { type: 4, index: 39 };// RNM(ename)\n  this.rules[36].opcodes[3] = { type: 4, index: 37 };// RNM(rname)\n\n  /* rname */\n  this.rules[37].opcodes = [];\n  this.rules[37].opcodes[0] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* uname */\n  this.rules[38].opcodes = [];\n  this.rules[38].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[38].opcodes[1] = { type: 6, string: [117,95] };// TBS\n  this.rules[38].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* ename */\n  this.rules[39].opcodes = [];\n  this.rules[39].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[39].opcodes[1] = { type: 6, string: [101,95] };// TBS\n  this.rules[39].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* UdtOp */\n  this.rules[40].opcodes = [];\n  this.rules[40].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[40].opcodes[1] = { type: 4, index: 42 };// RNM(udt-empty)\n  this.rules[40].opcodes[2] = { type: 4, index: 41 };// RNM(udt-non-empty)\n\n  /* udt-non-empty */\n  this.rules[41].opcodes = [];\n  this.rules[41].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[41].opcodes[1] = { type: 6, string: [117,95] };// TBS\n  this.rules[41].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* udt-empty */\n  this.rules[42].opcodes = [];\n  this.rules[42].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[42].opcodes[1] = { type: 6, string: [101,95] };// TBS\n  this.rules[42].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* RepOp */\n  this.rules[43].opcodes = [];\n  this.rules[43].opcodes[0] = { type: 1, children: [1,5,8,11,12] };// ALT\n  this.rules[43].opcodes[1] = { type: 2, children: [2,3,4] };// CAT\n  this.rules[43].opcodes[2] = { type: 4, index: 69 };// RNM(rep-min)\n  this.rules[43].opcodes[3] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[4] = { type: 4, index: 71 };// RNM(rep-max)\n  this.rules[43].opcodes[5] = { type: 2, children: [6,7] };// CAT\n  this.rules[43].opcodes[6] = { type: 4, index: 69 };// RNM(rep-min)\n  this.rules[43].opcodes[7] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[8] = { type: 2, children: [9,10] };// CAT\n  this.rules[43].opcodes[9] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[10] = { type: 4, index: 71 };// RNM(rep-max)\n  this.rules[43].opcodes[11] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[12] = { type: 4, index: 70 };// RNM(rep-min-max)\n\n  /* AltOp */\n  this.rules[44].opcodes = [];\n  this.rules[44].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[44].opcodes[1] = { type: 6, string: [47] };// TBS\n  this.rules[44].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n\n  /* CatOp */\n  this.rules[45].opcodes = [];\n  this.rules[45].opcodes[0] = { type: 4, index: 90 };// RNM(wsp)\n\n  /* StarOp */\n  this.rules[46].opcodes = [];\n  this.rules[46].opcodes[0] = { type: 6, string: [42] };// TBS\n\n  /* AndOp */\n  this.rules[47].opcodes = [];\n  this.rules[47].opcodes[0] = { type: 6, string: [38] };// TBS\n\n  /* NotOp */\n  this.rules[48].opcodes = [];\n  this.rules[48].opcodes[0] = { type: 6, string: [33] };// TBS\n\n  /* BkaOp */\n  this.rules[49].opcodes = [];\n  this.rules[49].opcodes[0] = { type: 6, string: [38,38] };// TBS\n\n  /* BknOp */\n  this.rules[50].opcodes = [];\n  this.rules[50].opcodes[0] = { type: 6, string: [33,33] };// TBS\n\n  /* AbgOp */\n  this.rules[51].opcodes = [];\n  this.rules[51].opcodes[0] = { type: 6, string: [37,94] };// TBS\n\n  /* AenOp */\n  this.rules[52].opcodes = [];\n  this.rules[52].opcodes[0] = { type: 6, string: [37,36] };// TBS\n\n  /* TrgOp */\n  this.rules[53].opcodes = [];\n  this.rules[53].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[53].opcodes[1] = { type: 6, string: [37] };// TBS\n  this.rules[53].opcodes[2] = { type: 1, children: [3,8,13] };// ALT\n  this.rules[53].opcodes[3] = { type: 2, children: [4,5,6,7] };// CAT\n  this.rules[53].opcodes[4] = { type: 4, index: 76 };// RNM(Dec)\n  this.rules[53].opcodes[5] = { type: 4, index: 79 };// RNM(dmin)\n  this.rules[53].opcodes[6] = { type: 6, string: [45] };// TBS\n  this.rules[53].opcodes[7] = { type: 4, index: 80 };// RNM(dmax)\n  this.rules[53].opcodes[8] = { type: 2, children: [9,10,11,12] };// CAT\n  this.rules[53].opcodes[9] = { type: 4, index: 77 };// RNM(Hex)\n  this.rules[53].opcodes[10] = { type: 4, index: 83 };// RNM(xmin)\n  this.rules[53].opcodes[11] = { type: 6, string: [45] };// TBS\n  this.rules[53].opcodes[12] = { type: 4, index: 84 };// RNM(xmax)\n  this.rules[53].opcodes[13] = { type: 2, children: [14,15,16,17] };// CAT\n  this.rules[53].opcodes[14] = { type: 4, index: 78 };// RNM(Bin)\n  this.rules[53].opcodes[15] = { type: 4, index: 81 };// RNM(bmin)\n  this.rules[53].opcodes[16] = { type: 6, string: [45] };// TBS\n  this.rules[53].opcodes[17] = { type: 4, index: 82 };// RNM(bmax)\n\n  /* TbsOp */\n  this.rules[54].opcodes = [];\n  this.rules[54].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[54].opcodes[1] = { type: 6, string: [37] };// TBS\n  this.rules[54].opcodes[2] = { type: 1, children: [3,10,17] };// ALT\n  this.rules[54].opcodes[3] = { type: 2, children: [4,5,6] };// CAT\n  this.rules[54].opcodes[4] = { type: 4, index: 76 };// RNM(Dec)\n  this.rules[54].opcodes[5] = { type: 4, index: 73 };// RNM(dString)\n  this.rules[54].opcodes[6] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[54].opcodes[7] = { type: 2, children: [8,9] };// CAT\n  this.rules[54].opcodes[8] = { type: 6, string: [46] };// TBS\n  this.rules[54].opcodes[9] = { type: 4, index: 73 };// RNM(dString)\n  this.rules[54].opcodes[10] = { type: 2, children: [11,12,13] };// CAT\n  this.rules[54].opcodes[11] = { type: 4, index: 77 };// RNM(Hex)\n  this.rules[54].opcodes[12] = { type: 4, index: 74 };// RNM(xString)\n  this.rules[54].opcodes[13] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[54].opcodes[14] = { type: 2, children: [15,16] };// CAT\n  this.rules[54].opcodes[15] = { type: 6, string: [46] };// TBS\n  this.rules[54].opcodes[16] = { type: 4, index: 74 };// RNM(xString)\n  this.rules[54].opcodes[17] = { type: 2, children: [18,19,20] };// CAT\n  this.rules[54].opcodes[18] = { type: 4, index: 78 };// RNM(Bin)\n  this.rules[54].opcodes[19] = { type: 4, index: 75 };// RNM(bString)\n  this.rules[54].opcodes[20] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[54].opcodes[21] = { type: 2, children: [22,23] };// CAT\n  this.rules[54].opcodes[22] = { type: 6, string: [46] };// TBS\n  this.rules[54].opcodes[23] = { type: 4, index: 75 };// RNM(bString)\n\n  /* TlsOp */\n  this.rules[55].opcodes = [];\n  this.rules[55].opcodes[0] = { type: 2, children: [1,2,3,4] };// CAT\n  this.rules[55].opcodes[1] = { type: 4, index: 56 };// RNM(TlsCase)\n  this.rules[55].opcodes[2] = { type: 4, index: 57 };// RNM(TlsOpen)\n  this.rules[55].opcodes[3] = { type: 4, index: 59 };// RNM(TlsString)\n  this.rules[55].opcodes[4] = { type: 4, index: 58 };// RNM(TlsClose)\n\n  /* TlsCase */\n  this.rules[56].opcodes = [];\n  this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[56].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[56].opcodes[2] = { type: 7, string: [37,105] };// TLS\n  this.rules[56].opcodes[3] = { type: 7, string: [37,115] };// TLS\n\n  /* TlsOpen */\n  this.rules[57].opcodes = [];\n  this.rules[57].opcodes[0] = { type: 6, string: [34] };// TBS\n\n  /* TlsClose */\n  this.rules[58].opcodes = [];\n  this.rules[58].opcodes[0] = { type: 6, string: [34] };// TBS\n\n  /* TlsString */\n  this.rules[59].opcodes = [];\n  this.rules[59].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[59].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 };// TRG\n  this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 };// TRG\n  this.rules[59].opcodes[4] = { type: 4, index: 60 };// RNM(StringTab)\n\n  /* StringTab */\n  this.rules[60].opcodes = [];\n  this.rules[60].opcodes[0] = { type: 6, string: [9] };// TBS\n\n  /* ClsOp */\n  this.rules[61].opcodes = [];\n  this.rules[61].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[61].opcodes[1] = { type: 4, index: 62 };// RNM(ClsOpen)\n  this.rules[61].opcodes[2] = { type: 4, index: 64 };// RNM(ClsString)\n  this.rules[61].opcodes[3] = { type: 4, index: 63 };// RNM(ClsClose)\n\n  /* ClsOpen */\n  this.rules[62].opcodes = [];\n  this.rules[62].opcodes[0] = { type: 6, string: [39] };// TBS\n\n  /* ClsClose */\n  this.rules[63].opcodes = [];\n  this.rules[63].opcodes[0] = { type: 6, string: [39] };// TBS\n\n  /* ClsString */\n  this.rules[64].opcodes = [];\n  this.rules[64].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[64].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 };// TRG\n  this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 };// TRG\n  this.rules[64].opcodes[4] = { type: 4, index: 60 };// RNM(StringTab)\n\n  /* ProsVal */\n  this.rules[65].opcodes = [];\n  this.rules[65].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[65].opcodes[1] = { type: 4, index: 66 };// RNM(ProsValOpen)\n  this.rules[65].opcodes[2] = { type: 4, index: 67 };// RNM(ProsValString)\n  this.rules[65].opcodes[3] = { type: 4, index: 68 };// RNM(ProsValClose)\n\n  /* ProsValOpen */\n  this.rules[66].opcodes = [];\n  this.rules[66].opcodes[0] = { type: 6, string: [60] };// TBS\n\n  /* ProsValString */\n  this.rules[67].opcodes = [];\n  this.rules[67].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[67].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 };// TRG\n  this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 };// TRG\n  this.rules[67].opcodes[4] = { type: 4, index: 60 };// RNM(StringTab)\n\n  /* ProsValClose */\n  this.rules[68].opcodes = [];\n  this.rules[68].opcodes[0] = { type: 6, string: [62] };// TBS\n\n  /* rep-min */\n  this.rules[69].opcodes = [];\n  this.rules[69].opcodes[0] = { type: 4, index: 72 };// RNM(rep-num)\n\n  /* rep-min-max */\n  this.rules[70].opcodes = [];\n  this.rules[70].opcodes[0] = { type: 4, index: 72 };// RNM(rep-num)\n\n  /* rep-max */\n  this.rules[71].opcodes = [];\n  this.rules[71].opcodes[0] = { type: 4, index: 72 };// RNM(rep-num)\n\n  /* rep-num */\n  this.rules[72].opcodes = [];\n  this.rules[72].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 };// TRG\n\n  /* dString */\n  this.rules[73].opcodes = [];\n  this.rules[73].opcodes[0] = { type: 4, index: 85 };// RNM(dnum)\n\n  /* xString */\n  this.rules[74].opcodes = [];\n  this.rules[74].opcodes[0] = { type: 4, index: 87 };// RNM(xnum)\n\n  /* bString */\n  this.rules[75].opcodes = [];\n  this.rules[75].opcodes[0] = { type: 4, index: 86 };// RNM(bnum)\n\n  /* Dec */\n  this.rules[76].opcodes = [];\n  this.rules[76].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[76].opcodes[1] = { type: 6, string: [68] };// TBS\n  this.rules[76].opcodes[2] = { type: 6, string: [100] };// TBS\n\n  /* Hex */\n  this.rules[77].opcodes = [];\n  this.rules[77].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[77].opcodes[1] = { type: 6, string: [88] };// TBS\n  this.rules[77].opcodes[2] = { type: 6, string: [120] };// TBS\n\n  /* Bin */\n  this.rules[78].opcodes = [];\n  this.rules[78].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[78].opcodes[1] = { type: 6, string: [66] };// TBS\n  this.rules[78].opcodes[2] = { type: 6, string: [98] };// TBS\n\n  /* dmin */\n  this.rules[79].opcodes = [];\n  this.rules[79].opcodes[0] = { type: 4, index: 85 };// RNM(dnum)\n\n  /* dmax */\n  this.rules[80].opcodes = [];\n  this.rules[80].opcodes[0] = { type: 4, index: 85 };// RNM(dnum)\n\n  /* bmin */\n  this.rules[81].opcodes = [];\n  this.rules[81].opcodes[0] = { type: 4, index: 86 };// RNM(bnum)\n\n  /* bmax */\n  this.rules[82].opcodes = [];\n  this.rules[82].opcodes[0] = { type: 4, index: 86 };// RNM(bnum)\n\n  /* xmin */\n  this.rules[83].opcodes = [];\n  this.rules[83].opcodes[0] = { type: 4, index: 87 };// RNM(xnum)\n\n  /* xmax */\n  this.rules[84].opcodes = [];\n  this.rules[84].opcodes[0] = { type: 4, index: 87 };// RNM(xnum)\n\n  /* dnum */\n  this.rules[85].opcodes = [];\n  this.rules[85].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 };// TRG\n\n  /* bnum */\n  this.rules[86].opcodes = [];\n  this.rules[86].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 };// TRG\n\n  /* xnum */\n  this.rules[87].opcodes = [];\n  this.rules[87].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[87].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 };// TRG\n  this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 };// TRG\n  this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 };// TRG\n\n  /* alphanum */\n  this.rules[88].opcodes = [];\n  this.rules[88].opcodes[0] = { type: 2, children: [1,4] };// CAT\n  this.rules[88].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 };// TRG\n  this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 };// TRG\n  this.rules[88].opcodes[4] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[88].opcodes[5] = { type: 1, children: [6,7,8,9] };// ALT\n  this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 };// TRG\n  this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 };// TRG\n  this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 };// TRG\n  this.rules[88].opcodes[9] = { type: 6, string: [45] };// TBS\n\n  /* owsp */\n  this.rules[89].opcodes = [];\n  this.rules[89].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[89].opcodes[1] = { type: 4, index: 91 };// RNM(space)\n\n  /* wsp */\n  this.rules[90].opcodes = [];\n  this.rules[90].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[90].opcodes[1] = { type: 4, index: 91 };// RNM(space)\n\n  /* space */\n  this.rules[91].opcodes = [];\n  this.rules[91].opcodes[0] = { type: 1, children: [1,2,3,4] };// ALT\n  this.rules[91].opcodes[1] = { type: 6, string: [32] };// TBS\n  this.rules[91].opcodes[2] = { type: 6, string: [9] };// TBS\n  this.rules[91].opcodes[3] = { type: 4, index: 92 };// RNM(comment)\n  this.rules[91].opcodes[4] = { type: 4, index: 94 };// RNM(LineContinue)\n\n  /* comment */\n  this.rules[92].opcodes = [];\n  this.rules[92].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[92].opcodes[1] = { type: 6, string: [59] };// TBS\n  this.rules[92].opcodes[2] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[92].opcodes[3] = { type: 1, children: [4,5] };// ALT\n  this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[92].opcodes[5] = { type: 6, string: [9] };// TBS\n\n  /* LineEnd */\n  this.rules[93].opcodes = [];\n  this.rules[93].opcodes[0] = { type: 1, children: [1,2,3] };// ALT\n  this.rules[93].opcodes[1] = { type: 6, string: [13,10] };// TBS\n  this.rules[93].opcodes[2] = { type: 6, string: [10] };// TBS\n  this.rules[93].opcodes[3] = { type: 6, string: [13] };// TBS\n\n  /* LineContinue */\n  this.rules[94].opcodes = [];\n  this.rules[94].opcodes[0] = { type: 2, children: [1,5] };// CAT\n  this.rules[94].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[94].opcodes[2] = { type: 6, string: [13,10] };// TBS\n  this.rules[94].opcodes[3] = { type: 6, string: [10] };// TBS\n  this.rules[94].opcodes[4] = { type: 6, string: [13] };// TBS\n  this.rules[94].opcodes[5] = { type: 1, children: [6,7] };// ALT\n  this.rules[94].opcodes[6] = { type: 6, string: [32] };// TBS\n  this.rules[94].opcodes[7] = { type: 6, string: [9] };// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \";\\n\";\n    str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n    str += \"; RFC 5234 with some restrictions and additions.\\n\";\n    str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n    str += \";  - accepts %s\\\"string\\\" as a case-sensitive string\\n\";\n    str += \";  - accepts %i\\\"string\\\" as a case-insensitive string\\n\";\n    str += \";  - accepts \\\"string\\\" as a case-insensitive string\\n\";\n    str += \";\\n\";\n    str += \"; Some restrictions:\\n\";\n    str += \";   1. Rules must begin at first character of each line.\\n\";\n    str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n    str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n    str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n    str += \";      However, a working parser cannot be generated from them.\\n\";\n    str += \";\\n\";\n    str += \"; Super set (SABNF) additions:\\n\";\n    str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n    str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n    str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n    str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n    str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n    str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n    str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n    str += \";      e.g. rule = A / u_myUdt\\n\";\n    str += \";           A = \\\"a\\\"\\n\";\n    str += \";      would be a valid grammar.\\n\";\n    str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n    str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n    str += \";      (kept for backward compatibility, but superseded by %s\\\"abc\\\")  \\n\";\n    str += \"; New 12/26/2015\\n\";\n    str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n    str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n    str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n    str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n    str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n    str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n    str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n    str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n    str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n    str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n    str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n    str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n    str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n    str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n    str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n    str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";\\n\";\n    str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n    str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n    str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n    str += \"                / (LineEndError LineEnd))\\n\";\n    str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n    str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n    str += \"RuleName        = alphanum\\n\";\n    str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n    str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n    str += \"DefinedAsError  = 1*2%d33-126\\n\";\n    str += \"DefinedAs       = IncAlt / Defined\\n\";\n    str += \"Defined         = %d61\\n\";\n    str += \"IncAlt          = %d61.47\\n\";\n    str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n    str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n    str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n    str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n    str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n    str += \"Modifier        = (Predicate [RepOp])\\n\";\n    str += \"                / RepOp\\n\";\n    str += \"Predicate       = BkaOp\\n\";\n    str += \"                / BknOp\\n\";\n    str += \"                / AndOp\\n\";\n    str += \"                / NotOp\\n\";\n    str += \"BasicElement    = UdtOp\\n\";\n    str += \"                / RnmOp\\n\";\n    str += \"                / TrgOp\\n\";\n    str += \"                / TbsOp\\n\";\n    str += \"                / TlsOp\\n\";\n    str += \"                / ClsOp\\n\";\n    str += \"                / BkrOp\\n\";\n    str += \"                / AbgOp\\n\";\n    str += \"                / AenOp\\n\";\n    str += \"                / ProsVal\\n\";\n    str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n    str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n    str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"GroupOpen       = %d40 owsp\\n\";\n    str += \"GroupClose      = owsp %d41\\n\";\n    str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n    str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"OptionOpen      = %d91 owsp\\n\";\n    str += \"OptionClose     = owsp %d93\\n\";\n    str += \"RnmOp           = alphanum\\n\";\n    str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n    str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n    str += \"cs              = '%s'\\n\";\n    str += \"ci              = '%i'\\n\";\n    str += \"um              = '%u'\\n\";\n    str += \"pm              = '%p'\\n\";\n    str += \"bkr-name        = uname / ename / rname\\n\";\n    str += \"rname           = alphanum\\n\";\n    str += \"uname           = %d117.95 alphanum\\n\";\n    str += \"ename           = %d101.95 alphanum\\n\";\n    str += \"UdtOp           = udt-empty\\n\";\n    str += \"                / udt-non-empty\\n\";\n    str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n    str += \"udt-empty       = %d101.95 alphanum\\n\";\n    str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n    str += \"                / (rep-min StarOp)\\n\";\n    str += \"                / (StarOp rep-max)\\n\";\n    str += \"                / StarOp\\n\";\n    str += \"                / rep-min-max\\n\";\n    str += \"AltOp           = %d47 owsp\\n\";\n    str += \"CatOp           = wsp\\n\";\n    str += \"StarOp          = %d42\\n\";\n    str += \"AndOp           = %d38\\n\";\n    str += \"NotOp           = %d33\\n\";\n    str += \"BkaOp           = %d38.38\\n\";\n    str += \"BknOp           = %d33.33\\n\";\n    str += \"AbgOp           = %d37.94\\n\";\n    str += \"AenOp           = %d37.36\\n\";\n    str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n    str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n    str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n    str += \"TlsCase         = [\\\"%i\\\" / \\\"%s\\\"]\\n\";\n    str += \"TlsOpen         = %d34\\n\";\n    str += \"TlsClose        = %d34\\n\";\n    str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n    str += \"StringTab       = %d9\\n\";\n    str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n    str += \"ClsOpen         = %d39\\n\";\n    str += \"ClsClose        = %d39\\n\";\n    str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n    str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n    str += \"ProsValOpen     = %d60\\n\";\n    str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n    str += \"ProsValClose    = %d62\\n\";\n    str += \"rep-min         = rep-num\\n\";\n    str += \"rep-min-max     = rep-num\\n\";\n    str += \"rep-max         = rep-num\\n\";\n    str += \"rep-num         = 1*(%d48-57)\\n\";\n    str += \"dString         = dnum\\n\";\n    str += \"xString         = xnum\\n\";\n    str += \"bString         = bnum\\n\";\n    str += \"Dec             = (%d68/%d100)\\n\";\n    str += \"Hex             = (%d88/%d120)\\n\";\n    str += \"Bin             = (%d66/%d98)\\n\";\n    str += \"dmin            = dnum\\n\";\n    str += \"dmax            = dnum\\n\";\n    str += \"bmin            = bnum\\n\";\n    str += \"bmax            = bnum\\n\";\n    str += \"xmin            = xnum\\n\";\n    str += \"xmax            = xnum\\n\";\n    str += \"dnum            = 1*(%d48-57)\\n\";\n    str += \"bnum            = 1*%d48-49\\n\";\n    str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n    str += \";\\n\";\n    str += \"; Basics\\n\";\n    str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n    str += \"owsp            = *space\\n\";\n    str += \"wsp             = 1*space\\n\";\n    str += \"space           = %d32\\n\";\n    str += \"                / %d9\\n\";\n    str += \"                / comment\\n\";\n    str += \"                / LineContinue\\n\";\n    str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n    str += \"LineEnd         = %d13.10\\n\";\n    str += \"                / %d10\\n\";\n    str += \"                / %d13\\n\";\n    str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NhYm5mLWdyYW1tYXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixx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QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NhYm5mLWdyYW1tYXIuanM/NDczYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyNCBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkPGJyPlxuLy8gICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKTxicj5cbi8vXG4vLyBHZW5lcmF0ZWQgYnkgYXBnLWpzLCBWZXJzaW9uIDQuNC4wIFthcGctanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdyYW1tYXIoKXtcbiAgLy8gYGBgXG4gIC8vIFNVTU1BUllcbiAgLy8gICAgICBydWxlcyA9IDk1XG4gIC8vICAgICAgIHVkdHMgPSAwXG4gIC8vICAgIG9wY29kZXMgPSAzNzJcbiAgLy8gICAgICAgIC0tLSAgIEFCTkYgb3JpZ2luYWwgb3Bjb2Rlc1xuICAvLyAgICAgICAgQUxUID0gNDNcbiAgLy8gICAgICAgIENBVCA9IDQ4XG4gIC8vICAgICAgICBSRVAgPSAzNFxuICAvLyAgICAgICAgUk5NID0gMTQ5XG4gIC8vICAgICAgICBUTFMgPSAyXG4gIC8vICAgICAgICBUQlMgPSA2MVxuICAvLyAgICAgICAgVFJHID0gMzVcbiAgLy8gICAgICAgIC0tLSAgIFNBQk5GIHN1cGVyc2V0IG9wY29kZXNcbiAgLy8gICAgICAgIFVEVCA9IDBcbiAgLy8gICAgICAgIEFORCA9IDBcbiAgLy8gICAgICAgIE5PVCA9IDBcbiAgLy8gICAgICAgIEJLQSA9IDBcbiAgLy8gICAgICAgIEJLTiA9IDBcbiAgLy8gICAgICAgIEJLUiA9IDBcbiAgLy8gICAgICAgIEFCRyA9IDBcbiAgLy8gICAgICAgIEFFTiA9IDBcbiAgLy8gY2hhcmFjdGVycyA9IFs5IC0gMTI2XVxuICAvLyBgYGBcbiAgLyogT0JKRUNUIElERU5USUZJRVIgKGZvciBpbnRlcm5hbCBwYXJzZXIgdXNlKSAqL1xuICB0aGlzLmdyYW1tYXJPYmplY3QgPSAnZ3JhbW1hck9iamVjdCc7XG5cbiAgLyogUlVMRVMgKi9cbiAgdGhpcy5ydWxlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdID0geyBuYW1lOiAnRmlsZScsIGxvd2VyOiAnZmlsZScsIGluZGV4OiAwLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1sxXSA9IHsgbmFtZTogJ0JsYW5rTGluZScsIGxvd2VyOiAnYmxhbmtsaW5lJywgaW5kZXg6IDEsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzJdID0geyBuYW1lOiAnUnVsZScsIGxvd2VyOiAncnVsZScsIGluZGV4OiAyLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1szXSA9IHsgbmFtZTogJ1J1bGVMb29rdXAnLCBsb3dlcjogJ3J1bGVsb29rdXAnLCBpbmRleDogMywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNF0gPSB7IG5hbWU6ICdSdWxlTmFtZVRlc3QnLCBsb3dlcjogJ3J1bGVuYW1ldGVzdCcsIGluZGV4OiA0LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s1XSA9IHsgbmFtZTogJ1J1bGVOYW1lJywgbG93ZXI6ICdydWxlbmFtZScsIGluZGV4OiA1LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2XSA9IHsgbmFtZTogJ1J1bGVOYW1lRXJyb3InLCBsb3dlcjogJ3J1bGVuYW1lZXJyb3InLCBpbmRleDogNiwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbN10gPSB7IG5hbWU6ICdEZWZpbmVkQXNUZXN0JywgbG93ZXI6ICdkZWZpbmVkYXN0ZXN0JywgaW5kZXg6IDcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzhdID0geyBuYW1lOiAnRGVmaW5lZEFzRXJyb3InLCBsb3dlcjogJ2RlZmluZWRhc2Vycm9yJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzldID0geyBuYW1lOiAnRGVmaW5lZEFzJywgbG93ZXI6ICdkZWZpbmVkYXMnLCBpbmRleDogOSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMTBdID0geyBuYW1lOiAnRGVmaW5lZCcsIGxvd2VyOiAnZGVmaW5lZCcsIGluZGV4OiAxMCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMTFdID0geyBuYW1lOiAnSW5jQWx0JywgbG93ZXI6ICdpbmNhbHQnLCBpbmRleDogMTEsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzEyXSA9IHsgbmFtZTogJ1J1bGVFcnJvcicsIGxvd2VyOiAncnVsZWVycm9yJywgaW5kZXg6IDEyLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1sxM10gPSB7IG5hbWU6ICdMaW5lRW5kRXJyb3InLCBsb3dlcjogJ2xpbmVlbmRlcnJvcicsIGluZGV4OiAxMywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMTRdID0geyBuYW1lOiAnQWx0ZXJuYXRpb24nLCBsb3dlcjogJ2FsdGVybmF0aW9uJywgaW5kZXg6IDE0LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1sxNV0gPSB7IG5hbWU6ICdDb25jYXRlbmF0aW9uJywgbG93ZXI6ICdjb25jYXRlbmF0aW9uJywgaW5kZXg6IDE1LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1sxNl0gPSB7IG5hbWU6ICdSZXBldGl0aW9uJywgbG93ZXI6ICdyZXBldGl0aW9uJywgaW5kZXg6IDE2LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1sxN10gPSB7IG5hbWU6ICdNb2RpZmllcicsIGxvd2VyOiAnbW9kaWZpZXInLCBpbmRleDogMTcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzE4XSA9IHsgbmFtZTogJ1ByZWRpY2F0ZScsIGxvd2VyOiAncHJlZGljYXRlJywgaW5kZXg6IDE4LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1sxOV0gPSB7IG5hbWU6ICdCYXNpY0VsZW1lbnQnLCBsb3dlcjogJ2Jhc2ljZWxlbWVudCcsIGluZGV4OiAxOSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMjBdID0geyBuYW1lOiAnQmFzaWNFbGVtZW50RXJyJywgbG93ZXI6ICdiYXNpY2VsZW1lbnRlcnInLCBpbmRleDogMjAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzIxXSA9IHsgbmFtZTogJ0dyb3VwJywgbG93ZXI6ICdncm91cCcsIGluZGV4OiAyMSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMjJdID0geyBuYW1lOiAnR3JvdXBFcnJvcicsIGxvd2VyOiAnZ3JvdXBlcnJvcicsIGluZGV4OiAyMiwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMjNdID0geyBuYW1lOiAnR3JvdXBPcGVuJywgbG93ZXI6ICdncm91cG9wZW4nLCBpbmRleDogMjMsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzI0XSA9IHsgbmFtZTogJ0dyb3VwQ2xvc2UnLCBsb3dlcjogJ2dyb3VwY2xvc2UnLCBpbmRleDogMjQsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzI1XSA9IHsgbmFtZTogJ09wdGlvbicsIGxvd2VyOiAnb3B0aW9uJywgaW5kZXg6IDI1LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1syNl0gPSB7IG5hbWU6ICdPcHRpb25FcnJvcicsIGxvd2VyOiAnb3B0aW9uZXJyb3InLCBpbmRleDogMjYsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzI3XSA9IHsgbmFtZTogJ09wdGlvbk9wZW4nLCBsb3dlcjogJ29wdGlvbm9wZW4nLCBpbmRleDogMjcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzI4XSA9IHsgbmFtZTogJ09wdGlvbkNsb3NlJywgbG93ZXI6ICdvcHRpb25jbG9zZScsIGluZGV4OiAyOCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMjldID0geyBuYW1lOiAnUm5tT3AnLCBsb3dlcjogJ3JubW9wJywgaW5kZXg6IDI5LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1szMF0gPSB7IG5hbWU6ICdCa3JPcCcsIGxvd2VyOiAnYmtyb3AnLCBpbmRleDogMzAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzMxXSA9IHsgbmFtZTogJ2Jrck1vZGlmaWVyJywgbG93ZXI6ICdia3Jtb2RpZmllcicsIGluZGV4OiAzMSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMzJdID0geyBuYW1lOiAnY3MnLCBsb3dlcjogJ2NzJywgaW5kZXg6IDMyLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1szM10gPSB7IG5hbWU6ICdjaScsIGxvd2VyOiAnY2knLCBpbmRleDogMzMsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzM0XSA9IHsgbmFtZTogJ3VtJywgbG93ZXI6ICd1bScsIGluZGV4OiAzNCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMzVdID0geyBuYW1lOiAncG0nLCBsb3dlcjogJ3BtJywgaW5kZXg6IDM1LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1szNl0gPSB7IG5hbWU6ICdia3ItbmFtZScsIGxvd2VyOiAnYmtyLW5hbWUnLCBpbmRleDogMzYsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzM3XSA9IHsgbmFtZTogJ3JuYW1lJywgbG93ZXI6ICdybmFtZScsIGluZGV4OiAzNywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbMzhdID0geyBuYW1lOiAndW5hbWUnLCBsb3dlcjogJ3VuYW1lJywgaW5kZXg6IDM4LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1szOV0gPSB7IG5hbWU6ICdlbmFtZScsIGxvd2VyOiAnZW5hbWUnLCBpbmRleDogMzksIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzQwXSA9IHsgbmFtZTogJ1VkdE9wJywgbG93ZXI6ICd1ZHRvcCcsIGluZGV4OiA0MCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNDFdID0geyBuYW1lOiAndWR0LW5vbi1lbXB0eScsIGxvd2VyOiAndWR0LW5vbi1lbXB0eScsIGluZGV4OiA0MSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNDJdID0geyBuYW1lOiAndWR0LWVtcHR5JywgbG93ZXI6ICd1ZHQtZW1wdHknLCBpbmRleDogNDIsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzQzXSA9IHsgbmFtZTogJ1JlcE9wJywgbG93ZXI6ICdyZXBvcCcsIGluZGV4OiA0MywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNDRdID0geyBuYW1lOiAnQWx0T3AnLCBsb3dlcjogJ2FsdG9wJywgaW5kZXg6IDQ0LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s0NV0gPSB7IG5hbWU6ICdDYXRPcCcsIGxvd2VyOiAnY2F0b3AnLCBpbmRleDogNDUsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzQ2XSA9IHsgbmFtZTogJ1N0YXJPcCcsIGxvd2VyOiAnc3Rhcm9wJywgaW5kZXg6IDQ2LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s0N10gPSB7IG5hbWU6ICdBbmRPcCcsIGxvd2VyOiAnYW5kb3AnLCBpbmRleDogNDcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzQ4XSA9IHsgbmFtZTogJ05vdE9wJywgbG93ZXI6ICdub3RvcCcsIGluZGV4OiA0OCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNDldID0geyBuYW1lOiAnQmthT3AnLCBsb3dlcjogJ2JrYW9wJywgaW5kZXg6IDQ5LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s1MF0gPSB7IG5hbWU6ICdCa25PcCcsIGxvd2VyOiAnYmtub3AnLCBpbmRleDogNTAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzUxXSA9IHsgbmFtZTogJ0FiZ09wJywgbG93ZXI6ICdhYmdvcCcsIGluZGV4OiA1MSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNTJdID0geyBuYW1lOiAnQWVuT3AnLCBsb3dlcjogJ2Flbm9wJywgaW5kZXg6IDUyLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s1M10gPSB7IG5hbWU6ICdUcmdPcCcsIGxvd2VyOiAndHJnb3AnLCBpbmRleDogNTMsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzU0XSA9IHsgbmFtZTogJ1Ric09wJywgbG93ZXI6ICd0YnNvcCcsIGluZGV4OiA1NCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNTVdID0geyBuYW1lOiAnVGxzT3AnLCBsb3dlcjogJ3Rsc29wJywgaW5kZXg6IDU1LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s1Nl0gPSB7IG5hbWU6ICdUbHNDYXNlJywgbG93ZXI6ICd0bHNjYXNlJywgaW5kZXg6IDU2LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s1N10gPSB7IG5hbWU6ICdUbHNPcGVuJywgbG93ZXI6ICd0bHNvcGVuJywgaW5kZXg6IDU3LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s1OF0gPSB7IG5hbWU6ICdUbHNDbG9zZScsIGxvd2VyOiAndGxzY2xvc2UnLCBpbmRleDogNTgsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzU5XSA9IHsgbmFtZTogJ1Rsc1N0cmluZycsIGxvd2VyOiAndGxzc3RyaW5nJywgaW5kZXg6IDU5LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2MF0gPSB7IG5hbWU6ICdTdHJpbmdUYWInLCBsb3dlcjogJ3N0cmluZ3RhYicsIGluZGV4OiA2MCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNjFdID0geyBuYW1lOiAnQ2xzT3AnLCBsb3dlcjogJ2Nsc29wJywgaW5kZXg6IDYxLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2Ml0gPSB7IG5hbWU6ICdDbHNPcGVuJywgbG93ZXI6ICdjbHNvcGVuJywgaW5kZXg6IDYyLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2M10gPSB7IG5hbWU6ICdDbHNDbG9zZScsIGxvd2VyOiAnY2xzY2xvc2UnLCBpbmRleDogNjMsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzY0XSA9IHsgbmFtZTogJ0Nsc1N0cmluZycsIGxvd2VyOiAnY2xzc3RyaW5nJywgaW5kZXg6IDY0LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2NV0gPSB7IG5hbWU6ICdQcm9zVmFsJywgbG93ZXI6ICdwcm9zdmFsJywgaW5kZXg6IDY1LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2Nl0gPSB7IG5hbWU6ICdQcm9zVmFsT3BlbicsIGxvd2VyOiAncHJvc3ZhbG9wZW4nLCBpbmRleDogNjYsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzY3XSA9IHsgbmFtZTogJ1Byb3NWYWxTdHJpbmcnLCBsb3dlcjogJ3Byb3N2YWxzdHJpbmcnLCBpbmRleDogNjcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzY4XSA9IHsgbmFtZTogJ1Byb3NWYWxDbG9zZScsIGxvd2VyOiAncHJvc3ZhbGNsb3NlJywgaW5kZXg6IDY4LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s2OV0gPSB7IG5hbWU6ICdyZXAtbWluJywgbG93ZXI6ICdyZXAtbWluJywgaW5kZXg6IDY5LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s3MF0gPSB7IG5hbWU6ICdyZXAtbWluLW1heCcsIGxvd2VyOiAncmVwLW1pbi1tYXgnLCBpbmRleDogNzAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzcxXSA9IHsgbmFtZTogJ3JlcC1tYXgnLCBsb3dlcjogJ3JlcC1tYXgnLCBpbmRleDogNzEsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzcyXSA9IHsgbmFtZTogJ3JlcC1udW0nLCBsb3dlcjogJ3JlcC1udW0nLCBpbmRleDogNzIsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzczXSA9IHsgbmFtZTogJ2RTdHJpbmcnLCBsb3dlcjogJ2RzdHJpbmcnLCBpbmRleDogNzMsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzc0XSA9IHsgbmFtZTogJ3hTdHJpbmcnLCBsb3dlcjogJ3hzdHJpbmcnLCBpbmRleDogNzQsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzc1XSA9IHsgbmFtZTogJ2JTdHJpbmcnLCBsb3dlcjogJ2JzdHJpbmcnLCBpbmRleDogNzUsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzc2XSA9IHsgbmFtZTogJ0RlYycsIGxvd2VyOiAnZGVjJywgaW5kZXg6IDc2LCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1s3N10gPSB7IG5hbWU6ICdIZXgnLCBsb3dlcjogJ2hleCcsIGluZGV4OiA3NywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNzhdID0geyBuYW1lOiAnQmluJywgbG93ZXI6ICdiaW4nLCBpbmRleDogNzgsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzc5XSA9IHsgbmFtZTogJ2RtaW4nLCBsb3dlcjogJ2RtaW4nLCBpbmRleDogNzksIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzgwXSA9IHsgbmFtZTogJ2RtYXgnLCBsb3dlcjogJ2RtYXgnLCBpbmRleDogODAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzgxXSA9IHsgbmFtZTogJ2JtaW4nLCBsb3dlcjogJ2JtaW4nLCBpbmRleDogODEsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzgyXSA9IHsgbmFtZTogJ2JtYXgnLCBsb3dlcjogJ2JtYXgnLCBpbmRleDogODIsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzgzXSA9IHsgbmFtZTogJ3htaW4nLCBsb3dlcjogJ3htaW4nLCBpbmRleDogODMsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzg0XSA9IHsgbmFtZTogJ3htYXgnLCBsb3dlcjogJ3htYXgnLCBpbmRleDogODQsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzg1XSA9IHsgbmFtZTogJ2RudW0nLCBsb3dlcjogJ2RudW0nLCBpbmRleDogODUsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzg2XSA9IHsgbmFtZTogJ2JudW0nLCBsb3dlcjogJ2JudW0nLCBpbmRleDogODYsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzg3XSA9IHsgbmFtZTogJ3hudW0nLCBsb3dlcjogJ3hudW0nLCBpbmRleDogODcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzg4XSA9IHsgbmFtZTogJ2FscGhhbnVtJywgbG93ZXI6ICdhbHBoYW51bScsIGluZGV4OiA4OCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbODldID0geyBuYW1lOiAnb3dzcCcsIGxvd2VyOiAnb3dzcCcsIGluZGV4OiA4OSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbOTBdID0geyBuYW1lOiAnd3NwJywgbG93ZXI6ICd3c3AnLCBpbmRleDogOTAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzkxXSA9IHsgbmFtZTogJ3NwYWNlJywgbG93ZXI6ICdzcGFjZScsIGluZGV4OiA5MSwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbOTJdID0geyBuYW1lOiAnY29tbWVudCcsIGxvd2VyOiAnY29tbWVudCcsIGluZGV4OiA5MiwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbOTNdID0geyBuYW1lOiAnTGluZUVuZCcsIGxvd2VyOiAnbGluZWVuZCcsIGluZGV4OiA5MywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbOTRdID0geyBuYW1lOiAnTGluZUNvbnRpbnVlJywgbG93ZXI6ICdsaW5lY29udGludWUnLCBpbmRleDogOTQsIGlzQmtyOiBmYWxzZSB9O1xuXG4gIC8qIFVEVFMgKi9cbiAgdGhpcy51ZHRzID0gW107XG5cbiAgLyogT1BDT0RFUyAqL1xuICAvKiBGaWxlICovXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDEgfTsvLyBSTk0oQmxhbmtMaW5lKVxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbM10gPSB7IHR5cGU6IDQsIGluZGV4OiAyIH07Ly8gUk5NKFJ1bGUpXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDEyIH07Ly8gUk5NKFJ1bGVFcnJvcilcblxuICAvKiBCbGFua0xpbmUgKi9cbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDUsN10gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzFdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzJdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzMsNF0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzNdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszMl0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzRdID0geyB0eXBlOiA2LCBzdHJpbmc6IFs5XSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXNbNV0gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiAxIH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNCwgaW5kZXg6IDkyIH07Ly8gUk5NKGNvbW1lbnQpXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1s3XSA9IHsgdHlwZTogNCwgaW5kZXg6IDkzIH07Ly8gUk5NKExpbmVFbmQpXG5cbiAgLyogUnVsZSAqL1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMiwzLDRdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDMgfTsvLyBSTk0oUnVsZUxvb2t1cClcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogODkgfTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzNdID0geyB0eXBlOiA0LCBpbmRleDogMTQgfTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFs1LDhdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s1XSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFs2LDddIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNCwgaW5kZXg6IDg5IH07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s3XSA9IHsgdHlwZTogNCwgaW5kZXg6IDkzIH07Ly8gUk5NKExpbmVFbmQpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1s4XSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFs5LDEwXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXNbOV0gPSB7IHR5cGU6IDQsIGluZGV4OiAxMyB9Oy8vIFJOTShMaW5lRW5kRXJyb3IpXG4gIHRoaXMucnVsZXNbMl0ub3Bjb2Rlc1sxMF0gPSB7IHR5cGU6IDQsIGluZGV4OiA5MyB9Oy8vIFJOTShMaW5lRW5kKVxuXG4gIC8qIFJ1bGVMb29rdXAgKi9cbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM10gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzFdID0geyB0eXBlOiA0LCBpbmRleDogNCB9Oy8vIFJOTShSdWxlTmFtZVRlc3QpXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg5IH07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbM10ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNCwgaW5kZXg6IDcgfTsvLyBSTk0oRGVmaW5lZEFzVGVzdClcblxuICAvKiBSdWxlTmFtZVRlc3QgKi9cbiAgdGhpcy5ydWxlc1s0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDUgfTsvLyBSTk0oUnVsZU5hbWUpXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDYgfTsvLyBSTk0oUnVsZU5hbWVFcnJvcilcblxuICAvKiBSdWxlTmFtZSAqL1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogODggfTsvLyBSTk0oYWxwaGFudW0pXG5cbiAgLyogUnVsZU5hbWVFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzFdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzIsM10gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzJdID0geyB0eXBlOiA1LCBtaW46IDMzLCBtYXg6IDYwIH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNSwgbWluOiA2MiwgbWF4OiAxMjYgfTsvLyBUUkdcblxuICAvKiBEZWZpbmVkQXNUZXN0ICovXG4gIHRoaXMucnVsZXNbN10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXNbMF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzddLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiA5IH07Ly8gUk5NKERlZmluZWRBcylcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogOCB9Oy8vIFJOTShEZWZpbmVkQXNFcnJvcilcblxuICAvKiBEZWZpbmVkQXNFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogMiB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDUsIG1pbjogMzMsIG1heDogMTI2IH07Ly8gVFJHXG5cbiAgLyogRGVmaW5lZEFzICovXG4gIHRoaXMucnVsZXNbOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzldLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiAxMSB9Oy8vIFJOTShJbmNBbHQpXG4gIHRoaXMucnVsZXNbOV0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDEwIH07Ly8gUk5NKERlZmluZWQpXG5cbiAgLyogRGVmaW5lZCAqL1xuICB0aGlzLnJ1bGVzWzEwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTBdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzYxXSB9Oy8vIFRCU1xuXG4gIC8qIEluY0FsdCAqL1xuICB0aGlzLnJ1bGVzWzExXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTFdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzYxLDQ3XSB9Oy8vIFRCU1xuXG4gIC8qIFJ1bGVFcnJvciAqL1xuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTJdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSw2XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzEyXS5vcGNvZGVzWzFdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFszLDQsNV0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNSwgbWluOiAzMiwgbWF4OiAxMjYgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbOV0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s1XSA9IHsgdHlwZTogNCwgaW5kZXg6IDk0IH07Ly8gUk5NKExpbmVDb250aW51ZSlcbiAgdGhpcy5ydWxlc1sxMl0ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNCwgaW5kZXg6IDkzIH07Ly8gUk5NKExpbmVFbmQpXG5cbiAgLyogTGluZUVuZEVycm9yICovXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxM10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbM10gPSB7IHR5cGU6IDYsIHN0cmluZzogWzldIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMTNdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiA5NCB9Oy8vIFJOTShMaW5lQ29udGludWUpXG5cbiAgLyogQWx0ZXJuYXRpb24gKi9cbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDE1IH07Ly8gUk5NKENvbmNhdGVuYXRpb24pXG4gIHRoaXMucnVsZXNbMTRdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzNdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogODkgfTsvLyBSTk0ob3dzcClcbiAgdGhpcy5ydWxlc1sxNF0ub3Bjb2Rlc1s1XSA9IHsgdHlwZTogNCwgaW5kZXg6IDQ0IH07Ly8gUk5NKEFsdE9wKVxuICB0aGlzLnJ1bGVzWzE0XS5vcGNvZGVzWzZdID0geyB0eXBlOiA0LCBpbmRleDogMTUgfTsvLyBSTk0oQ29uY2F0ZW5hdGlvbilcblxuICAvKiBDb25jYXRlbmF0aW9uICovXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiAxNiB9Oy8vIFJOTShSZXBldGl0aW9uKVxuICB0aGlzLnJ1bGVzWzE1XS5vcGNvZGVzWzJdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFs0LDVdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMTVdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiA0NSB9Oy8vIFJOTShDYXRPcClcbiAgdGhpcy5ydWxlc1sxNV0ub3Bjb2Rlc1s1XSA9IHsgdHlwZTogNCwgaW5kZXg6IDE2IH07Ly8gUk5NKFJlcGV0aXRpb24pXG5cbiAgLyogUmVwZXRpdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwzXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzFdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogMSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogMTcgfTsvLyBSTk0oTW9kaWZpZXIpXG4gIHRoaXMucnVsZXNbMTZdLm9wY29kZXNbM10gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbNCw1LDYsN10gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1sxNl0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDIxIH07Ly8gUk5NKEdyb3VwKVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzVdID0geyB0eXBlOiA0LCBpbmRleDogMjUgfTsvLyBSTk0oT3B0aW9uKVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzZdID0geyB0eXBlOiA0LCBpbmRleDogMTkgfTsvLyBSTk0oQmFzaWNFbGVtZW50KVxuICB0aGlzLnJ1bGVzWzE2XS5vcGNvZGVzWzddID0geyB0eXBlOiA0LCBpbmRleDogMjAgfTsvLyBSTk0oQmFzaWNFbGVtZW50RXJyKVxuXG4gIC8qIE1vZGlmaWVyICovXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxN10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsxLDVdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbMV0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMiwzXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogMTggfTsvLyBSTk0oUHJlZGljYXRlKVxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzNdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogMSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzE3XS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogNDMgfTsvLyBSTk0oUmVwT3ApXG4gIHRoaXMucnVsZXNbMTddLm9wY29kZXNbNV0gPSB7IHR5cGU6IDQsIGluZGV4OiA0MyB9Oy8vIFJOTShSZXBPcClcblxuICAvKiBQcmVkaWNhdGUgKi9cbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE4XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiA0OSB9Oy8vIFJOTShCa2FPcClcbiAgdGhpcy5ydWxlc1sxOF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDUwIH07Ly8gUk5NKEJrbk9wKVxuICB0aGlzLnJ1bGVzWzE4XS5vcGNvZGVzWzNdID0geyB0eXBlOiA0LCBpbmRleDogNDcgfTsvLyBSTk0oQW5kT3ApXG4gIHRoaXMucnVsZXNbMThdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiA0OCB9Oy8vIFJOTShOb3RPcClcblxuICAvKiBCYXNpY0VsZW1lbnQgKi9cbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzE5XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDQsNSw2LDcsOCw5LDEwXSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzE5XS5vcGNvZGVzWzFdID0geyB0eXBlOiA0LCBpbmRleDogNDAgfTsvLyBSTk0oVWR0T3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbMl0gPSB7IHR5cGU6IDQsIGluZGV4OiAyOSB9Oy8vIFJOTShSbm1PcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNCwgaW5kZXg6IDUzIH07Ly8gUk5NKFRyZ09wKVxuICB0aGlzLnJ1bGVzWzE5XS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogNTQgfTsvLyBSTk0oVGJzT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbNV0gPSB7IHR5cGU6IDQsIGluZGV4OiA1NSB9Oy8vIFJOTShUbHNPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNCwgaW5kZXg6IDYxIH07Ly8gUk5NKENsc09wKVxuICB0aGlzLnJ1bGVzWzE5XS5vcGNvZGVzWzddID0geyB0eXBlOiA0LCBpbmRleDogMzAgfTsvLyBSTk0oQmtyT3ApXG4gIHRoaXMucnVsZXNbMTldLm9wY29kZXNbOF0gPSB7IHR5cGU6IDQsIGluZGV4OiA1MSB9Oy8vIFJOTShBYmdPcClcbiAgdGhpcy5ydWxlc1sxOV0ub3Bjb2Rlc1s5XSA9IHsgdHlwZTogNCwgaW5kZXg6IDUyIH07Ly8gUk5NKEFlbk9wKVxuICB0aGlzLnJ1bGVzWzE5XS5vcGNvZGVzWzEwXSA9IHsgdHlwZTogNCwgaW5kZXg6IDY1IH07Ly8gUk5NKFByb3NWYWwpXG5cbiAgLyogQmFzaWNFbGVtZW50RXJyICovXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNSwgbWluOiAzMywgbWF4OiA0MCB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIwXS5vcGNvZGVzWzNdID0geyB0eXBlOiA1LCBtaW46IDQyLCBtYXg6IDQ2IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjBdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDUsIG1pbjogNDgsIG1heDogOTIgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syMF0ub3Bjb2Rlc1s1XSA9IHsgdHlwZTogNSwgbWluOiA5NCwgbWF4OiAxMjYgfTsvLyBUUkdcblxuICAvKiBHcm91cCAqL1xuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwyLDNdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiAyMyB9Oy8vIFJOTShHcm91cE9wZW4pXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDQsIGluZGV4OiAxNCB9Oy8vIFJOTShBbHRlcm5hdGlvbilcbiAgdGhpcy5ydWxlc1syMV0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFs0LDVdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMjFdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiAyNCB9Oy8vIFJOTShHcm91cENsb3NlKVxuICB0aGlzLnJ1bGVzWzIxXS5vcGNvZGVzWzVdID0geyB0eXBlOiA0LCBpbmRleDogMjIgfTsvLyBSTk0oR3JvdXBFcnJvcilcblxuICAvKiBHcm91cEVycm9yICovXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDQsNV0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNSwgbWluOiAzMywgbWF4OiA0MCB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzIyXS5vcGNvZGVzWzNdID0geyB0eXBlOiA1LCBtaW46IDQyLCBtYXg6IDQ2IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjJdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDUsIG1pbjogNDgsIG1heDogOTIgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syMl0ub3Bjb2Rlc1s1XSA9IHsgdHlwZTogNSwgbWluOiA5NCwgbWF4OiAxMjYgfTsvLyBUUkdcblxuICAvKiBHcm91cE9wZW4gKi9cbiAgdGhpcy5ydWxlc1syM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzIzXS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syM10ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbNDBdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMjNdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDQsIGluZGV4OiA4OSB9Oy8vIFJOTShvd3NwKVxuXG4gIC8qIEdyb3VwQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI0XS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syNF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg5IH07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMjRdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzQxXSB9Oy8vIFRCU1xuXG4gIC8qIE9wdGlvbiAqL1xuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwyLDNdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiAyNyB9Oy8vIFJOTShPcHRpb25PcGVuKVxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogMTQgfTsvLyBSTk0oQWx0ZXJuYXRpb24pXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbM10gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbNCw1XSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzI1XS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogMjggfTsvLyBSTk0oT3B0aW9uQ2xvc2UpXG4gIHRoaXMucnVsZXNbMjVdLm9wY29kZXNbNV0gPSB7IHR5cGU6IDQsIGluZGV4OiAyNiB9Oy8vIFJOTShPcHRpb25FcnJvcilcblxuICAvKiBPcHRpb25FcnJvciAqL1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzFdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0LDVdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDUsIG1pbjogMzMsIG1heDogNDAgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1syNl0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNSwgbWluOiA0MiwgbWF4OiA0NiB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzI2XS5vcGNvZGVzWzRdID0geyB0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDkyIH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbMjZdLm9wY29kZXNbNV0gPSB7IHR5cGU6IDUsIG1pbjogOTQsIG1heDogMTI2IH07Ly8gVFJHXG5cbiAgLyogT3B0aW9uT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbMjddLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzI3XS5vcGNvZGVzWzFdID0geyB0eXBlOiA2LCBzdHJpbmc6IFs5MV0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1syN10ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg5IH07Ly8gUk5NKG93c3ApXG5cbiAgLyogT3B0aW9uQ2xvc2UgKi9cbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzI4XS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1syOF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg5IH07Ly8gUk5NKG93c3ApXG4gIHRoaXMucnVsZXNbMjhdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzkzXSB9Oy8vIFRCU1xuXG4gIC8qIFJubU9wICovXG4gIHRoaXMucnVsZXNbMjldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syOV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg4IH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIEJrck9wICovXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDIsNF0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1szMF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbOTJdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiAxIH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzBdLm9wY29kZXNbM10gPSB7IHR5cGU6IDQsIGluZGV4OiAzMSB9Oy8vIFJOTShia3JNb2RpZmllcilcbiAgdGhpcy5ydWxlc1szMF0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDM2IH07Ly8gUk5NKGJrci1uYW1lKVxuXG4gIC8qIGJrck1vZGlmaWVyICovXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsxLDcsMTMsMTldIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMiwzXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogMzIgfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbM10gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiAxIH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbNSw2XSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzVdID0geyB0eXBlOiA0LCBpbmRleDogMzQgfTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbNl0gPSB7IHR5cGU6IDQsIGluZGV4OiAzNSB9Oy8vIFJOTShwbSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s3XSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFs4LDldIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbOF0gPSB7IHR5cGU6IDQsIGluZGV4OiAzMyB9Oy8vIFJOTShjaSlcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1s5XSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IDEgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxMF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMTEsMTJdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTFdID0geyB0eXBlOiA0LCBpbmRleDogMzQgfTsvLyBSTk0odW0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTJdID0geyB0eXBlOiA0LCBpbmRleDogMzUgfTsvLyBSTk0ocG0pXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTNdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzE0LDE1XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDM0IH07Ly8gUk5NKHVtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzE1XSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IDEgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1sxNl0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMTcsMThdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTddID0geyB0eXBlOiA0LCBpbmRleDogMzIgfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMThdID0geyB0eXBlOiA0LCBpbmRleDogMzMgfTsvLyBSTk0oY2kpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMTldID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzIwLDIxXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzIwXSA9IHsgdHlwZTogNCwgaW5kZXg6IDM1IH07Ly8gUk5NKHBtKVxuICB0aGlzLnJ1bGVzWzMxXS5vcGNvZGVzWzIxXSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IDEgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szMV0ub3Bjb2Rlc1syMl0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMjMsMjRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjNdID0geyB0eXBlOiA0LCBpbmRleDogMzIgfTsvLyBSTk0oY3MpXG4gIHRoaXMucnVsZXNbMzFdLm9wY29kZXNbMjRdID0geyB0eXBlOiA0LCBpbmRleDogMzMgfTsvLyBSTk0oY2kpXG5cbiAgLyogY3MgKi9cbiAgdGhpcy5ydWxlc1szMl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzMyXS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszNywxMTVdIH07Ly8gVEJTXG5cbiAgLyogY2kgKi9cbiAgdGhpcy5ydWxlc1szM10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzMzXS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszNywxMDVdIH07Ly8gVEJTXG5cbiAgLyogdW0gKi9cbiAgdGhpcy5ydWxlc1szNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM0XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszNywxMTddIH07Ly8gVEJTXG5cbiAgLyogcG0gKi9cbiAgdGhpcy5ydWxlc1szNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM1XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszNywxMTJdIH07Ly8gVEJTXG5cbiAgLyogYmtyLW5hbWUgKi9cbiAgdGhpcy5ydWxlc1szNl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzXSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzM2XS5vcGNvZGVzWzFdID0geyB0eXBlOiA0LCBpbmRleDogMzggfTsvLyBSTk0odW5hbWUpXG4gIHRoaXMucnVsZXNbMzZdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDQsIGluZGV4OiAzOSB9Oy8vIFJOTShlbmFtZSlcbiAgdGhpcy5ydWxlc1szNl0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNCwgaW5kZXg6IDM3IH07Ly8gUk5NKHJuYW1lKVxuXG4gIC8qIHJuYW1lICovXG4gIHRoaXMucnVsZXNbMzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szN10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg4IH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIHVuYW1lICovXG4gIHRoaXMucnVsZXNbMzhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzhdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzExNyw5NV0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg4IH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIGVuYW1lICovXG4gIHRoaXMucnVsZXNbMzldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbMzldLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzEwMSw5NV0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1szOV0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg4IH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIFVkdE9wICovXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0MF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiA0MiB9Oy8vIFJOTSh1ZHQtZW1wdHkpXG4gIHRoaXMucnVsZXNbNDBdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDQsIGluZGV4OiA0MSB9Oy8vIFJOTSh1ZHQtbm9uLWVtcHR5KVxuXG4gIC8qIHVkdC1ub24tZW1wdHkgKi9cbiAgdGhpcy5ydWxlc1s0MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0MV0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbMTE3LDk1XSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzQxXS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogODggfTsvLyBSTk0oYWxwaGFudW0pXG5cbiAgLyogdWR0LWVtcHR5ICovXG4gIHRoaXMucnVsZXNbNDJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNDJdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzEwMSw5NV0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s0Ml0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg4IH07Ly8gUk5NKGFscGhhbnVtKVxuXG4gIC8qIFJlcE9wICovXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsxLDUsOCwxMSwxMl0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsyLDMsNF0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDY5IH07Ly8gUk5NKHJlcC1taW4pXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbM10gPSB7IHR5cGU6IDQsIGluZGV4OiA0NiB9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiA3MSB9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzVdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzYsN10gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNCwgaW5kZXg6IDY5IH07Ly8gUk5NKHJlcC1taW4pXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbN10gPSB7IHR5cGU6IDQsIGluZGV4OiA0NiB9Oy8vIFJOTShTdGFyT3ApXG4gIHRoaXMucnVsZXNbNDNdLm9wY29kZXNbOF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbOSwxMF0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1s5XSA9IHsgdHlwZTogNCwgaW5kZXg6IDQ2IH07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1sxMF0gPSB7IHR5cGU6IDQsIGluZGV4OiA3MSB9Oy8vIFJOTShyZXAtbWF4KVxuICB0aGlzLnJ1bGVzWzQzXS5vcGNvZGVzWzExXSA9IHsgdHlwZTogNCwgaW5kZXg6IDQ2IH07Ly8gUk5NKFN0YXJPcClcbiAgdGhpcy5ydWxlc1s0M10ub3Bjb2Rlc1sxMl0gPSB7IHR5cGU6IDQsIGluZGV4OiA3MCB9Oy8vIFJOTShyZXAtbWluLW1heClcblxuICAvKiBBbHRPcCAqL1xuICB0aGlzLnJ1bGVzWzQ0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDRdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzQ0XS5vcGNvZGVzWzFdID0geyB0eXBlOiA2LCBzdHJpbmc6IFs0N10gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s0NF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg5IH07Ly8gUk5NKG93c3ApXG5cbiAgLyogQ2F0T3AgKi9cbiAgdGhpcy5ydWxlc1s0NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzQ1XS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogOTAgfTsvLyBSTk0od3NwKVxuXG4gIC8qIFN0YXJPcCAqL1xuICB0aGlzLnJ1bGVzWzQ2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDZdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzQyXSB9Oy8vIFRCU1xuXG4gIC8qIEFuZE9wICovXG4gIHRoaXMucnVsZXNbNDddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s0N10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbMzhdIH07Ly8gVEJTXG5cbiAgLyogTm90T3AgKi9cbiAgdGhpcy5ydWxlc1s0OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzQ4XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszM10gfTsvLyBUQlNcblxuICAvKiBCa2FPcCAqL1xuICB0aGlzLnJ1bGVzWzQ5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNDldLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzM4LDM4XSB9Oy8vIFRCU1xuXG4gIC8qIEJrbk9wICovXG4gIHRoaXMucnVsZXNbNTBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1MF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbMzMsMzNdIH07Ly8gVEJTXG5cbiAgLyogQWJnT3AgKi9cbiAgdGhpcy5ydWxlc1s1MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzUxXS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszNyw5NF0gfTsvLyBUQlNcblxuICAvKiBBZW5PcCAqL1xuICB0aGlzLnJ1bGVzWzUyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTJdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzM3LDM2XSB9Oy8vIFRCU1xuXG4gIC8qIFRyZ09wICovXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzM3XSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzJdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzMsOCwxM10gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1szXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFs0LDUsNiw3XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogNzYgfTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzVdID0geyB0eXBlOiA0LCBpbmRleDogNzkgfTsvLyBSTk0oZG1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbNDVdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbN10gPSB7IHR5cGU6IDQsIGluZGV4OiA4MCB9Oy8vIFJOTShkbWF4KVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzhdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzksMTAsMTEsMTJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbOV0gPSB7IHR5cGU6IDQsIGluZGV4OiA3NyB9Oy8vIFJOTShIZXgpXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTBdID0geyB0eXBlOiA0LCBpbmRleDogODMgfTsvLyBSTk0oeG1pbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzQ1XSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzEyXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg0IH07Ly8gUk5NKHhtYXgpXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTNdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzE0LDE1LDE2LDE3XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzE0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDc4IH07Ly8gUk5NKEJpbilcbiAgdGhpcy5ydWxlc1s1M10ub3Bjb2Rlc1sxNV0gPSB7IHR5cGU6IDQsIGluZGV4OiA4MSB9Oy8vIFJOTShibWluKVxuICB0aGlzLnJ1bGVzWzUzXS5vcGNvZGVzWzE2XSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbNDVdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTNdLm9wY29kZXNbMTddID0geyB0eXBlOiA0LCBpbmRleDogODIgfTsvLyBSTk0oYm1heClcblxuICAvKiBUYnNPcCAqL1xuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwyXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzFdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszN10gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFszLDEwLDE3XSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzNdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzQsNSw2XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogNzYgfTsvLyBSTk0oRGVjKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzVdID0geyB0eXBlOiA0LCBpbmRleDogNzMgfTsvLyBSTk0oZFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbN10gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbOCw5XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzhdID0geyB0eXBlOiA2LCBzdHJpbmc6IFs0Nl0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1s5XSA9IHsgdHlwZTogNCwgaW5kZXg6IDczIH07Ly8gUk5NKGRTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzExLDEyLDEzXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzExXSA9IHsgdHlwZTogNCwgaW5kZXg6IDc3IH07Ly8gUk5NKEhleClcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxMl0gPSB7IHR5cGU6IDQsIGluZGV4OiA3NCB9Oy8vIFJOTSh4U3RyaW5nKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzEzXSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTRdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzE1LDE2XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE1XSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbNDZdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMTZdID0geyB0eXBlOiA0LCBpbmRleDogNzQgfTsvLyBSTk0oeFN0cmluZylcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1sxN10gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMTgsMTksMjBdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMThdID0geyB0eXBlOiA0LCBpbmRleDogNzggfTsvLyBSTk0oQmluKVxuICB0aGlzLnJ1bGVzWzU0XS5vcGNvZGVzWzE5XSA9IHsgdHlwZTogNCwgaW5kZXg6IDc1IH07Ly8gUk5NKGJTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjBdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syMV0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMjIsMjNdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNTRdLm9wY29kZXNbMjJdID0geyB0eXBlOiA2LCBzdHJpbmc6IFs0Nl0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s1NF0ub3Bjb2Rlc1syM10gPSB7IHR5cGU6IDQsIGluZGV4OiA3NSB9Oy8vIFJOTShiU3RyaW5nKVxuXG4gIC8qIFRsc09wICovXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDIsMyw0XSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzU1XS5vcGNvZGVzWzFdID0geyB0eXBlOiA0LCBpbmRleDogNTYgfTsvLyBSTk0oVGxzQ2FzZSlcbiAgdGhpcy5ydWxlc1s1NV0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDU3IH07Ly8gUk5NKFRsc09wZW4pXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbM10gPSB7IHR5cGU6IDQsIGluZGV4OiA1OSB9Oy8vIFJOTShUbHNTdHJpbmcpXG4gIHRoaXMucnVsZXNbNTVdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiA1OCB9Oy8vIFJOTShUbHNDbG9zZSlcblxuICAvKiBUbHNDYXNlICovXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IDEgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsyLDNdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNTZdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDcsIHN0cmluZzogWzM3LDEwNV0gfTsvLyBUTFNcbiAgdGhpcy5ydWxlc1s1Nl0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNywgc3RyaW5nOiBbMzcsMTE1XSB9Oy8vIFRMU1xuXG4gIC8qIFRsc09wZW4gKi9cbiAgdGhpcy5ydWxlc1s1N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzU3XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszNF0gfTsvLyBUQlNcblxuICAvKiBUbHNDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzU4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNThdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzM0XSB9Oy8vIFRCU1xuXG4gIC8qIFRsc1N0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbMF0gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzWzFdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzIsMyw0XSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzU5XS5vcGNvZGVzWzJdID0geyB0eXBlOiA1LCBtaW46IDMyLCBtYXg6IDMzIH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbM10gPSB7IHR5cGU6IDUsIG1pbjogMzUsIG1heDogMTI2IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNTldLm9wY29kZXNbNF0gPSB7IHR5cGU6IDQsIGluZGV4OiA2MCB9Oy8vIFJOTShTdHJpbmdUYWIpXG5cbiAgLyogU3RyaW5nVGFiICovXG4gIHRoaXMucnVsZXNbNjBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2MF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbOV0gfTsvLyBUQlNcblxuICAvKiBDbHNPcCAqL1xuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwyLDNdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbNjFdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiA2MiB9Oy8vIFJOTShDbHNPcGVuKVxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogNjQgfTsvLyBSTk0oQ2xzU3RyaW5nKVxuICB0aGlzLnJ1bGVzWzYxXS5vcGNvZGVzWzNdID0geyB0eXBlOiA0LCBpbmRleDogNjMgfTsvLyBSTk0oQ2xzQ2xvc2UpXG5cbiAgLyogQ2xzT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzYyXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjJdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzM5XSB9Oy8vIFRCU1xuXG4gIC8qIENsc0Nsb3NlICovXG4gIHRoaXMucnVsZXNbNjNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2M10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbMzldIH07Ly8gVEJTXG5cbiAgLyogQ2xzU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbNjRdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDUsIG1pbjogMzIsIG1heDogMzggfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNSwgbWluOiA0MCwgbWF4OiAxMjYgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s2NF0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDYwIH07Ly8gUk5NKFN0cmluZ1RhYilcblxuICAvKiBQcm9zVmFsICovXG4gIHRoaXMucnVsZXNbNjVdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDIsM10gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDY2IH07Ly8gUk5NKFByb3NWYWxPcGVuKVxuICB0aGlzLnJ1bGVzWzY1XS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogNjcgfTsvLyBSTk0oUHJvc1ZhbFN0cmluZylcbiAgdGhpcy5ydWxlc1s2NV0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNCwgaW5kZXg6IDY4IH07Ly8gUk5NKFByb3NWYWxDbG9zZSlcblxuICAvKiBQcm9zVmFsT3BlbiAqL1xuICB0aGlzLnJ1bGVzWzY2XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjZdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzYwXSB9Oy8vIFRCU1xuXG4gIC8qIFByb3NWYWxTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s2N10ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNSwgbWluOiAzMiwgbWF4OiA2MSB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzNdID0geyB0eXBlOiA1LCBtaW46IDYzLCBtYXg6IDEyNiB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzY3XS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogNjAgfTsvLyBSTk0oU3RyaW5nVGFiKVxuXG4gIC8qIFByb3NWYWxDbG9zZSAqL1xuICB0aGlzLnJ1bGVzWzY4XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNjhdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzYyXSB9Oy8vIFRCU1xuXG4gIC8qIHJlcC1taW4gKi9cbiAgdGhpcy5ydWxlc1s2OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzY5XS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogNzIgfTsvLyBSTk0ocmVwLW51bSlcblxuICAvKiByZXAtbWluLW1heCAqL1xuICB0aGlzLnJ1bGVzWzcwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzBdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDQsIGluZGV4OiA3MiB9Oy8vIFJOTShyZXAtbnVtKVxuXG4gIC8qIHJlcC1tYXggKi9cbiAgdGhpcy5ydWxlc1s3MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzcxXS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogNzIgfTsvLyBSTk0ocmVwLW51bSlcblxuICAvKiByZXAtbnVtICovXG4gIHRoaXMucnVsZXNbNzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3Ml0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMywgbWluOiAxLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbNzJdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDUsIG1pbjogNDgsIG1heDogNTcgfTsvLyBUUkdcblxuICAvKiBkU3RyaW5nICovXG4gIHRoaXMucnVsZXNbNzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3M10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg1IH07Ly8gUk5NKGRudW0pXG5cbiAgLyogeFN0cmluZyAqL1xuICB0aGlzLnJ1bGVzWzc0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbNzRdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDQsIGluZGV4OiA4NyB9Oy8vIFJOTSh4bnVtKVxuXG4gIC8qIGJTdHJpbmcgKi9cbiAgdGhpcy5ydWxlc1s3NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc1XS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogODYgfTsvLyBSTk0oYm51bSlcblxuICAvKiBEZWMgKi9cbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc2XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3Nl0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbNjhdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNzZdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzEwMF0gfTsvLyBUQlNcblxuICAvKiBIZXggKi9cbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc3XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3N10ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbODhdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNzddLm9wY29kZXNbMl0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzEyMF0gfTsvLyBUQlNcblxuICAvKiBCaW4gKi9cbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc4XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s3OF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbNjZdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbNzhdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzk4XSB9Oy8vIFRCU1xuXG4gIC8qIGRtaW4gKi9cbiAgdGhpcy5ydWxlc1s3OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzc5XS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogODUgfTsvLyBSTk0oZG51bSlcblxuICAvKiBkbWF4ICovXG4gIHRoaXMucnVsZXNbODBdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4MF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg1IH07Ly8gUk5NKGRudW0pXG5cbiAgLyogYm1pbiAqL1xuICB0aGlzLnJ1bGVzWzgxXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODFdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDQsIGluZGV4OiA4NiB9Oy8vIFJOTShibnVtKVxuXG4gIC8qIGJtYXggKi9cbiAgdGhpcy5ydWxlc1s4Ml0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzgyXS5vcGNvZGVzWzBdID0geyB0eXBlOiA0LCBpbmRleDogODYgfTsvLyBSTk0oYm51bSlcblxuICAvKiB4bWluICovXG4gIHRoaXMucnVsZXNbODNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4M10ub3Bjb2Rlc1swXSA9IHsgdHlwZTogNCwgaW5kZXg6IDg3IH07Ly8gUk5NKHhudW0pXG5cbiAgLyogeG1heCAqL1xuICB0aGlzLnJ1bGVzWzg0XS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbODRdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDQsIGluZGV4OiA4NyB9Oy8vIFJOTSh4bnVtKVxuXG4gIC8qIGRudW0gKi9cbiAgdGhpcy5ydWxlc1s4NV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg1XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4NV0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNSwgbWluOiA0OCwgbWF4OiA1NyB9Oy8vIFRSR1xuXG4gIC8qIGJudW0gKi9cbiAgdGhpcy5ydWxlc1s4Nl0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg2XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4Nl0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNSwgbWluOiA0OCwgbWF4OiA0OSB9Oy8vIFRSR1xuXG4gIC8qIHhudW0gKi9cbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsyLDMsNF0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4N10ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNSwgbWluOiA0OCwgbWF4OiA1NyB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzg3XS5vcGNvZGVzWzNdID0geyB0eXBlOiA1LCBtaW46IDY1LCBtYXg6IDcwIH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODddLm9wY29kZXNbNF0gPSB7IHR5cGU6IDUsIG1pbjogOTcsIG1heDogMTAyIH07Ly8gVFJHXG5cbiAgLyogYWxwaGFudW0gKi9cbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsNF0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFsyLDNdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDUsIG1pbjogOTcsIG1heDogMTIyIH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbM10gPSB7IHR5cGU6IDUsIG1pbjogNjUsIG1heDogOTAgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IEluZmluaXR5IH07Ly8gUkVQXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbNV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbNiw3LDgsOV0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s2XSA9IHsgdHlwZTogNSwgbWluOiA5NywgbWF4OiAxMjIgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s4OF0ub3Bjb2Rlc1s3XSA9IHsgdHlwZTogNSwgbWluOiA2NSwgbWF4OiA5MCB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzg4XS5vcGNvZGVzWzhdID0geyB0eXBlOiA1LCBtaW46IDQ4LCBtYXg6IDU3IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbODhdLm9wY29kZXNbOV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzQ1XSB9Oy8vIFRCU1xuXG4gIC8qIG93c3AgKi9cbiAgdGhpcy5ydWxlc1s4OV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzg5XS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s4OV0ub3Bjb2Rlc1sxXSA9IHsgdHlwZTogNCwgaW5kZXg6IDkxIH07Ly8gUk5NKHNwYWNlKVxuXG4gIC8qIHdzcCAqL1xuICB0aGlzLnJ1bGVzWzkwXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTBdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDMsIG1pbjogMSwgbWF4OiBJbmZpbml0eSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzkwXS5vcGNvZGVzWzFdID0geyB0eXBlOiA0LCBpbmRleDogOTEgfTsvLyBSTk0oc3BhY2UpXG5cbiAgLyogc3BhY2UgKi9cbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzLDRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTFdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzMyXSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzWzJdID0geyB0eXBlOiA2LCBzdHJpbmc6IFs5XSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkxXS5vcGNvZGVzWzNdID0geyB0eXBlOiA0LCBpbmRleDogOTIgfTsvLyBSTk0oY29tbWVudClcbiAgdGhpcy5ydWxlc1s5MV0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNCwgaW5kZXg6IDk0IH07Ly8gUk5NKExpbmVDb250aW51ZSlcblxuICAvKiBjb21tZW50ICovXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDJdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzU5XSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkyXS5vcGNvZGVzWzJdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1s5Ml0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogMSwgY2hpbGRyZW46IFs0LDVdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbNF0gPSB7IHR5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbOTJdLm9wY29kZXNbNV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzldIH07Ly8gVEJTXG5cbiAgLyogTGluZUVuZCAqL1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzID0gW107XG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDNdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTNdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzEzLDEwXSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzkzXS5vcGNvZGVzWzJdID0geyB0eXBlOiA2LCBzdHJpbmc6IFsxMF0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5M10ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbMTNdIH07Ly8gVEJTXG5cbiAgLyogTGluZUNvbnRpbnVlICovXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1swXSA9IHsgdHlwZTogMiwgY2hpbGRyZW46IFsxLDVdIH07Ly8gQ0FUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMiwzLDRdIH07Ly8gQUxUXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDYsIHN0cmluZzogWzEzLDEwXSB9Oy8vIFRCU1xuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzNdID0geyB0eXBlOiA2LCBzdHJpbmc6IFsxMF0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbMTNdIH07Ly8gVEJTXG4gIHRoaXMucnVsZXNbOTRdLm9wY29kZXNbNV0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbNiw3XSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzk0XS5vcGNvZGVzWzZdID0geyB0eXBlOiA2LCBzdHJpbmc6IFszMl0gfTsvLyBUQlNcbiAgdGhpcy5ydWxlc1s5NF0ub3Bjb2Rlc1s3XSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbOV0gfTsvLyBUQlNcblxuICAvLyBUaGUgYHRvU3RyaW5nKClgIGZ1bmN0aW9uIHdpbGwgZGlzcGxheSB0aGUgb3JpZ2luYWwgZ3JhbW1hciBmaWxlKHMpIHRoYXQgcHJvZHVjZWQgdGhlc2Ugb3Bjb2Rlcy5cbiAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgQUJORiBmb3IgSmF2YVNjcmlwdCBBUEcgMi4wIFNBQk5GXFxuXCI7XG4gICAgc3RyICs9IFwiOyBSRkMgNTIzNCB3aXRoIHNvbWUgcmVzdHJpY3Rpb25zIGFuZCBhZGRpdGlvbnMuXFxuXCI7XG4gICAgc3RyICs9IFwiOyBVcGRhdGVkIDExLzI0LzIwMTUgZm9yIFJGQyA3NDA1IGNhc2Utc2Vuc2l0aXZlIGxpdGVyYWwgc3RyaW5nIG5vdGF0aW9uXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzICVzXFxcInN0cmluZ1xcXCIgYXMgYSBjYXNlLXNlbnNpdGl2ZSBzdHJpbmdcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAtIGFjY2VwdHMgJWlcXFwic3RyaW5nXFxcIiBhcyBhIGNhc2UtaW5zZW5zaXRpdmUgc3RyaW5nXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgLSBhY2NlcHRzIFxcXCJzdHJpbmdcXFwiIGFzIGEgY2FzZS1pbnNlbnNpdGl2ZSBzdHJpbmdcXG5cIjtcbiAgICBzdHIgKz0gXCI7XFxuXCI7XG4gICAgc3RyICs9IFwiOyBTb21lIHJlc3RyaWN0aW9uczpcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMS4gUnVsZXMgbXVzdCBiZWdpbiBhdCBmaXJzdCBjaGFyYWN0ZXIgb2YgZWFjaCBsaW5lLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbmRlbnRhdGlvbnMgb24gZmlyc3QgcnVsZSBhbmQgcnVsZXMgdGhlcmVhZnRlciBhcmUgbm90IGFsbG93ZWQuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDIuIFJlbGF4ZWQgbGluZSBlbmRpbmdzLiBDUkxGLCBMRiBvciBDUiBhcmUgYWNjZXB0ZWQgYXMgdmFsaWQgbGluZSBlbmRpbmcuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDMuIFByb3NlIHZhbHVlcywgaS5lLiA8cHJvc2UgdmFsdWU+LCBhcmUgYWNjZXB0ZWQgYXMgdmFsaWQgZ3JhbW1hciBzeW50YXguXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEhvd2V2ZXIsIGEgd29ya2luZyBwYXJzZXIgY2Fubm90IGJlIGdlbmVyYXRlZCBmcm9tIHRoZW0uXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgU3VwZXIgc2V0IChTQUJORikgYWRkaXRpb25zOlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAxLiBMb29rLWFoZWFkIChzeW50YWN0aWMgcHJlZGljYXRlKSBvcGVyYXRvcnMgYXJlIGFjY2VwdGVkIGFzIGVsZW1lbnQgcHJlZml4ZXMuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICYgaXMgdGhlIHBvc2l0aXZlIGxvb2stYWhlYWQgb3BlcmF0b3IsIHN1Y2NlZWRzIGFuZCBiYWNrdHJhY2tzIGlmIHRoZSBsb29rLWFoZWFkIHBocmFzZSBpcyBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAhIGlzIHRoZSBuZWdhdGl2ZSBsb29rLWFoZWFkIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1haGVhZCBwaHJhc2UgaXMgTk9UIGZvdW5kXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIGUuZy4gJiVkMTMgb3IgJnJ1bGUgb3IgIShBIC8gQilcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgMi4gVXNlci1EZWZpbmVkIFRlcm1pbmFscyAoVURUKSBvZiB0aGUgZm9ybSwgdV9uYW1lIGFuZCBlX25hbWUgYXJlIGFjY2VwdGVkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAnbmFtZScgaXMgYWxwaGEgZm9sbG93ZWQgYnkgYWxwaGEvbnVtL2h5cGhlbiBqdXN0IGxpa2UgYSBydWxlIG5hbWUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIHVfbmFtZSBtYXkgYmUgdXNlZCBhcyBhbiBlbGVtZW50IGJ1dCBubyBydWxlIGRlZmluaXRpb24gaXMgZ2l2ZW4uXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIGUuZy4gcnVsZSA9IEEgLyB1X215VWR0XFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgICAgICAgQSA9IFxcXCJhXFxcIlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICB3b3VsZCBiZSBhIHZhbGlkIGdyYW1tYXIuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDMuIENhc2Utc2Vuc2l0aXZlLCBzaW5nbGUtcXVvdGVkIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICdhYmMnIHdvdWxkIGJlIGVxdWl2YWxlbnQgdG8gJWQ5Ny45OC45OVxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAoa2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgYnV0IHN1cGVyc2VkZWQgYnkgJXNcXFwiYWJjXFxcIikgIFxcblwiO1xuICAgIHN0ciArPSBcIjsgTmV3IDEyLzI2LzIwMTVcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgNC4gTG9vay1iZWhpbmQgb3BlcmF0b3JzIGFyZSBhY2NlcHRlZCBhcyBlbGVtZW50IHByZWZpeGVzLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICAmJiBpcyB0aGUgcG9zaXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IsIHN1Y2NlZWRzIGFuZCBiYWNrdHJhY2tzIGlmIHRoZSBsb29rLWJlaGluZCBwaHJhc2UgaXMgZm91bmRcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgISEgaXMgdGhlIG5lZ2F0aXZlIGxvb2stYmVoaW5kIG9wZXJhdG9yLCBzdWNjZWVkcyBhbmQgYmFja3RyYWNrcyBpZiB0aGUgbG9vay1iZWhpbmQgcGhyYXNlIGlzIE5PVCBmb3VuZFxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBlLmcuICYmJWQxMyBvciAmJnJ1bGUgb3IgISEoQSAvIEIpXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDUuIEJhY2sgcmVmZXJlbmNlIG9wZXJhdG9ycywgaS5lLiBcXFxccnVsZW5hbWUsIGFyZSBhY2NlcHRlZC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQSBiYWNrIHJlZmVyZW5jZSBvcGVyYXRvciBhY3RzIGxpa2UgYSBUTFMgb3IgVEJTIHRlcm1pbmFsIGV4Y2VwdCB0aGF0IHRoZSBwaHJhc2UgaXQgYXR0ZW1wdHNcXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgdG8gbWF0Y2ggaXMgYSBwaHJhc2UgcHJldmlvdXNseSBtYXRjaGVkIGJ5IHRoZSBydWxlICdydWxlbmFtZScuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFRoZXJlIGFyZSB0d28gbW9kZXMgb2YgcHJldmlvdXMgcGhyYXNlIG1hdGNoaW5nIC0gdGhlIHBhcmVudC1mcmFtZSBtb2RlIGFuZCB0aGUgdW5pdmVyc2FsIG1vZGUuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIEluIHVuaXZlcnNhbCBtb2RlLCBcXFxccnVsZW5hbWUgbWF0Y2hlcyB0aGUgbGFzdCBtYXRjaCB0byAncnVsZW5hbWUnIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgaXQgd2FzIGZvdW5kLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBJbiBwYXJlbnQtZnJhbWUgbW9kZSwgXFxcXHJ1bGVuYW1lIG1hdGNoZXMgb25seSB0aGUgbGFzdCBtYXRjaCBmb3VuZCBvbiB0aGUgcGFyZW50J3MgZnJhbWUgb3IgcGFyc2UgdHJlZSBsZXZlbC5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgQmFjayByZWZlcmVuY2UgbW9kaWZpZXJzIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgY2FzZSBhbmQgbW9kZS5cXG5cIjtcbiAgICBzdHIgKz0gXCI7ICAgICAgXFxcXEEgZGVmYXVsdHMgdG8gY2FzZS1pbnNlbnNpdGl2ZSBhbmQgdW5pdmVyc2FsIG1vZGUsIGUuZy4gXFxcXEEgPT09IFxcXFwlaSV1QVxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBNb2RpZmllcnMgJWkgYW5kICVzIGRldGVybWluZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYXNlLXNlbnNpdGl2ZSBtb2RlLCByZXNwZWN0aXZlbHkuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIE1vZGlmaWVycyAldSBhbmQgJXAgZGV0ZXJtaW5lIHVuaXZlcnNhbCBtb2RlIGFuZCBwYXJlbnQgZnJhbWUgbW9kZSwgcmVzcGVjdGl2ZWx5LlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBDYXNlIGFuZCBtb2RlIG1vZGlmaWVycyBjYW4gYXBwZWFyIGluIGFueSBvcmRlciwgZS5nLiBcXFxcJXMlcEEgPT09IFxcXFwlcCVzQS4gXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDcuIFN0cmluZyBiZWdpbiBhbmNob3IsIEFCRyglXikgbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dCBzdHJpbmcgbG9jYXRpb24uXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgICAgIFJldHVybnMgRU1QVFkgb3IgTk9NQVRDSC4gTmV2ZXIgY29uc3VtZXMgYW55IGNoYXJhY3RlcnMuXFxuXCI7XG4gICAgc3RyICs9IFwiOyAgIDguIFN0cmluZyBlbmQgYW5jaG9yLCBBRU4oJSQpIG1hdGNoZXMgdGhlIGVuZCBvZiB0aGUgaW5wdXQgc3RyaW5nIGxvY2F0aW9uLlxcblwiO1xuICAgIHN0ciArPSBcIjsgICAgICBSZXR1cm5zIEVNUFRZIG9yIE5PTUFUQ0guIE5ldmVyIGNvbnN1bWVzIGFueSBjaGFyYWN0ZXJzLlxcblwiO1xuICAgIHN0ciArPSBcIjtcXG5cIjtcbiAgICBzdHIgKz0gXCJGaWxlICAgICAgICAgICAgPSAqKEJsYW5rTGluZSAvIFJ1bGUgLyBSdWxlRXJyb3IpXFxuXCI7XG4gICAgc3RyICs9IFwiQmxhbmtMaW5lICAgICAgID0gKiglZDMyLyVkOSkgW2NvbW1lbnRdIExpbmVFbmRcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlICAgICAgICAgICAgPSBSdWxlTG9va3VwIG93c3AgQWx0ZXJuYXRpb24gKChvd3NwIExpbmVFbmQpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gKExpbmVFbmRFcnJvciBMaW5lRW5kKSlcXG5cIjtcbiAgICBzdHIgKz0gXCJSdWxlTG9va3VwICAgICAgPSBSdWxlTmFtZVRlc3Qgb3dzcCBEZWZpbmVkQXNUZXN0XFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZU5hbWVUZXN0ICAgID0gUnVsZU5hbWUvUnVsZU5hbWVFcnJvclxcblwiO1xuICAgIHN0ciArPSBcIlJ1bGVOYW1lICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZU5hbWVFcnJvciAgID0gMSooJWQzMy02MC8lZDYyLTEyNilcXG5cIjtcbiAgICBzdHIgKz0gXCJEZWZpbmVkQXNUZXN0ICAgPSBEZWZpbmVkQXMgLyBEZWZpbmVkQXNFcnJvclxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWRBc0Vycm9yICA9IDEqMiVkMzMtMTI2XFxuXCI7XG4gICAgc3RyICs9IFwiRGVmaW5lZEFzICAgICAgID0gSW5jQWx0IC8gRGVmaW5lZFxcblwiO1xuICAgIHN0ciArPSBcIkRlZmluZWQgICAgICAgICA9ICVkNjFcXG5cIjtcbiAgICBzdHIgKz0gXCJJbmNBbHQgICAgICAgICAgPSAlZDYxLjQ3XFxuXCI7XG4gICAgc3RyICs9IFwiUnVsZUVycm9yICAgICAgID0gMSooJWQzMi0xMjYgLyAlZDkgIC8gTGluZUNvbnRpbnVlKSBMaW5lRW5kXFxuXCI7XG4gICAgc3RyICs9IFwiTGluZUVuZEVycm9yICAgID0gMSooJWQzMi0xMjYgLyAlZDkgIC8gTGluZUNvbnRpbnVlKVxcblwiO1xuICAgIHN0ciArPSBcIkFsdGVybmF0aW9uICAgICA9IENvbmNhdGVuYXRpb24gKihvd3NwIEFsdE9wIENvbmNhdGVuYXRpb24pXFxuXCI7XG4gICAgc3RyICs9IFwiQ29uY2F0ZW5hdGlvbiAgID0gUmVwZXRpdGlvbiAqKENhdE9wIFJlcGV0aXRpb24pXFxuXCI7XG4gICAgc3RyICs9IFwiUmVwZXRpdGlvbiAgICAgID0gW01vZGlmaWVyXSAoR3JvdXAgLyBPcHRpb24gLyBCYXNpY0VsZW1lbnQgLyBCYXNpY0VsZW1lbnRFcnIpXFxuXCI7XG4gICAgc3RyICs9IFwiTW9kaWZpZXIgICAgICAgID0gKFByZWRpY2F0ZSBbUmVwT3BdKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFJlcE9wXFxuXCI7XG4gICAgc3RyICs9IFwiUHJlZGljYXRlICAgICAgID0gQmthT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBCa25PcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFuZE9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gTm90T3BcXG5cIjtcbiAgICBzdHIgKz0gXCJCYXNpY0VsZW1lbnQgICAgPSBVZHRPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFJubU9wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gVHJnT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBUYnNPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIFRsc09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQ2xzT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBCa3JPcFxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIEFiZ09wXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gQWVuT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBQcm9zVmFsXFxuXCI7XG4gICAgc3RyICs9IFwiQmFzaWNFbGVtZW50RXJyID0gMSooJWQzMy00MC8lZDQyLTQ2LyVkNDgtOTIvJWQ5NC0xMjYpXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXAgICAgICAgICAgID0gR3JvdXBPcGVuICBBbHRlcm5hdGlvbiAoR3JvdXBDbG9zZSAvIEdyb3VwRXJyb3IpXFxuXCI7XG4gICAgc3RyICs9IFwiR3JvdXBFcnJvciAgICAgID0gMSooJWQzMy00MC8lZDQyLTQ2LyVkNDgtOTIvJWQ5NC0xMjYpIDsgc2FtZSBhcyBCYXNpY0VsZW1lbnRFcnJcXG5cIjtcbiAgICBzdHIgKz0gXCJHcm91cE9wZW4gICAgICAgPSAlZDQwIG93c3BcXG5cIjtcbiAgICBzdHIgKz0gXCJHcm91cENsb3NlICAgICAgPSBvd3NwICVkNDFcXG5cIjtcbiAgICBzdHIgKz0gXCJPcHRpb24gICAgICAgICAgPSBPcHRpb25PcGVuIEFsdGVybmF0aW9uIChPcHRpb25DbG9zZSAvIE9wdGlvbkVycm9yKVxcblwiO1xuICAgIHN0ciArPSBcIk9wdGlvbkVycm9yICAgICA9IDEqKCVkMzMtNDAvJWQ0Mi00Ni8lZDQ4LTkyLyVkOTQtMTI2KSA7IHNhbWUgYXMgQmFzaWNFbGVtZW50RXJyXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uT3BlbiAgICAgID0gJWQ5MSBvd3NwXFxuXCI7XG4gICAgc3RyICs9IFwiT3B0aW9uQ2xvc2UgICAgID0gb3dzcCAlZDkzXFxuXCI7XG4gICAgc3RyICs9IFwiUm5tT3AgICAgICAgICAgID0gYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJCa3JPcCAgICAgICAgICAgPSAlZDkyIFtia3JNb2RpZmllcl0gYmtyLW5hbWVcXG5cIjtcbiAgICBzdHIgKz0gXCJia3JNb2RpZmllciAgICAgPSAoY3MgW3VtIC8gcG1dKSAvIChjaSBbdW0gLyBwbV0pIC8gKHVtIFtjcyAvY2ldKSAvIChwbSBbY3MgLyBjaV0pXFxuXCI7XG4gICAgc3RyICs9IFwiY3MgICAgICAgICAgICAgID0gJyVzJ1xcblwiO1xuICAgIHN0ciArPSBcImNpICAgICAgICAgICAgICA9ICclaSdcXG5cIjtcbiAgICBzdHIgKz0gXCJ1bSAgICAgICAgICAgICAgPSAnJXUnXFxuXCI7XG4gICAgc3RyICs9IFwicG0gICAgICAgICAgICAgID0gJyVwJ1xcblwiO1xuICAgIHN0ciArPSBcImJrci1uYW1lICAgICAgICA9IHVuYW1lIC8gZW5hbWUgLyBybmFtZVxcblwiO1xuICAgIHN0ciArPSBcInJuYW1lICAgICAgICAgICA9IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwidW5hbWUgICAgICAgICAgID0gJWQxMTcuOTUgYWxwaGFudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJlbmFtZSAgICAgICAgICAgPSAlZDEwMS45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcIlVkdE9wICAgICAgICAgICA9IHVkdC1lbXB0eVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIHVkdC1ub24tZW1wdHlcXG5cIjtcbiAgICBzdHIgKz0gXCJ1ZHQtbm9uLWVtcHR5ICAgPSAlZDExNy45NSBhbHBoYW51bVxcblwiO1xuICAgIHN0ciArPSBcInVkdC1lbXB0eSAgICAgICA9ICVkMTAxLjk1IGFscGhhbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiUmVwT3AgICAgICAgICAgID0gKHJlcC1taW4gU3Rhck9wIHJlcC1tYXgpXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gKHJlcC1taW4gU3Rhck9wKVxcblwiO1xuICAgIHN0ciArPSBcIiAgICAgICAgICAgICAgICAvIChTdGFyT3AgcmVwLW1heClcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBTdGFyT3BcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyByZXAtbWluLW1heFxcblwiO1xuICAgIHN0ciArPSBcIkFsdE9wICAgICAgICAgICA9ICVkNDcgb3dzcFxcblwiO1xuICAgIHN0ciArPSBcIkNhdE9wICAgICAgICAgICA9IHdzcFxcblwiO1xuICAgIHN0ciArPSBcIlN0YXJPcCAgICAgICAgICA9ICVkNDJcXG5cIjtcbiAgICBzdHIgKz0gXCJBbmRPcCAgICAgICAgICAgPSAlZDM4XFxuXCI7XG4gICAgc3RyICs9IFwiTm90T3AgICAgICAgICAgID0gJWQzM1xcblwiO1xuICAgIHN0ciArPSBcIkJrYU9wICAgICAgICAgICA9ICVkMzguMzhcXG5cIjtcbiAgICBzdHIgKz0gXCJCa25PcCAgICAgICAgICAgPSAlZDMzLjMzXFxuXCI7XG4gICAgc3RyICs9IFwiQWJnT3AgICAgICAgICAgID0gJWQzNy45NFxcblwiO1xuICAgIHN0ciArPSBcIkFlbk9wICAgICAgICAgICA9ICVkMzcuMzZcXG5cIjtcbiAgICBzdHIgKz0gXCJUcmdPcCAgICAgICAgICAgPSAlZDM3ICgoRGVjIGRtaW4gJWQ0NSBkbWF4KSAvIChIZXggeG1pbiAlZDQ1IHhtYXgpIC8gKEJpbiBibWluICVkNDUgYm1heCkpXFxuXCI7XG4gICAgc3RyICs9IFwiVGJzT3AgICAgICAgICAgID0gJWQzNyAoKERlYyBkU3RyaW5nICooJWQ0NiBkU3RyaW5nKSkgLyAoSGV4IHhTdHJpbmcgKiglZDQ2IHhTdHJpbmcpKSAvIChCaW4gYlN0cmluZyAqKCVkNDYgYlN0cmluZykpKVxcblwiO1xuICAgIHN0ciArPSBcIlRsc09wICAgICAgICAgICA9IFRsc0Nhc2UgVGxzT3BlbiBUbHNTdHJpbmcgVGxzQ2xvc2VcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNDYXNlICAgICAgICAgPSBbXFxcIiVpXFxcIiAvIFxcXCIlc1xcXCJdXFxuXCI7XG4gICAgc3RyICs9IFwiVGxzT3BlbiAgICAgICAgID0gJWQzNFxcblwiO1xuICAgIHN0ciArPSBcIlRsc0Nsb3NlICAgICAgICA9ICVkMzRcXG5cIjtcbiAgICBzdHIgKz0gXCJUbHNTdHJpbmcgICAgICAgPSAqKCVkMzItMzMvJWQzNS0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlN0cmluZ1RhYiAgICAgICA9ICVkOVxcblwiO1xuICAgIHN0ciArPSBcIkNsc09wICAgICAgICAgICA9IENsc09wZW4gQ2xzU3RyaW5nIENsc0Nsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiQ2xzT3BlbiAgICAgICAgID0gJWQzOVxcblwiO1xuICAgIHN0ciArPSBcIkNsc0Nsb3NlICAgICAgICA9ICVkMzlcXG5cIjtcbiAgICBzdHIgKz0gXCJDbHNTdHJpbmcgICAgICAgPSAqKCVkMzItMzgvJWQ0MC0xMjYvU3RyaW5nVGFiKVxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWwgICAgICAgICA9IFByb3NWYWxPcGVuIFByb3NWYWxTdHJpbmcgUHJvc1ZhbENsb3NlXFxuXCI7XG4gICAgc3RyICs9IFwiUHJvc1ZhbE9wZW4gICAgID0gJWQ2MFxcblwiO1xuICAgIHN0ciArPSBcIlByb3NWYWxTdHJpbmcgICA9ICooJWQzMi02MS8lZDYzLTEyNi9TdHJpbmdUYWIpXFxuXCI7XG4gICAgc3RyICs9IFwiUHJvc1ZhbENsb3NlICAgID0gJWQ2MlxcblwiO1xuICAgIHN0ciArPSBcInJlcC1taW4gICAgICAgICA9IHJlcC1udW1cXG5cIjtcbiAgICBzdHIgKz0gXCJyZXAtbWluLW1heCAgICAgPSByZXAtbnVtXFxuXCI7XG4gICAgc3RyICs9IFwicmVwLW1heCAgICAgICAgID0gcmVwLW51bVxcblwiO1xuICAgIHN0ciArPSBcInJlcC1udW0gICAgICAgICA9IDEqKCVkNDgtNTcpXFxuXCI7XG4gICAgc3RyICs9IFwiZFN0cmluZyAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcInhTdHJpbmcgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJiU3RyaW5nICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwiRGVjICAgICAgICAgICAgID0gKCVkNjgvJWQxMDApXFxuXCI7XG4gICAgc3RyICs9IFwiSGV4ICAgICAgICAgICAgID0gKCVkODgvJWQxMjApXFxuXCI7XG4gICAgc3RyICs9IFwiQmluICAgICAgICAgICAgID0gKCVkNjYvJWQ5OClcXG5cIjtcbiAgICBzdHIgKz0gXCJkbWluICAgICAgICAgICAgPSBkbnVtXFxuXCI7XG4gICAgc3RyICs9IFwiZG1heCAgICAgICAgICAgID0gZG51bVxcblwiO1xuICAgIHN0ciArPSBcImJtaW4gICAgICAgICAgICA9IGJudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJibWF4ICAgICAgICAgICAgPSBibnVtXFxuXCI7XG4gICAgc3RyICs9IFwieG1pbiAgICAgICAgICAgID0geG51bVxcblwiO1xuICAgIHN0ciArPSBcInhtYXggICAgICAgICAgICA9IHhudW1cXG5cIjtcbiAgICBzdHIgKz0gXCJkbnVtICAgICAgICAgICAgPSAxKiglZDQ4LTU3KVxcblwiO1xuICAgIHN0ciArPSBcImJudW0gICAgICAgICAgICA9IDEqJWQ0OC00OVxcblwiO1xuICAgIHN0ciArPSBcInhudW0gICAgICAgICAgICA9IDEqKCVkNDgtNTcgLyAlZDY1LTcwIC8gJWQ5Ny0xMDIpXFxuXCI7XG4gICAgc3RyICs9IFwiO1xcblwiO1xuICAgIHN0ciArPSBcIjsgQmFzaWNzXFxuXCI7XG4gICAgc3RyICs9IFwiYWxwaGFudW0gICAgICAgID0gKCVkOTctMTIyLyVkNjUtOTApICooJWQ5Ny0xMjIvJWQ2NS05MC8lZDQ4LTU3LyVkNDUpXFxuXCI7XG4gICAgc3RyICs9IFwib3dzcCAgICAgICAgICAgID0gKnNwYWNlXFxuXCI7XG4gICAgc3RyICs9IFwid3NwICAgICAgICAgICAgID0gMSpzcGFjZVxcblwiO1xuICAgIHN0ciArPSBcInNwYWNlICAgICAgICAgICA9ICVkMzJcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAlZDlcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyBjb21tZW50XFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gTGluZUNvbnRpbnVlXFxuXCI7XG4gICAgc3RyICs9IFwiY29tbWVudCAgICAgICAgID0gJWQ1OSAqKCVkMzItMTI2IC8gJWQ5KVxcblwiO1xuICAgIHN0ciArPSBcIkxpbmVFbmQgICAgICAgICA9ICVkMTMuMTBcXG5cIjtcbiAgICBzdHIgKz0gXCIgICAgICAgICAgICAgICAgLyAlZDEwXFxuXCI7XG4gICAgc3RyICs9IFwiICAgICAgICAgICAgICAgIC8gJWQxM1xcblwiO1xuICAgIHN0ciArPSBcIkxpbmVDb250aW51ZSAgICA9ICglZDEzLjEwIC8gJWQxMCAvICVkMTMpICglZDMyIC8gJWQ5KVxcblwiO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/sabnf-grammar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/scanner-callbacks.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner-callbacks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = __webpack_require__(/*! ../apg-lib/identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\nconst utils = __webpack_require__(/*! ../apg-lib/utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: data.textLength,\n      endType: data.endType,\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.textLength = phraseCount;\n  }\n  return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else if (data.strict) {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: phraseCount,\n      endType: 'none',\n      invalidChars: data.invalidCount,\n    });\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex + phraseCount,\n      msg: 'no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n    });\n  } else {\n    /* add a line ender */\n    chars.push(10);\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount + 1,\n      textLength: phraseCount,\n      endType: 'LF',\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex,\n      msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_POST) {\n    data.lineNo += 1;\n  }\n  return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'LF';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CR';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CRLF';\n  }\n  return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks['line-text'] = semLineText;\ncallbacks['last-line'] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQyxzRkFBd0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGtGQUFzQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQ0FBb0M7QUFDOUUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItY2FsbGJhY2tzLmpzP2RjNTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhlc2UgYXJlIHRoZSBBU1QgdHJhbnNsYXRpb24gY2FsbGJhY2sgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIHNjYW5uZXJcbi8vIHRvIGFuYWx5emUgdGhlIGNoYXJhY3RlcnMgYW5kIGxpbmVzLlxuY29uc3QgaWRzID0gcmVxdWlyZSgnLi4vYXBnLWxpYi9pZGVudGlmaWVycycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi9hcGctbGliL3V0aWxpdGllcycpO1xuXG5mdW5jdGlvbiBzZW1MaW5lKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZExlbmd0aCA9IDA7XG4gICAgZGF0YS50ZXh0TGVuZ3RoID0gMDtcbiAgICBkYXRhLmludmFsaWRDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5saW5lcy5wdXNoKHtcbiAgICAgIGxpbmVObzogZGF0YS5saW5lcy5sZW5ndGgsXG4gICAgICBiZWdpbkNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIHRleHRMZW5ndGg6IGRhdGEudGV4dExlbmd0aCxcbiAgICAgIGVuZFR5cGU6IGRhdGEuZW5kVHlwZSxcbiAgICAgIGludmFsaWRDaGFyczogZGF0YS5pbnZhbGlkQ291bnQsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1MaW5lVGV4dChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS50ZXh0TGVuZ3RoID0gcGhyYXNlQ291bnQ7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1MYXN0TGluZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICBpZiAoc3RhdGUgPT09IGlkcy5TRU1fUFJFKSB7XG4gICAgZGF0YS5lbmRMZW5ndGggPSAwO1xuICAgIGRhdGEudGV4dExlbmd0aCA9IDA7XG4gICAgZGF0YS5pbnZhbGlkQ291bnQgPSAwO1xuICB9IGVsc2UgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgZGF0YS5saW5lcy5wdXNoKHtcbiAgICAgIGxpbmVObzogZGF0YS5saW5lcy5sZW5ndGgsXG4gICAgICBiZWdpbkNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgbGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIHRleHRMZW5ndGg6IHBocmFzZUNvdW50LFxuICAgICAgZW5kVHlwZTogJ25vbmUnLFxuICAgICAgaW52YWxpZENoYXJzOiBkYXRhLmludmFsaWRDb3VudCxcbiAgICB9KTtcbiAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgIGxpbmU6IGRhdGEubGluZU5vLFxuICAgICAgY2hhcjogcGhyYXNlSW5kZXggKyBwaHJhc2VDb3VudCxcbiAgICAgIG1zZzogJ25vIGxpbmUgZW5kIG9uIGxhc3QgbGluZSAtIHN0cmljdCBBQk5GIHNwZWNpZmllcyBDUkxGKFxcXFxyXFxcXG4sIFxcXFx4MERcXFxceDBBKScsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLyogYWRkIGEgbGluZSBlbmRlciAqL1xuICAgIGNoYXJzLnB1c2goMTApO1xuICAgIGRhdGEubGluZXMucHVzaCh7XG4gICAgICBsaW5lTm86IGRhdGEubGluZXMubGVuZ3RoLFxuICAgICAgYmVnaW5DaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIGxlbmd0aDogcGhyYXNlQ291bnQgKyAxLFxuICAgICAgdGV4dExlbmd0aDogcGhyYXNlQ291bnQsXG4gICAgICBlbmRUeXBlOiAnTEYnLFxuICAgICAgaW52YWxpZENoYXJzOiBkYXRhLmludmFsaWRDb3VudCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUludmFsaWQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgIG1zZzogYGludmFsaWQgY2hhcmFjdGVyIGZvdW5kICdcXFxceCR7dXRpbHMuY2hhclRvSGV4KGNoYXJzW3BocmFzZUluZGV4XSl9J2AsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1FbmQoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BPU1QpIHtcbiAgICBkYXRhLmxpbmVObyArPSAxO1xuICB9XG4gIHJldHVybiBpZHMuU0VNX09LO1xufVxuZnVuY3Rpb24gc2VtTEYoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgaWYgKHN0YXRlID09PSBpZHMuU0VNX1BSRSkge1xuICAgIGRhdGEuZW5kVHlwZSA9ICdMRic7XG4gICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgbGluZTogZGF0YS5saW5lTm8sXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICBtc2c6ICdsaW5lIGVuZCBjaGFyYWN0ZXIgTEYoXFxcXG4sIFxcXFx4MEEpIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVzIENSTEYoXFxcXHJcXFxcbiwgXFxcXHgwRFxcXFx4MEEpJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWRzLlNFTV9PSztcbn1cbmZ1bmN0aW9uIHNlbUNSKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZFR5cGUgPSAnQ1InO1xuICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgIGxpbmU6IGRhdGEubGluZU5vLFxuICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgbXNnOiAnbGluZSBlbmQgY2hhcmFjdGVyIENSKFxcXFxyLCBcXFxceDBEKSAtIHN0cmljdCBBQk5GIHNwZWNpZmllcyBDUkxGKFxcXFxyXFxcXG4sIFxcXFx4MERcXFxceDBBKScsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5mdW5jdGlvbiBzZW1DUkxGKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gIGlmIChzdGF0ZSA9PT0gaWRzLlNFTV9QUkUpIHtcbiAgICBkYXRhLmVuZFR5cGUgPSAnQ1JMRic7XG4gIH1cbiAgcmV0dXJuIGlkcy5TRU1fT0s7XG59XG5jb25zdCBjYWxsYmFja3MgPSBbXTtcbmNhbGxiYWNrcy5saW5lID0gc2VtTGluZTtcbmNhbGxiYWNrc1snbGluZS10ZXh0J10gPSBzZW1MaW5lVGV4dDtcbmNhbGxiYWNrc1snbGFzdC1saW5lJ10gPSBzZW1MYXN0TGluZTtcbmNhbGxiYWNrcy5pbnZhbGlkID0gc2VtSW52YWxpZDtcbmNhbGxiYWNrcy5lbmQgPSBzZW1FbmQ7XG5jYWxsYmFja3MubGYgPSBzZW1MRjtcbmNhbGxiYWNrcy5jciA9IHNlbUNSO1xuY2FsbGJhY2tzLmNybGYgPSBzZW1DUkxGO1xuZXhwb3J0cy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/scanner-callbacks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/scanner-grammar.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner-grammar.js ***!
  \************************************************************/
/***/ ((module) => {

eval("// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 10\n  //       udts = 0\n  //    opcodes = 31\n  //        ---   ABNF original opcodes\n  //        ALT = 5\n  //        CAT = 2\n  //        REP = 4\n  //        RNM = 11\n  //        TLS = 0\n  //        TBS = 4\n  //        TRG = 5\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [0 - 4294967295]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = { name: 'file', lower: 'file', index: 0, isBkr: false };\n  this.rules[1] = { name: 'line', lower: 'line', index: 1, isBkr: false };\n  this.rules[2] = { name: 'line-text', lower: 'line-text', index: 2, isBkr: false };\n  this.rules[3] = { name: 'last-line', lower: 'last-line', index: 3, isBkr: false };\n  this.rules[4] = { name: 'valid', lower: 'valid', index: 4, isBkr: false };\n  this.rules[5] = { name: 'invalid', lower: 'invalid', index: 5, isBkr: false };\n  this.rules[6] = { name: 'end', lower: 'end', index: 6, isBkr: false };\n  this.rules[7] = { name: 'CRLF', lower: 'crlf', index: 7, isBkr: false };\n  this.rules[8] = { name: 'LF', lower: 'lf', index: 8, isBkr: false };\n  this.rules[9] = { name: 'CR', lower: 'cr', index: 9, isBkr: false };\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* file */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = { type: 2, children: [1,3] };// CAT\n  this.rules[0].opcodes[1] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[0].opcodes[2] = { type: 4, index: 1 };// RNM(line)\n  this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[0].opcodes[4] = { type: 4, index: 3 };// RNM(last-line)\n\n  /* line */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[1].opcodes[1] = { type: 4, index: 2 };// RNM(line-text)\n  this.rules[1].opcodes[2] = { type: 4, index: 6 };// RNM(end)\n\n  /* line-text */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[2].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[2].opcodes[2] = { type: 4, index: 4 };// RNM(valid)\n  this.rules[2].opcodes[3] = { type: 4, index: 5 };// RNM(invalid)\n\n  /* last-line */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[3].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[3].opcodes[2] = { type: 4, index: 4 };// RNM(valid)\n  this.rules[3].opcodes[3] = { type: 4, index: 5 };// RNM(invalid)\n\n  /* valid */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[4].opcodes[2] = { type: 6, string: [9] };// TBS\n\n  /* invalid */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = { type: 1, children: [1,2,3,4] };// ALT\n  this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 };// TRG\n  this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 };// TRG\n  this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 };// TRG\n  this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 };// TRG\n\n  /* end */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = { type: 1, children: [1,2,3] };// ALT\n  this.rules[6].opcodes[1] = { type: 4, index: 7 };// RNM(CRLF)\n  this.rules[6].opcodes[2] = { type: 4, index: 8 };// RNM(LF)\n  this.rules[6].opcodes[3] = { type: 4, index: 9 };// RNM(CR)\n\n  /* CRLF */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = { type: 6, string: [13,10] };// TBS\n\n  /* LF */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = { type: 6, string: [10] };// TBS\n\n  /* CR */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = { type: 6, string: [13] };// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \"file = *line [last-line]\\n\";\n    str += \"line = line-text end\\n\";\n    str += \"line-text = *(valid/invalid)\\n\";\n    str += \"last-line = 1*(valid/invalid)\\n\";\n    str += \"valid = %d32-126 / %d9\\n\";\n    str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n    str += \"end = CRLF / LF / CR\\n\";\n    str += \"CRLF = %d13.10\\n\";\n    str += \"LF = %d10\\n\";\n    str += \"CR = %d13\\n\";\n    return str;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItZ3JhbW1hci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLGlDQUFpQztBQUNoRSwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQiwwQkFBMEI7QUFDekQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9COztBQUVuRDtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRSwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQixvQkFBb0I7QUFDbkQsK0JBQStCLG9CQUFvQjs7QUFFbkQ7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEUsK0JBQStCLDJCQUEyQjtBQUMxRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCO0FBQzFELCtCQUErQiw2QkFBNkI7QUFDNUQsK0JBQStCLHVCQUF1Qjs7QUFFdEQ7QUFDQTtBQUNBLCtCQUErQiwrQkFBK0I7QUFDOUQsK0JBQStCLDBCQUEwQjtBQUN6RCwrQkFBK0IsNEJBQTRCO0FBQzNELCtCQUErQiw0QkFBNEI7QUFDM0QsK0JBQStCLHFDQUFxQzs7QUFFcEU7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQsK0JBQStCLG9CQUFvQjtBQUNuRCwrQkFBK0Isb0JBQW9CO0FBQ25ELCtCQUErQixvQkFBb0I7O0FBRW5EO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCOztBQUUxRDtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3Qjs7QUFFdkQ7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXItZ3JhbW1hci5qcz84MmZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDI0IExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWQ8YnI+XG4vLyAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpPGJyPlxuLy9cbi8vIEdlbmVyYXRlZCBieSBhcGctanMsIFZlcnNpb24gNC40LjAgW2FwZy1qc10oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qcylcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ3JhbW1hcigpe1xuICAvLyBgYGBcbiAgLy8gU1VNTUFSWVxuICAvLyAgICAgIHJ1bGVzID0gMTBcbiAgLy8gICAgICAgdWR0cyA9IDBcbiAgLy8gICAgb3Bjb2RlcyA9IDMxXG4gIC8vICAgICAgICAtLS0gICBBQk5GIG9yaWdpbmFsIG9wY29kZXNcbiAgLy8gICAgICAgIEFMVCA9IDVcbiAgLy8gICAgICAgIENBVCA9IDJcbiAgLy8gICAgICAgIFJFUCA9IDRcbiAgLy8gICAgICAgIFJOTSA9IDExXG4gIC8vICAgICAgICBUTFMgPSAwXG4gIC8vICAgICAgICBUQlMgPSA0XG4gIC8vICAgICAgICBUUkcgPSA1XG4gIC8vICAgICAgICAtLS0gICBTQUJORiBzdXBlcnNldCBvcGNvZGVzXG4gIC8vICAgICAgICBVRFQgPSAwXG4gIC8vICAgICAgICBBTkQgPSAwXG4gIC8vICAgICAgICBOT1QgPSAwXG4gIC8vICAgICAgICBCS0EgPSAwXG4gIC8vICAgICAgICBCS04gPSAwXG4gIC8vICAgICAgICBCS1IgPSAwXG4gIC8vICAgICAgICBBQkcgPSAwXG4gIC8vICAgICAgICBBRU4gPSAwXG4gIC8vIGNoYXJhY3RlcnMgPSBbMCAtIDQyOTQ5NjcyOTVdXG4gIC8vIGBgYFxuICAvKiBPQkpFQ1QgSURFTlRJRklFUiAoZm9yIGludGVybmFsIHBhcnNlciB1c2UpICovXG4gIHRoaXMuZ3JhbW1hck9iamVjdCA9ICdncmFtbWFyT2JqZWN0JztcblxuICAvKiBSVUxFUyAqL1xuICB0aGlzLnJ1bGVzID0gW107XG4gIHRoaXMucnVsZXNbMF0gPSB7IG5hbWU6ICdmaWxlJywgbG93ZXI6ICdmaWxlJywgaW5kZXg6IDAsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzFdID0geyBuYW1lOiAnbGluZScsIGxvd2VyOiAnbGluZScsIGluZGV4OiAxLCBpc0JrcjogZmFsc2UgfTtcbiAgdGhpcy5ydWxlc1syXSA9IHsgbmFtZTogJ2xpbmUtdGV4dCcsIGxvd2VyOiAnbGluZS10ZXh0JywgaW5kZXg6IDIsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzNdID0geyBuYW1lOiAnbGFzdC1saW5lJywgbG93ZXI6ICdsYXN0LWxpbmUnLCBpbmRleDogMywgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNF0gPSB7IG5hbWU6ICd2YWxpZCcsIGxvd2VyOiAndmFsaWQnLCBpbmRleDogNCwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbNV0gPSB7IG5hbWU6ICdpbnZhbGlkJywgbG93ZXI6ICdpbnZhbGlkJywgaW5kZXg6IDUsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzZdID0geyBuYW1lOiAnZW5kJywgbG93ZXI6ICdlbmQnLCBpbmRleDogNiwgaXNCa3I6IGZhbHNlIH07XG4gIHRoaXMucnVsZXNbN10gPSB7IG5hbWU6ICdDUkxGJywgbG93ZXI6ICdjcmxmJywgaW5kZXg6IDcsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzhdID0geyBuYW1lOiAnTEYnLCBsb3dlcjogJ2xmJywgaW5kZXg6IDgsIGlzQmtyOiBmYWxzZSB9O1xuICB0aGlzLnJ1bGVzWzldID0geyBuYW1lOiAnQ1InLCBsb3dlcjogJ2NyJywgaW5kZXg6IDksIGlzQmtyOiBmYWxzZSB9O1xuXG4gIC8qIFVEVFMgKi9cbiAgdGhpcy51ZHRzID0gW107XG5cbiAgLyogT1BDT0RFUyAqL1xuICAvKiBmaWxlICovXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDIsIGNoaWxkcmVuOiBbMSwzXSB9Oy8vIENBVFxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDMsIG1pbjogMCwgbWF4OiBJbmZpbml0eSB9Oy8vIFJFUFxuICB0aGlzLnJ1bGVzWzBdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDQsIGluZGV4OiAxIH07Ly8gUk5NKGxpbmUpXG4gIHRoaXMucnVsZXNbMF0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogMywgbWluOiAwLCBtYXg6IDEgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1swXS5vcGNvZGVzWzRdID0geyB0eXBlOiA0LCBpbmRleDogMyB9Oy8vIFJOTShsYXN0LWxpbmUpXG5cbiAgLyogbGluZSAqL1xuICB0aGlzLnJ1bGVzWzFdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzBdID0geyB0eXBlOiAyLCBjaGlsZHJlbjogWzEsMl0gfTsvLyBDQVRcbiAgdGhpcy5ydWxlc1sxXS5vcGNvZGVzWzFdID0geyB0eXBlOiA0LCBpbmRleDogMiB9Oy8vIFJOTShsaW5lLXRleHQpXG4gIHRoaXMucnVsZXNbMV0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDYgfTsvLyBSTk0oZW5kKVxuXG4gIC8qIGxpbmUtdGV4dCAqL1xuICB0aGlzLnJ1bGVzWzJdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDAsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzFdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzIsM10gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogNCB9Oy8vIFJOTSh2YWxpZClcbiAgdGhpcy5ydWxlc1syXS5vcGNvZGVzWzNdID0geyB0eXBlOiA0LCBpbmRleDogNSB9Oy8vIFJOTShpbnZhbGlkKVxuXG4gIC8qIGxhc3QtbGluZSAqL1xuICB0aGlzLnJ1bGVzWzNdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzBdID0geyB0eXBlOiAzLCBtaW46IDEsIG1heDogSW5maW5pdHkgfTsvLyBSRVBcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzFdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzIsM10gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzJdID0geyB0eXBlOiA0LCBpbmRleDogNCB9Oy8vIFJOTSh2YWxpZClcbiAgdGhpcy5ydWxlc1szXS5vcGNvZGVzWzNdID0geyB0eXBlOiA0LCBpbmRleDogNSB9Oy8vIFJOTShpbnZhbGlkKVxuXG4gIC8qIHZhbGlkICovXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMSwyXSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzRdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDUsIG1pbjogMzIsIG1heDogMTI2IH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNF0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNiwgc3RyaW5nOiBbOV0gfTsvLyBUQlNcblxuICAvKiBpbnZhbGlkICovXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2RlcyA9IFtdO1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMF0gPSB7IHR5cGU6IDEsIGNoaWxkcmVuOiBbMSwyLDMsNF0gfTsvLyBBTFRcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzFdID0geyB0eXBlOiA1LCBtaW46IDAsIG1heDogOCB9Oy8vIFRSR1xuICB0aGlzLnJ1bGVzWzVdLm9wY29kZXNbMl0gPSB7IHR5cGU6IDUsIG1pbjogMTEsIG1heDogMTIgfTsvLyBUUkdcbiAgdGhpcy5ydWxlc1s1XS5vcGNvZGVzWzNdID0geyB0eXBlOiA1LCBtaW46IDE0LCBtYXg6IDMxIH07Ly8gVFJHXG4gIHRoaXMucnVsZXNbNV0ub3Bjb2Rlc1s0XSA9IHsgdHlwZTogNSwgbWluOiAxMjcsIG1heDogNDI5NDk2NzI5NSB9Oy8vIFRSR1xuXG4gIC8qIGVuZCAqL1xuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s2XS5vcGNvZGVzWzBdID0geyB0eXBlOiAxLCBjaGlsZHJlbjogWzEsMiwzXSB9Oy8vIEFMVFxuICB0aGlzLnJ1bGVzWzZdLm9wY29kZXNbMV0gPSB7IHR5cGU6IDQsIGluZGV4OiA3IH07Ly8gUk5NKENSTEYpXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1syXSA9IHsgdHlwZTogNCwgaW5kZXg6IDggfTsvLyBSTk0oTEYpXG4gIHRoaXMucnVsZXNbNl0ub3Bjb2Rlc1szXSA9IHsgdHlwZTogNCwgaW5kZXg6IDkgfTsvLyBSTk0oQ1IpXG5cbiAgLyogQ1JMRiAqL1xuICB0aGlzLnJ1bGVzWzddLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s3XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFsxMywxMF0gfTsvLyBUQlNcblxuICAvKiBMRiAqL1xuICB0aGlzLnJ1bGVzWzhdLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s4XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFsxMF0gfTsvLyBUQlNcblxuICAvKiBDUiAqL1xuICB0aGlzLnJ1bGVzWzldLm9wY29kZXMgPSBbXTtcbiAgdGhpcy5ydWxlc1s5XS5vcGNvZGVzWzBdID0geyB0eXBlOiA2LCBzdHJpbmc6IFsxM10gfTsvLyBUQlNcblxuICAvLyBUaGUgYHRvU3RyaW5nKClgIGZ1bmN0aW9uIHdpbGwgZGlzcGxheSB0aGUgb3JpZ2luYWwgZ3JhbW1hciBmaWxlKHMpIHRoYXQgcHJvZHVjZWQgdGhlc2Ugb3Bjb2Rlcy5cbiAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgc3RyICs9IFwiZmlsZSA9ICpsaW5lIFtsYXN0LWxpbmVdXFxuXCI7XG4gICAgc3RyICs9IFwibGluZSA9IGxpbmUtdGV4dCBlbmRcXG5cIjtcbiAgICBzdHIgKz0gXCJsaW5lLXRleHQgPSAqKHZhbGlkL2ludmFsaWQpXFxuXCI7XG4gICAgc3RyICs9IFwibGFzdC1saW5lID0gMSoodmFsaWQvaW52YWxpZClcXG5cIjtcbiAgICBzdHIgKz0gXCJ2YWxpZCA9ICVkMzItMTI2IC8gJWQ5XFxuXCI7XG4gICAgc3RyICs9IFwiaW52YWxpZCA9ICVkMC04IC8gJWQxMS0xMiAvJWQxNC0zMSAvICV4N2YtZmZmZmZmZmZcXG5cIjtcbiAgICBzdHIgKz0gXCJlbmQgPSBDUkxGIC8gTEYgLyBDUlxcblwiO1xuICAgIHN0ciArPSBcIkNSTEYgPSAlZDEzLjEwXFxuXCI7XG4gICAgc3RyICs9IFwiTEYgPSAlZDEwXFxuXCI7XG4gICAgc3RyICs9IFwiQ1IgPSAlZDEzXFxuXCI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/scanner-grammar.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/scanner.js":
/*!****************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/scanner.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\nmodule.exports = function exfn(chars, errors, strict, trace) {\n  const thisFileName = 'scanner.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const grammar = new (__webpack_require__(/*! ./scanner-grammar */ \"(ssr)/./node_modules/apg-js/src/apg-api/scanner-grammar.js\"))();\n  const { callbacks } = __webpack_require__(/*! ./scanner-callbacks */ \"(ssr)/./node_modules/apg-js/src/apg-api/scanner-callbacks.js\");\n\n  /* Scan the grammar for character code errors and catalog the lines. */\n  const lines = [];\n  // eslint-disable-next-line new-cap\n  const parser = new apglib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new apglib.ast();\n  parser.ast.callbacks = callbacks;\n  if (trace) {\n    if (trace.traceObject !== 'traceObject') {\n      throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n    }\n    parser.trace = trace;\n  }\n\n  /* parse the input SABNF grammar */\n  const test = parser.parse(grammar, 'file', chars);\n  if (test.success !== true) {\n    errors.push({\n      line: 0,\n      char: 0,\n      msg: 'syntax analysis error analyzing input SABNF grammar',\n    });\n    return;\n  }\n  const data = {\n    lines,\n    lineNo: 0,\n    errors,\n    strict: !!strict,\n  };\n\n  /* translate (analyze) the input SABNF grammar */\n  parser.ast.translate(data);\n  // eslint-disable-next-line consistent-return\n  return lines;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NjYW5uZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBbUI7QUFDbEQsVUFBVSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyx5RkFBcUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2Nhbm5lci5qcz9mOGIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIHJlYWRzIHRoZSBpbnB1dCBncmFtbWFyIGZpbGUgYW5kIGRvZXMgYSBwcmVsaW1pbmFyeSBhbmFseXNpc1xuLy8gYmVmb3JlIGF0dGVtcHRpbmcgdG8gcGFyc2UgaXQgaW50byBhIGdyYW1tYXIgb2JqZWN0LlxuLy8gU2VlOjxicj5cbi8vIGAuL2Rpc3Qvc2Nhbm5lci1ncmFtbWFyLmJuZmA8YnI+XG4vLyBmb3IgdGhlIGdyYW1tYXIgZmlsZSB0aGlzIHBhcnNlciBpcyBiYXNlZCBvbi5cbi8vXG4vLyBJdCBoYXMgdHdvIHByaW1hcnkgZnVuY3Rpb25zLlxuLy8gLSB2ZXJpZnkgdGhlIGNoYXJhY3RlciBjb2RlcyAtIG5vIG5vbi1wcmludGluZyBBU0NJSSBjaGFyYWN0ZXJzXG4vLyAtIGNhdGFsb2cgdGhlIGxpbmVzIC0gY3JlYXRlIGFuIGFycmF5IHdpdGggYSBsaW5lIG9iamVjdCBmb3IgZWFjaCBsaW5lLlxuLy8gVGhlIG9iamVjdCBjYXJyaWVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5lIG51bWJlciBhbmQgY2hhcmFjdGVyIGxlbmd0aCB3aGljaCBpcyB1c2VkXG4vLyBieSB0aGUgcGFyc2VyIGdlbmVyYXRvciBwcmltYXJpbHkgZm9yIGVycm9yIHJlcG9ydGluZy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXhmbihjaGFycywgZXJyb3JzLCBzdHJpY3QsIHRyYWNlKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzY2FubmVyLmpzOiAnO1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBncmFtbWFyID0gbmV3IChyZXF1aXJlKCcuL3NjYW5uZXItZ3JhbW1hcicpKSgpO1xuICBjb25zdCB7IGNhbGxiYWNrcyB9ID0gcmVxdWlyZSgnLi9zY2FubmVyLWNhbGxiYWNrcycpO1xuXG4gIC8qIFNjYW4gdGhlIGdyYW1tYXIgZm9yIGNoYXJhY3RlciBjb2RlIGVycm9ycyBhbmQgY2F0YWxvZyB0aGUgbGluZXMuICovXG4gIGNvbnN0IGxpbmVzID0gW107XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gIGNvbnN0IHBhcnNlciA9IG5ldyBhcGdsaWIucGFyc2VyKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gIHBhcnNlci5hc3QgPSBuZXcgYXBnbGliLmFzdCgpO1xuICBwYXJzZXIuYXN0LmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgaWYgKHRyYWNlKSB7XG4gICAgaWYgKHRyYWNlLnRyYWNlT2JqZWN0ICE9PSAndHJhY2VPYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXNGaWxlTmFtZX10cmFjZSBhcmd1bWVudCBpcyBub3QgYSB0cmFjZSBvYmplY3RgKTtcbiAgICB9XG4gICAgcGFyc2VyLnRyYWNlID0gdHJhY2U7XG4gIH1cblxuICAvKiBwYXJzZSB0aGUgaW5wdXQgU0FCTkYgZ3JhbW1hciAqL1xuICBjb25zdCB0ZXN0ID0gcGFyc2VyLnBhcnNlKGdyYW1tYXIsICdmaWxlJywgY2hhcnMpO1xuICBpZiAodGVzdC5zdWNjZXNzICE9PSB0cnVlKSB7XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAgbGluZTogMCxcbiAgICAgIGNoYXI6IDAsXG4gICAgICBtc2c6ICdzeW50YXggYW5hbHlzaXMgZXJyb3IgYW5hbHl6aW5nIGlucHV0IFNBQk5GIGdyYW1tYXInLFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkYXRhID0ge1xuICAgIGxpbmVzLFxuICAgIGxpbmVObzogMCxcbiAgICBlcnJvcnMsXG4gICAgc3RyaWN0OiAhIXN0cmljdCxcbiAgfTtcblxuICAvKiB0cmFuc2xhdGUgKGFuYWx5emUpIHRoZSBpbnB1dCBTQUJORiBncmFtbWFyICovXG4gIHBhcnNlci5hc3QudHJhbnNsYXRlKGRhdGEpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgcmV0dXJuIGxpbmVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/scanner.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/semantic-callbacks.js":
/*!***************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/semantic-callbacks.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n\n  /* Some helper functions. */\n  const NameList = function NameList() {\n    this.names = [];\n    /* Adds a new rule name object to the list. Returns -1 if the name already exists. */\n    /* Returns the added name object if the name does not already exist. */\n    this.add = function add(name) {\n      let ret = -1;\n      const find = this.get(name);\n      if (find === -1) {\n        ret = {\n          name,\n          lower: name.toLowerCase(),\n          index: this.names.length,\n        };\n        this.names.push(ret);\n      }\n      return ret;\n    };\n    /* Brute-force look up. */\n    this.get = function get(name) {\n      let ret = -1;\n      const lower = name.toLowerCase();\n      for (let i = 0; i < this.names.length; i += 1) {\n        if (this.names[i].lower === lower) {\n          ret = this.names[i];\n          break;\n        }\n      }\n      return ret;\n    };\n  };\n  /* converts text decimal numbers from, e.g. %d99, to an integer */\n  const decnum = function decnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 10 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text binary numbers from, e.g. %b10, to an integer */\n  const binnum = function binnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 2 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text hexadecimal numbers from, e.g. %xff, to an integer */\n  const hexnum = function hexnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      let digit = chars[i];\n      if (digit >= 48 && digit <= 57) {\n        digit -= 48;\n      } else if (digit >= 65 && digit <= 70) {\n        digit -= 55;\n      } else if (digit >= 97 && digit <= 102) {\n        digit -= 87;\n      } else {\n        throw new Error('hexnum out of range');\n      }\n      num = 16 * num + digit;\n    }\n    return num;\n  };\n\n  // This is the prototype for all semantic analysis callback functions.\n  // ````\n  // state - the translator state\n  //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n  //   id.SEM_POST for upward (post branch) traversal of the AST\n  // chars - the array of character codes for the input string\n  // phraseIndex - index into the chars array to the first\n  //               character of the phrase\n  // phraseCount - the number of characters in the phrase\n  // data - user-defined data passed to the translator\n  //        for use by the callback functions.\n  // @return id.SEM_OK, normal return.\n  //         id.SEM_SKIP in state id.SEM_PRE will\n  //         skip the branch below.\n  //         Any thing else is an error which will\n  //         stop the translation.\n  // ````\n  /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */\n  // The AST callback functions.\n  function semFile(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleNames = new NameList();\n      data.udtNames = new NameList();\n      data.rules = [];\n      data.udts = [];\n      data.rulesLineMap = [];\n      data.opcodes = [];\n      data.altStack = [];\n      data.topStack = null;\n      data.topRule = null;\n    } else if (state === id.SEM_POST) {\n      /* validate RNM rule names and set opcode rule index */\n      let nameObj;\n      data.rules.forEach((rule) => {\n        rule.isBkr = false;\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.RNM) {\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj === -1) {\n              data.errors.push({\n                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                char: op.index.phraseIndex,\n                msg: `Rule name '${op.index.name}' used but not defined.`,\n              });\n              op.index = -1;\n            } else {\n              op.index = nameObj.index;\n            }\n          }\n        });\n      });\n      /* validate BKR rule names and set opcode rule index */\n      data.udts.forEach((udt) => {\n        udt.isBkr = false;\n      });\n      data.rules.forEach((rule) => {\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.BKR) {\n            rule.hasBkr = true;\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj !== -1) {\n              data.rules[nameObj.index].isBkr = true;\n              op.index = nameObj.index;\n            } else {\n              nameObj = data.udtNames.get(op.index.name);\n              if (nameObj !== -1) {\n                data.udts[nameObj.index].isBkr = true;\n                op.index = data.rules.length + nameObj.index;\n              } else {\n                data.errors.push({\n                  line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                  char: op.index.phraseIndex,\n                  msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`,\n                });\n                op.index = -1;\n              }\n            }\n          }\n        });\n      });\n    }\n    return ret;\n  }\n  function semRule(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.altStack.length = 0;\n      data.topStack = null;\n      data.rulesLineMap.push({\n        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = '';\n      data.definedas = '';\n    } else if (state === id.SEM_POST) {\n      let ruleName;\n      if (data.definedas === '=') {\n        ruleName = data.ruleNames.add(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' previously defined.`,\n          });\n        } else {\n          /* start a new rule */\n          data.topRule = {\n            name: ruleName.name,\n            lower: ruleName.lower,\n            opcodes: [],\n            index: ruleName.index,\n          };\n          data.rules.push(data.topRule);\n          data.opcodes = data.topRule.opcodes;\n        }\n      } else {\n        ruleName = data.ruleNames.get(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`,\n          });\n        } else {\n          data.topRule = data.rules[ruleName.index];\n          data.opcodes = data.topRule.opcodes;\n        }\n      }\n    }\n    return ret;\n  }\n  function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      const TRUE = true;\n      while (TRUE) {\n        if (data.definedas === null) {\n          /* rule error - skip opcode generation */\n          ret = id.SEM_SKIP;\n          break;\n        }\n        if (data.topStack === null) {\n          /* top-level ALT */\n          if (data.definedas === '=') {\n            /* \"=\" new rule */\n            data.topStack = {\n              alt: {\n                type: id.ALT,\n                children: [],\n              },\n              cat: null,\n            };\n            data.altStack.push(data.topStack);\n            data.opcodes.push(data.topStack.alt);\n            break;\n          }\n          /* \"=/\" incremental alternate */\n          data.topStack = {\n            alt: data.opcodes[0],\n            cat: null,\n          };\n          data.altStack.push(data.topStack);\n          break;\n        }\n        /* lower-level ALT */\n        data.topStack = {\n          alt: {\n            type: id.ALT,\n            children: [],\n          },\n          cat: null,\n        };\n        data.altStack.push(data.topStack);\n        data.opcodes.push(data.topStack.alt);\n        break;\n      }\n    } else if (state === id.SEM_POST) {\n      data.altStack.pop();\n      if (data.altStack.length > 0) {\n        data.topStack = data.altStack[data.altStack.length - 1];\n      } else {\n        data.topStack = null;\n      }\n    }\n    return ret;\n  }\n  function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.alt.children.push(data.opcodes.length);\n      data.topStack.cat = {\n        type: id.CAT,\n        children: [],\n      };\n      data.opcodes.push(data.topStack.cat);\n    } else if (state === id.SEM_POST) {\n      data.topStack.cat = null;\n    }\n    return ret;\n  }\n  function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.cat.children.push(data.opcodes.length);\n    }\n    return ret;\n  }\n  function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.REP,\n        min: 0,\n        max: 1,\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDefined(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=';\n    }\n    return ret;\n  }\n  function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=/';\n    }\n    return ret;\n  }\n  function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = Infinity;\n      data.topRep = {\n        type: id.REP,\n        min: 0,\n        max: Infinity,\n      };\n      data.opcodes.push(data.topRep);\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.topRep.min = data.min;\n      data.topRep.max = data.max;\n    }\n    return ret;\n  }\n  function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n      data.min = data.max;\n    }\n    return ret;\n  }\n  function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AND,\n      });\n    }\n    return ret;\n  }\n  function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.NOT,\n      });\n    }\n    return ret;\n  }\n  function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.RNM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex,\n          name: apglib.utils.charsToString(chars, phraseIndex, phraseCount),\n        },\n      });\n    }\n    return ret;\n  }\n  function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.ABG,\n      });\n    }\n    return ret;\n  }\n  function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AEN,\n      });\n    }\n    return ret;\n  }\n  function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKA,\n      });\n    }\n    return ret;\n  }\n  function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKN,\n      });\n    }\n    return ret;\n  }\n  function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ci = true; /* default to case insensitive */\n      data.cs = false;\n      data.um = true;\n      data.pm = false;\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKR,\n        bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n        bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex: data.bkrname.phraseIndex,\n          name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength),\n        },\n      });\n    }\n    return ret;\n  }\n  function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.ci = true;\n    }\n    return ret;\n  }\n  function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.cs = true;\n    }\n    return ret;\n  }\n  function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.um = true;\n    }\n    return ret;\n  }\n  function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.pm = true;\n    }\n    return ret;\n  }\n  function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.bkrname = {\n        phraseIndex,\n        phraseLength: phraseCount,\n      };\n    }\n    return ret;\n  }\n  function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: true,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: true,\n        index: udtName.index,\n      });\n    }\n    return ret;\n  }\n  function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtNonEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: false,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: false,\n        index: udtName.index,\n        syntax: null,\n        semantic: null,\n      });\n    }\n    return ret;\n  }\n  function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tlscase = true; /* default to case insensitive */\n    }\n    return ret;\n  }\n  function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n        data.tlscase = false; /* set to case sensitive */\n      }\n    }\n    return ret;\n  }\n  function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (data.tlscase) {\n        const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n        for (let i = 0; i < str.length; i += 1) {\n          if (str[i] >= 65 && str[i] <= 90) {\n            str[i] += 32;\n          }\n        }\n        data.opcodes.push({\n          type: id.TLS,\n          string: str,\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex, phraseIndex + phraseCount),\n        });\n      }\n    }\n    return ret;\n  }\n  function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount <= 2) {\n        /* only TLS is allowed to be empty */\n        data.opcodes.push({\n          type: id.TLS,\n          string: [],\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1),\n        });\n      }\n    }\n    return ret;\n  }\n  function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tbsstr = [];\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.TBS,\n        string: data.tbsstr,\n      });\n    }\n    return ret;\n  }\n  function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = 0;\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.opcodes.push({\n        type: id.TRG,\n        min: data.min,\n        max: data.max,\n      });\n    }\n    return ret;\n  }\n  function semDmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semBstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semXstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  // Define the callback functions to the AST object.\n  this.callbacks = [];\n  this.callbacks.abgop = semAbgOp;\n  this.callbacks.aenop = semAenOp;\n  this.callbacks.alternation = semAlternation;\n  this.callbacks.andop = semAndOp;\n  this.callbacks.bmax = semBmax;\n  this.callbacks.bmin = semBmin;\n  this.callbacks.bkaop = semBkaOp;\n  this.callbacks.bknop = semBknOp;\n  this.callbacks.bkrop = semBkrOp;\n  this.callbacks['bkr-name'] = semBkrName;\n  this.callbacks.bstring = semBstring;\n  this.callbacks.clsop = semClsOp;\n  this.callbacks.ci = semBkrCi;\n  this.callbacks.cs = semBkrCs;\n  this.callbacks.um = semBkrUm;\n  this.callbacks.pm = semBkrPm;\n  this.callbacks.concatenation = semConcatenation;\n  this.callbacks.defined = semDefined;\n  this.callbacks.dmax = semDmax;\n  this.callbacks.dmin = semDmin;\n  this.callbacks.dstring = semDstring;\n  this.callbacks.file = semFile;\n  this.callbacks.incalt = semIncAlt;\n  this.callbacks.notop = semNotOp;\n  this.callbacks.optionopen = semOptionOpen;\n  this.callbacks['rep-max'] = semRepMax;\n  this.callbacks['rep-min'] = semRepMin;\n  this.callbacks['rep-min-max'] = semRepMinMax;\n  this.callbacks.repetition = semRepetition;\n  this.callbacks.repop = semRepOp;\n  this.callbacks.rnmop = semRnmOp;\n  this.callbacks.rule = semRule;\n  this.callbacks.rulelookup = semRuleLookup;\n  this.callbacks.rulename = semRuleName;\n  this.callbacks.tbsop = semTbsOp;\n  this.callbacks.tlscase = semTlsCase;\n  this.callbacks.tlsstring = semTlsString;\n  this.callbacks.tlsop = semTlsOp;\n  this.callbacks.trgop = semTrgOp;\n  this.callbacks['udt-empty'] = semUdtEmpty;\n  this.callbacks['udt-non-empty'] = semUdtNonEmpty;\n  this.callbacks.xmax = semXmax;\n  this.callbacks.xmin = semXmin;\n  this.callbacks.xstring = semXstring;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NlbWFudGljLWNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QyxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFNBQVMsU0FBUyxTQUFTO0FBQzdGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxTQUFTLFNBQVMsU0FBUztBQUNwRyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3NlbWFudGljLWNhbGxiYWNrcy5qcz9hYzI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGhhcyBhbGwgb2YgdGhlIEFTVCB0cmFuc2xhdGlvbiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBzZW1hbnRpYyBhbmFseXNpc1xuLy8gcGhhc2Ugb2YgdGhlIGdlbmVyYXRvci5cbi8vIFNlZTo8YnI+XG4vLyBgLi9kaXN0L2FibmYtZm9yLXNhYm5mLWdyYW1tYXIuYm5mYDxicj5cbi8vIGZvciB0aGUgZ3JhbW1hciBmaWxlIHRoZXNlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhcmUgYmFzZWQgb24uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4Zm4oKSB7XG4gIGNvbnN0IGFwZ2xpYiA9IHJlcXVpcmUoJy4uL2FwZy1saWIvbm9kZS1leHBvcnRzJyk7XG4gIGNvbnN0IGlkID0gYXBnbGliLmlkcztcblxuICAvKiBTb21lIGhlbHBlciBmdW5jdGlvbnMuICovXG4gIGNvbnN0IE5hbWVMaXN0ID0gZnVuY3Rpb24gTmFtZUxpc3QoKSB7XG4gICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgIC8qIEFkZHMgYSBuZXcgcnVsZSBuYW1lIG9iamVjdCB0byB0aGUgbGlzdC4gUmV0dXJucyAtMSBpZiB0aGUgbmFtZSBhbHJlYWR5IGV4aXN0cy4gKi9cbiAgICAvKiBSZXR1cm5zIHRoZSBhZGRlZCBuYW1lIG9iamVjdCBpZiB0aGUgbmFtZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiAqL1xuICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUpIHtcbiAgICAgIGxldCByZXQgPSAtMTtcbiAgICAgIGNvbnN0IGZpbmQgPSB0aGlzLmdldChuYW1lKTtcbiAgICAgIGlmIChmaW5kID09PSAtMSkge1xuICAgICAgICByZXQgPSB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBsb3dlcjogbmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGluZGV4OiB0aGlzLm5hbWVzLmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lcy5wdXNoKHJldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgLyogQnJ1dGUtZm9yY2UgbG9vayB1cC4gKi9cbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICBsZXQgcmV0ID0gLTE7XG4gICAgICBjb25zdCBsb3dlciA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5uYW1lc1tpXS5sb3dlciA9PT0gbG93ZXIpIHtcbiAgICAgICAgICByZXQgPSB0aGlzLm5hbWVzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH07XG4gIC8qIGNvbnZlcnRzIHRleHQgZGVjaW1hbCBudW1iZXJzIGZyb20sIGUuZy4gJWQ5OSwgdG8gYW4gaW50ZWdlciAqL1xuICBjb25zdCBkZWNudW0gPSBmdW5jdGlvbiBkZWNudW0oY2hhcnMsIGJlZywgbGVuKSB7XG4gICAgbGV0IG51bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGJlZzsgaSA8IGJlZyArIGxlbjsgaSArPSAxKSB7XG4gICAgICBudW0gPSAxMCAqIG51bSArIGNoYXJzW2ldIC0gNDg7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG4gIC8qIGNvbnZlcnRzIHRleHQgYmluYXJ5IG51bWJlcnMgZnJvbSwgZS5nLiAlYjEwLCB0byBhbiBpbnRlZ2VyICovXG4gIGNvbnN0IGJpbm51bSA9IGZ1bmN0aW9uIGJpbm51bShjaGFycywgYmVnLCBsZW4pIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgYmVnICsgbGVuOyBpICs9IDEpIHtcbiAgICAgIG51bSA9IDIgKiBudW0gKyBjaGFyc1tpXSAtIDQ4O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuICAvKiBjb252ZXJ0cyB0ZXh0IGhleGFkZWNpbWFsIG51bWJlcnMgZnJvbSwgZS5nLiAleGZmLCB0byBhbiBpbnRlZ2VyICovXG4gIGNvbnN0IGhleG51bSA9IGZ1bmN0aW9uIGhleG51bShjaGFycywgYmVnLCBsZW4pIHtcbiAgICBsZXQgbnVtID0gMDtcbiAgICBmb3IgKGxldCBpID0gYmVnOyBpIDwgYmVnICsgbGVuOyBpICs9IDEpIHtcbiAgICAgIGxldCBkaWdpdCA9IGNoYXJzW2ldO1xuICAgICAgaWYgKGRpZ2l0ID49IDQ4ICYmIGRpZ2l0IDw9IDU3KSB7XG4gICAgICAgIGRpZ2l0IC09IDQ4O1xuICAgICAgfSBlbHNlIGlmIChkaWdpdCA+PSA2NSAmJiBkaWdpdCA8PSA3MCkge1xuICAgICAgICBkaWdpdCAtPSA1NTtcbiAgICAgIH0gZWxzZSBpZiAoZGlnaXQgPj0gOTcgJiYgZGlnaXQgPD0gMTAyKSB7XG4gICAgICAgIGRpZ2l0IC09IDg3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhudW0gb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG4gICAgICBudW0gPSAxNiAqIG51bSArIGRpZ2l0O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgdGhlIHByb3RvdHlwZSBmb3IgYWxsIHNlbWFudGljIGFuYWx5c2lzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gYGBgYFxuICAvLyBzdGF0ZSAtIHRoZSB0cmFuc2xhdG9yIHN0YXRlXG4gIC8vICAgaWQuU0VNX1BSRSBmb3IgZG93bndhcmQgKHByZS1icmFuY2gpIHRyYXZlcnNhbCBvZiB0aGUgQVNUXG4gIC8vICAgaWQuU0VNX1BPU1QgZm9yIHVwd2FyZCAocG9zdCBicmFuY2gpIHRyYXZlcnNhbCBvZiB0aGUgQVNUXG4gIC8vIGNoYXJzIC0gdGhlIGFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyBmb3IgdGhlIGlucHV0IHN0cmluZ1xuICAvLyBwaHJhc2VJbmRleCAtIGluZGV4IGludG8gdGhlIGNoYXJzIGFycmF5IHRvIHRoZSBmaXJzdFxuICAvLyAgICAgICAgICAgICAgIGNoYXJhY3RlciBvZiB0aGUgcGhyYXNlXG4gIC8vIHBocmFzZUNvdW50IC0gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBwaHJhc2VcbiAgLy8gZGF0YSAtIHVzZXItZGVmaW5lZCBkYXRhIHBhc3NlZCB0byB0aGUgdHJhbnNsYXRvclxuICAvLyAgICAgICAgZm9yIHVzZSBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyBAcmV0dXJuIGlkLlNFTV9PSywgbm9ybWFsIHJldHVybi5cbiAgLy8gICAgICAgICBpZC5TRU1fU0tJUCBpbiBzdGF0ZSBpZC5TRU1fUFJFIHdpbGxcbiAgLy8gICAgICAgICBza2lwIHRoZSBicmFuY2ggYmVsb3cuXG4gIC8vICAgICAgICAgQW55IHRoaW5nIGVsc2UgaXMgYW4gZXJyb3Igd2hpY2ggd2lsbFxuICAvLyAgICAgICAgIHN0b3AgdGhlIHRyYW5zbGF0aW9uLlxuICAvLyBgYGBgXG4gIC8qXG4gIGZ1bmN0aW9uIHNlbUNhbGxiYWNrUHJvdG90eXBlKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgbGV0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gICovXG4gIC8vIFRoZSBBU1QgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBzZW1GaWxlKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5ydWxlTmFtZXMgPSBuZXcgTmFtZUxpc3QoKTtcbiAgICAgIGRhdGEudWR0TmFtZXMgPSBuZXcgTmFtZUxpc3QoKTtcbiAgICAgIGRhdGEucnVsZXMgPSBbXTtcbiAgICAgIGRhdGEudWR0cyA9IFtdO1xuICAgICAgZGF0YS5ydWxlc0xpbmVNYXAgPSBbXTtcbiAgICAgIGRhdGEub3Bjb2RlcyA9IFtdO1xuICAgICAgZGF0YS5hbHRTdGFjayA9IFtdO1xuICAgICAgZGF0YS50b3BTdGFjayA9IG51bGw7XG4gICAgICBkYXRhLnRvcFJ1bGUgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICAvKiB2YWxpZGF0ZSBSTk0gcnVsZSBuYW1lcyBhbmQgc2V0IG9wY29kZSBydWxlIGluZGV4ICovXG4gICAgICBsZXQgbmFtZU9iajtcbiAgICAgIGRhdGEucnVsZXMuZm9yRWFjaCgocnVsZSkgPT4ge1xuICAgICAgICBydWxlLmlzQmtyID0gZmFsc2U7XG4gICAgICAgIHJ1bGUub3Bjb2Rlcy5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgIGlmIChvcC50eXBlID09PSBpZC5STk0pIHtcbiAgICAgICAgICAgIG5hbWVPYmogPSBkYXRhLnJ1bGVOYW1lcy5nZXQob3AuaW5kZXgubmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZU9iaiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBvcC5pbmRleC5waHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICAgICAgY2hhcjogb3AuaW5kZXgucGhyYXNlSW5kZXgsXG4gICAgICAgICAgICAgICAgbXNnOiBgUnVsZSBuYW1lICcke29wLmluZGV4Lm5hbWV9JyB1c2VkIGJ1dCBub3QgZGVmaW5lZC5gLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgb3AuaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wLmluZGV4ID0gbmFtZU9iai5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvKiB2YWxpZGF0ZSBCS1IgcnVsZSBuYW1lcyBhbmQgc2V0IG9wY29kZSBydWxlIGluZGV4ICovXG4gICAgICBkYXRhLnVkdHMuZm9yRWFjaCgodWR0KSA9PiB7XG4gICAgICAgIHVkdC5pc0JrciA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBkYXRhLnJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICAgICAgcnVsZS5vcGNvZGVzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgICAgaWYgKG9wLnR5cGUgPT09IGlkLkJLUikge1xuICAgICAgICAgICAgcnVsZS5oYXNCa3IgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZU9iaiA9IGRhdGEucnVsZU5hbWVzLmdldChvcC5pbmRleC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lT2JqICE9PSAtMSkge1xuICAgICAgICAgICAgICBkYXRhLnJ1bGVzW25hbWVPYmouaW5kZXhdLmlzQmtyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgb3AuaW5kZXggPSBuYW1lT2JqLmluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZU9iaiA9IGRhdGEudWR0TmFtZXMuZ2V0KG9wLmluZGV4Lm5hbWUpO1xuICAgICAgICAgICAgICBpZiAobmFtZU9iaiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnVkdHNbbmFtZU9iai5pbmRleF0uaXNCa3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wLmluZGV4ID0gZGF0YS5ydWxlcy5sZW5ndGggKyBuYW1lT2JqLmluZGV4O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBvcC5pbmRleC5waHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICAgICAgICBjaGFyOiBvcC5pbmRleC5waHJhc2VJbmRleCxcbiAgICAgICAgICAgICAgICAgIG1zZzogYEJhY2sgcmVmZXJlbmNlIG5hbWUgJyR7b3AuaW5kZXgubmFtZX0nIHJlZmVycyB0byB1bmRlZmluZWQgcnVsZSBvciB1bmFtZWQgVURULmAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3AuaW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SdWxlKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5hbHRTdGFjay5sZW5ndGggPSAwO1xuICAgICAgZGF0YS50b3BTdGFjayA9IG51bGw7XG4gICAgICBkYXRhLnJ1bGVzTGluZU1hcC5wdXNoKHtcbiAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUnVsZUxvb2t1cChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEucnVsZU5hbWUgPSAnJztcbiAgICAgIGRhdGEuZGVmaW5lZGFzID0gJyc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGxldCBydWxlTmFtZTtcbiAgICAgIGlmIChkYXRhLmRlZmluZWRhcyA9PT0gJz0nKSB7XG4gICAgICAgIHJ1bGVOYW1lID0gZGF0YS5ydWxlTmFtZXMuYWRkKGRhdGEucnVsZU5hbWUpO1xuICAgICAgICBpZiAocnVsZU5hbWUgPT09IC0xKSB7XG4gICAgICAgICAgZGF0YS5kZWZpbmVkYXMgPSBudWxsO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYFJ1bGUgbmFtZSAnJHtkYXRhLnJ1bGVOYW1lfScgcHJldmlvdXNseSBkZWZpbmVkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogc3RhcnQgYSBuZXcgcnVsZSAqL1xuICAgICAgICAgIGRhdGEudG9wUnVsZSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHJ1bGVOYW1lLm5hbWUsXG4gICAgICAgICAgICBsb3dlcjogcnVsZU5hbWUubG93ZXIsXG4gICAgICAgICAgICBvcGNvZGVzOiBbXSxcbiAgICAgICAgICAgIGluZGV4OiBydWxlTmFtZS5pbmRleCxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGRhdGEucnVsZXMucHVzaChkYXRhLnRvcFJ1bGUpO1xuICAgICAgICAgIGRhdGEub3Bjb2RlcyA9IGRhdGEudG9wUnVsZS5vcGNvZGVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBydWxlTmFtZSA9IGRhdGEucnVsZU5hbWVzLmdldChkYXRhLnJ1bGVOYW1lKTtcbiAgICAgICAgaWYgKHJ1bGVOYW1lID09PSAtMSkge1xuICAgICAgICAgIGRhdGEuZGVmaW5lZGFzID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBSdWxlIG5hbWUgJyR7ZGF0YS5ydWxlTmFtZX0nIGZvciBpbmNyZW1lbnRhbCBhbHRlcm5hdGUgbm90IHByZXZpb3VzbHkgZGVmaW5lZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEudG9wUnVsZSA9IGRhdGEucnVsZXNbcnVsZU5hbWUuaW5kZXhdO1xuICAgICAgICAgIGRhdGEub3Bjb2RlcyA9IGRhdGEudG9wUnVsZS5vcGNvZGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQWx0ZXJuYXRpb24oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBsZXQgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgICBpZiAoZGF0YS5kZWZpbmVkYXMgPT09IG51bGwpIHtcbiAgICAgICAgICAvKiBydWxlIGVycm9yIC0gc2tpcCBvcGNvZGUgZ2VuZXJhdGlvbiAqL1xuICAgICAgICAgIHJldCA9IGlkLlNFTV9TS0lQO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnRvcFN0YWNrID09PSBudWxsKSB7XG4gICAgICAgICAgLyogdG9wLWxldmVsIEFMVCAqL1xuICAgICAgICAgIGlmIChkYXRhLmRlZmluZWRhcyA9PT0gJz0nKSB7XG4gICAgICAgICAgICAvKiBcIj1cIiBuZXcgcnVsZSAqL1xuICAgICAgICAgICAgZGF0YS50b3BTdGFjayA9IHtcbiAgICAgICAgICAgICAgYWx0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogaWQuQUxULFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2F0OiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaChkYXRhLnRvcFN0YWNrKTtcbiAgICAgICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKGRhdGEudG9wU3RhY2suYWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBcIj0vXCIgaW5jcmVtZW50YWwgYWx0ZXJuYXRlICovXG4gICAgICAgICAgZGF0YS50b3BTdGFjayA9IHtcbiAgICAgICAgICAgIGFsdDogZGF0YS5vcGNvZGVzWzBdLFxuICAgICAgICAgICAgY2F0OiBudWxsLFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGF0YS5hbHRTdGFjay5wdXNoKGRhdGEudG9wU3RhY2spO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIGxvd2VyLWxldmVsIEFMVCAqL1xuICAgICAgICBkYXRhLnRvcFN0YWNrID0ge1xuICAgICAgICAgIGFsdDoge1xuICAgICAgICAgICAgdHlwZTogaWQuQUxULFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2F0OiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2goZGF0YS50b3BTdGFjayk7XG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKGRhdGEudG9wU3RhY2suYWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICBpZiAoZGF0YS5hbHRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRhdGEudG9wU3RhY2sgPSBkYXRhLmFsdFN0YWNrW2RhdGEuYWx0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnRvcFN0YWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Db25jYXRlbmF0aW9uKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS50b3BTdGFjay5hbHQuY2hpbGRyZW4ucHVzaChkYXRhLm9wY29kZXMubGVuZ3RoKTtcbiAgICAgIGRhdGEudG9wU3RhY2suY2F0ID0ge1xuICAgICAgICB0eXBlOiBpZC5DQVQsXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIH07XG4gICAgICBkYXRhLm9wY29kZXMucHVzaChkYXRhLnRvcFN0YWNrLmNhdCk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudG9wU3RhY2suY2F0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBldGl0aW9uKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS50b3BTdGFjay5jYXQuY2hpbGRyZW4ucHVzaChkYXRhLm9wY29kZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1PcHRpb25PcGVuKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuUkVQLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SdWxlTmFtZShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEucnVsZU5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1EZWZpbmVkKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuZGVmaW5lZGFzID0gJz0nO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUluY0FsdChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLmRlZmluZWRhcyA9ICc9Lyc7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLm1pbiA9IDA7XG4gICAgICBkYXRhLm1heCA9IEluZmluaXR5O1xuICAgICAgZGF0YS50b3BSZXAgPSB7XG4gICAgICAgIHR5cGU6IGlkLlJFUCxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IEluZmluaXR5LFxuICAgICAgfTtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKGRhdGEudG9wUmVwKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgaWYgKGRhdGEubWluID4gZGF0YS5tYXgpIHtcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgbXNnOiBgcmVwZXRpdGlvbiBtaW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXg6IG1pbjogJHtkYXRhLm1pbn06IG1heDogJHtkYXRhLm1heH1gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRhdGEudG9wUmVwLm1pbiA9IGRhdGEubWluO1xuICAgICAgZGF0YS50b3BSZXAubWF4ID0gZGF0YS5tYXg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtUmVwTWluKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWluID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVJlcE1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1SZXBNaW5NYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBkZWNudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgICBkYXRhLm1pbiA9IGRhdGEubWF4O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUFuZE9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQU5ELFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtTm90T3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5OT1QsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Sbm1PcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlJOTSxcbiAgICAgICAgLyogTk9URTogdGhpcyBpcyB0ZW1wb3JhcnkgaW5mbywgaW5kZXggd2lsbCBiZSByZXBsYWNlZCB3aXRoIGludGVnZXIgbGF0ZXIuICovXG4gICAgICAgIC8qIFByb2JhYmx5IG5vdCB0aGUgYmVzdCBjb2RpbmcgcHJhY3RpY2UgYnV0IGhlcmUgeW91IGdvLiAqL1xuICAgICAgICBpbmRleDoge1xuICAgICAgICAgIHBocmFzZUluZGV4LFxuICAgICAgICAgIG5hbWU6IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQWJnT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5BQkcsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1BZW5PcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkFFTixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrYU9wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuQktBLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQmtuT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICB0eXBlOiBpZC5CS04sXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1Ca3JPcChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgIGRhdGEuY2kgPSB0cnVlOyAvKiBkZWZhdWx0IHRvIGNhc2UgaW5zZW5zaXRpdmUgKi9cbiAgICAgIGRhdGEuY3MgPSBmYWxzZTtcbiAgICAgIGRhdGEudW0gPSB0cnVlO1xuICAgICAgZGF0YS5wbSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLkJLUixcbiAgICAgICAgYmtyQ2FzZTogZGF0YS5jcyA9PT0gdHJ1ZSA/IGlkLkJLUl9NT0RFX0NTIDogaWQuQktSX01PREVfQ0ksXG4gICAgICAgIGJrck1vZGU6IGRhdGEucG0gPT09IHRydWUgPyBpZC5CS1JfTU9ERV9QTSA6IGlkLkJLUl9NT0RFX1VNLFxuICAgICAgICAvKiBOT1RFOiB0aGlzIGlzIHRlbXBvcmFyeSBpbmZvLCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggaW50ZWdlciBsYXRlci4gKi9cbiAgICAgICAgLyogUHJvYmFibHkgbm90IHRoZSBiZXN0IGNvZGluZyBwcmFjdGljZSBidXQgaGVyZSB5b3UgZ28uICovXG4gICAgICAgIGluZGV4OiB7XG4gICAgICAgICAgcGhyYXNlSW5kZXg6IGRhdGEuYmtybmFtZS5waHJhc2VJbmRleCxcbiAgICAgICAgICBuYW1lOiBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgZGF0YS5ia3JuYW1lLnBocmFzZUluZGV4LCBkYXRhLmJrcm5hbWUucGhyYXNlTGVuZ3RoKSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrckNpKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuY2kgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrckNzKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEuY3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrclVtKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEudW0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrclBtKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEucG0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJrck5hbWUoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5ia3JuYW1lID0ge1xuICAgICAgICBwaHJhc2VJbmRleCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBwaHJhc2VDb3VudCxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVWR0RW1wdHkoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgICAgbGV0IHVkdE5hbWUgPSBkYXRhLnVkdE5hbWVzLmFkZChuYW1lKTtcbiAgICAgIGlmICh1ZHROYW1lID09PSAtMSkge1xuICAgICAgICB1ZHROYW1lID0gZGF0YS51ZHROYW1lcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICh1ZHROYW1lID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VtVWR0RW1wdHk6IG5hbWUgbG9vayB1cCBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnVkdHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogdWR0TmFtZS5uYW1lLFxuICAgICAgICAgIGxvd2VyOiB1ZHROYW1lLmxvd2VyLFxuICAgICAgICAgIGluZGV4OiB1ZHROYW1lLmluZGV4LFxuICAgICAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuVURULFxuICAgICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgICAgaW5kZXg6IHVkdE5hbWUuaW5kZXgsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1VZHROb25FbXB0eShzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgICBsZXQgdWR0TmFtZSA9IGRhdGEudWR0TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgaWYgKHVkdE5hbWUgPT09IC0xKSB7XG4gICAgICAgIHVkdE5hbWUgPSBkYXRhLnVkdE5hbWVzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHVkdE5hbWUgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW1VZHROb25FbXB0eTogbmFtZSBsb29rIHVwIGVycm9yJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEudWR0cy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB1ZHROYW1lLm5hbWUsXG4gICAgICAgICAgbG93ZXI6IHVkdE5hbWUubG93ZXIsXG4gICAgICAgICAgaW5kZXg6IHVkdE5hbWUuaW5kZXgsXG4gICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuVURULFxuICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgIGluZGV4OiB1ZHROYW1lLmluZGV4LFxuICAgICAgICBzeW50YXg6IG51bGwsXG4gICAgICAgIHNlbWFudGljOiBudWxsLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVGxzT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnRsc2Nhc2UgPSB0cnVlOyAvKiBkZWZhdWx0IHRvIGNhc2UgaW5zZW5zaXRpdmUgKi9cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1UbHNDYXNlKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChwaHJhc2VDb3VudCA+IDAgJiYgKGNoYXJzW3BocmFzZUluZGV4ICsgMV0gPT09IDgzIHx8IGNoYXJzW3BocmFzZUluZGV4ICsgMV0gPT09IDExNSkpIHtcbiAgICAgICAgZGF0YS50bHNjYXNlID0gZmFsc2U7IC8qIHNldCB0byBjYXNlIHNlbnNpdGl2ZSAqL1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRsc1N0cmluZyhzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAoZGF0YS50bHNjYXNlKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IGNoYXJzLnNsaWNlKHBocmFzZUluZGV4LCBwaHJhc2VJbmRleCArIHBocmFzZUNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoc3RyW2ldID49IDY1ICYmIHN0cltpXSA8PSA5MCkge1xuICAgICAgICAgICAgc3RyW2ldICs9IDMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogaWQuVExTLFxuICAgICAgICAgIHN0cmluZzogc3RyLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpZC5UQlMsXG4gICAgICAgICAgc3RyaW5nOiBjaGFycy5zbGljZShwaHJhc2VJbmRleCwgcGhyYXNlSW5kZXggKyBwaHJhc2VDb3VudCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUNsc09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGlmIChwaHJhc2VDb3VudCA8PSAyKSB7XG4gICAgICAgIC8qIG9ubHkgVExTIGlzIGFsbG93ZWQgdG8gYmUgZW1wdHkgKi9cbiAgICAgICAgZGF0YS5vcGNvZGVzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGlkLlRMUyxcbiAgICAgICAgICBzdHJpbmc6IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBpZC5UQlMsXG4gICAgICAgICAgc3RyaW5nOiBjaGFycy5zbGljZShwaHJhc2VJbmRleCArIDEsIHBocmFzZUluZGV4ICsgcGhyYXNlQ291bnQgLSAxKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtVGJzT3Aoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICBkYXRhLnRic3N0ciA9IFtdO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm9wY29kZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IGlkLlRCUyxcbiAgICAgICAgc3RyaW5nOiBkYXRhLnRic3N0cixcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVRyZ09wKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgZGF0YS5taW4gPSAwO1xuICAgICAgZGF0YS5tYXggPSAwO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBpZiAoZGF0YS5taW4gPiBkYXRhLm1heCkge1xuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6IGBUUkcsICglZG1pbi1tYXgpLCBtaW4gY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBtYXg6IG1pbjogJHtkYXRhLm1pbn06IG1heDogJHtkYXRhLm1heH1gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRhdGEub3Bjb2Rlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogaWQuVFJHLFxuICAgICAgICBtaW46IGRhdGEubWluLFxuICAgICAgICBtYXg6IGRhdGEubWF4LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtRG1pbihzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1pbiA9IGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1EbWF4KHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWF4ID0gZGVjbnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbUJtaW4oc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5taW4gPSBiaW5udW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQm1heChzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLm1heCA9IGJpbm51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBzZW1YbWluKHN0YXRlLCBjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50LCBkYXRhKSB7XG4gICAgY29uc3QgcmV0ID0gaWQuU0VNX09LO1xuICAgIGlmIChzdGF0ZSA9PT0gaWQuU0VNX1BPU1QpIHtcbiAgICAgIGRhdGEubWluID0gaGV4bnVtKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGZ1bmN0aW9uIHNlbVhtYXgoc3RhdGUsIGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlQ291bnQsIGRhdGEpIHtcbiAgICBjb25zdCByZXQgPSBpZC5TRU1fT0s7XG4gICAgaWYgKHN0YXRlID09PSBpZC5TRU1fUE9TVCkge1xuICAgICAgZGF0YS5tYXggPSBoZXhudW0oY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtRHN0cmluZyhzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnRic3N0ci5wdXNoKGRlY251bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtQnN0cmluZyhzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnRic3N0ci5wdXNoKGJpbm51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZnVuY3Rpb24gc2VtWHN0cmluZyhzdGF0ZSwgY2hhcnMsIHBocmFzZUluZGV4LCBwaHJhc2VDb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHJldCA9IGlkLlNFTV9PSztcbiAgICBpZiAoc3RhdGUgPT09IGlkLlNFTV9QT1NUKSB7XG4gICAgICBkYXRhLnRic3N0ci5wdXNoKGhleG51bShjaGFycywgcGhyYXNlSW5kZXgsIHBocmFzZUNvdW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLy8gRGVmaW5lIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMgdG8gdGhlIEFTVCBvYmplY3QuXG4gIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIHRoaXMuY2FsbGJhY2tzLmFiZ29wID0gc2VtQWJnT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmFlbm9wID0gc2VtQWVuT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmFsdGVybmF0aW9uID0gc2VtQWx0ZXJuYXRpb247XG4gIHRoaXMuY2FsbGJhY2tzLmFuZG9wID0gc2VtQW5kT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJtYXggPSBzZW1CbWF4O1xuICB0aGlzLmNhbGxiYWNrcy5ibWluID0gc2VtQm1pbjtcbiAgdGhpcy5jYWxsYmFja3MuYmthb3AgPSBzZW1Ca2FPcDtcbiAgdGhpcy5jYWxsYmFja3MuYmtub3AgPSBzZW1Ca25PcDtcbiAgdGhpcy5jYWxsYmFja3MuYmtyb3AgPSBzZW1Ca3JPcDtcbiAgdGhpcy5jYWxsYmFja3NbJ2Jrci1uYW1lJ10gPSBzZW1Ca3JOYW1lO1xuICB0aGlzLmNhbGxiYWNrcy5ic3RyaW5nID0gc2VtQnN0cmluZztcbiAgdGhpcy5jYWxsYmFja3MuY2xzb3AgPSBzZW1DbHNPcDtcbiAgdGhpcy5jYWxsYmFja3MuY2kgPSBzZW1Ca3JDaTtcbiAgdGhpcy5jYWxsYmFja3MuY3MgPSBzZW1Ca3JDcztcbiAgdGhpcy5jYWxsYmFja3MudW0gPSBzZW1Ca3JVbTtcbiAgdGhpcy5jYWxsYmFja3MucG0gPSBzZW1Ca3JQbTtcbiAgdGhpcy5jYWxsYmFja3MuY29uY2F0ZW5hdGlvbiA9IHNlbUNvbmNhdGVuYXRpb247XG4gIHRoaXMuY2FsbGJhY2tzLmRlZmluZWQgPSBzZW1EZWZpbmVkO1xuICB0aGlzLmNhbGxiYWNrcy5kbWF4ID0gc2VtRG1heDtcbiAgdGhpcy5jYWxsYmFja3MuZG1pbiA9IHNlbURtaW47XG4gIHRoaXMuY2FsbGJhY2tzLmRzdHJpbmcgPSBzZW1Ec3RyaW5nO1xuICB0aGlzLmNhbGxiYWNrcy5maWxlID0gc2VtRmlsZTtcbiAgdGhpcy5jYWxsYmFja3MuaW5jYWx0ID0gc2VtSW5jQWx0O1xuICB0aGlzLmNhbGxiYWNrcy5ub3RvcCA9IHNlbU5vdE9wO1xuICB0aGlzLmNhbGxiYWNrcy5vcHRpb25vcGVuID0gc2VtT3B0aW9uT3BlbjtcbiAgdGhpcy5jYWxsYmFja3NbJ3JlcC1tYXgnXSA9IHNlbVJlcE1heDtcbiAgdGhpcy5jYWxsYmFja3NbJ3JlcC1taW4nXSA9IHNlbVJlcE1pbjtcbiAgdGhpcy5jYWxsYmFja3NbJ3JlcC1taW4tbWF4J10gPSBzZW1SZXBNaW5NYXg7XG4gIHRoaXMuY2FsbGJhY2tzLnJlcGV0aXRpb24gPSBzZW1SZXBldGl0aW9uO1xuICB0aGlzLmNhbGxiYWNrcy5yZXBvcCA9IHNlbVJlcE9wO1xuICB0aGlzLmNhbGxiYWNrcy5ybm1vcCA9IHNlbVJubU9wO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlID0gc2VtUnVsZTtcbiAgdGhpcy5jYWxsYmFja3MucnVsZWxvb2t1cCA9IHNlbVJ1bGVMb29rdXA7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGVuYW1lID0gc2VtUnVsZU5hbWU7XG4gIHRoaXMuY2FsbGJhY2tzLnRic29wID0gc2VtVGJzT3A7XG4gIHRoaXMuY2FsbGJhY2tzLnRsc2Nhc2UgPSBzZW1UbHNDYXNlO1xuICB0aGlzLmNhbGxiYWNrcy50bHNzdHJpbmcgPSBzZW1UbHNTdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLnRsc29wID0gc2VtVGxzT3A7XG4gIHRoaXMuY2FsbGJhY2tzLnRyZ29wID0gc2VtVHJnT3A7XG4gIHRoaXMuY2FsbGJhY2tzWyd1ZHQtZW1wdHknXSA9IHNlbVVkdEVtcHR5O1xuICB0aGlzLmNhbGxiYWNrc1sndWR0LW5vbi1lbXB0eSddID0gc2VtVWR0Tm9uRW1wdHk7XG4gIHRoaXMuY2FsbGJhY2tzLnhtYXggPSBzZW1YbWF4O1xuICB0aGlzLmNhbGxiYWNrcy54bWluID0gc2VtWG1pbjtcbiAgdGhpcy5jYWxsYmFja3MueHN0cmluZyA9IHNlbVhzdHJpbmc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/semantic-callbacks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/show-rules.js":
/*!*******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/show-rules.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\nmodule.exports = (function exfn() {\n  const thisFileName = 'show-rules.js';\n  // Display the rules.\n  // This function may be called before the attributes calculation.\n  // Sorting is done independently from the attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  const showRules = function showRules(rulesIn = [], udtsIn = [], order = 'index') {\n    const thisFuncName = 'showRules';\n    let alphaArray = [];\n    let udtAlphaArray = [];\n    const indexArray = [];\n    const udtIndexArray = [];\n    const rules = rulesIn;\n    const udts = udtsIn;\n    const ruleCount = rulesIn.length;\n    const udtCount = udtsIn.length;\n    let str = 'RULE/UDT NAMES';\n    let i;\n    function compRulesAlpha(left, right) {\n      if (rules[left].lower < rules[right].lower) {\n        return -1;\n      }\n      if (rules[left].lower > rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    function compUdtsAlpha(left, right) {\n      if (udts[left].lower < udts[right].lower) {\n        return -1;\n      }\n      if (udts[left].lower > udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n    }\n    if (!Array.isArray(udtsIn)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n    }\n\n    for (i = 0; i < ruleCount; i += 1) {\n      indexArray.push(i);\n    }\n    alphaArray = indexArray.slice(0);\n    alphaArray.sort(compRulesAlpha);\n    if (udtCount) {\n      for (i = 0; i < udtCount; i += 1) {\n        udtIndexArray.push(i);\n      }\n      udtAlphaArray = udtIndexArray.slice(0);\n      udtAlphaArray.sort(compUdtsAlpha);\n    }\n    if (order.charCodeAt(0) === 97) {\n      str += ' - alphabetical by rule/UDT name\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n        }\n      }\n    } else {\n      str += ' - ordered by rule/UDT index\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${rules[i].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udts[i].name}\\n`;\n        }\n      }\n    }\n    return str;\n  };\n  return showRules;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3Nob3ctcnVsZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhLEdBQUcsYUFBYTtBQUN0RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsR0FBRyxhQUFhO0FBQ3REOztBQUVBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYyxJQUFJLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSw0QkFBNEI7QUFDM0U7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixFQUFFLElBQUksY0FBYztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEMsb0JBQW9CLEVBQUUsSUFBSSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc2hvdy1ydWxlcy5qcz9iZTU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIGV4Zm4oKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzaG93LXJ1bGVzLmpzJztcbiAgLy8gRGlzcGxheSB0aGUgcnVsZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGF0dHJpYnV0ZXMgY2FsY3VsYXRpb24uXG4gIC8vIFNvcnRpbmcgaXMgZG9uZSBpbmRlcGVuZGVudGx5IGZyb20gdGhlIGF0dHJpYnV0ZXMuXG4gIC8vIC0gb3JkZXJcbiAgLy8gICAgICAtIFwiaW5kZXhcIiBvciBcImlcIiwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIC8vICAgICAgLSBcImFscGhhXCIgb3IgXCJhXCIsIGFscGhhYmV0aWNhbCBvcmRlclxuICAvLyAgICAgIC0gbm9uZSBvZiBhYm92ZSwgaW5kZXggb3JkZXIgKGRlZmF1bHQpXG4gIGNvbnN0IHNob3dSdWxlcyA9IGZ1bmN0aW9uIHNob3dSdWxlcyhydWxlc0luID0gW10sIHVkdHNJbiA9IFtdLCBvcmRlciA9ICdpbmRleCcpIHtcbiAgICBjb25zdCB0aGlzRnVuY05hbWUgPSAnc2hvd1J1bGVzJztcbiAgICBsZXQgYWxwaGFBcnJheSA9IFtdO1xuICAgIGxldCB1ZHRBbHBoYUFycmF5ID0gW107XG4gICAgY29uc3QgaW5kZXhBcnJheSA9IFtdO1xuICAgIGNvbnN0IHVkdEluZGV4QXJyYXkgPSBbXTtcbiAgICBjb25zdCBydWxlcyA9IHJ1bGVzSW47XG4gICAgY29uc3QgdWR0cyA9IHVkdHNJbjtcbiAgICBjb25zdCBydWxlQ291bnQgPSBydWxlc0luLmxlbmd0aDtcbiAgICBjb25zdCB1ZHRDb3VudCA9IHVkdHNJbi5sZW5ndGg7XG4gICAgbGV0IHN0ciA9ICdSVUxFL1VEVCBOQU1FUyc7XG4gICAgbGV0IGk7XG4gICAgZnVuY3Rpb24gY29tcFJ1bGVzQWxwaGEobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmIChydWxlc1tsZWZ0XS5sb3dlciA8IHJ1bGVzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAocnVsZXNbbGVmdF0ubG93ZXIgPiBydWxlc1tyaWdodF0ubG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcFVkdHNBbHBoYShsZWZ0LCByaWdodCkge1xuICAgICAgaWYgKHVkdHNbbGVmdF0ubG93ZXIgPCB1ZHRzW3JpZ2h0XS5sb3dlcikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAodWR0c1tsZWZ0XS5sb3dlciA+IHVkdHNbcmlnaHRdLmxvd2VyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghKEFycmF5LmlzQXJyYXkocnVsZXNJbikgJiYgcnVsZXNJbi5sZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfToke3RoaXNGdW5jTmFtZX06IHJ1bGVzIGFyZyBtdXN0IGJlIGFycmF5IHdpdGggbGVuZ3RoID4gMGApO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodWR0c0luKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX06JHt0aGlzRnVuY05hbWV9OiB1ZHRzIGFyZyBtdXN0IGJlIGFycmF5YCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVDb3VudDsgaSArPSAxKSB7XG4gICAgICBpbmRleEFycmF5LnB1c2goaSk7XG4gICAgfVxuICAgIGFscGhhQXJyYXkgPSBpbmRleEFycmF5LnNsaWNlKDApO1xuICAgIGFscGhhQXJyYXkuc29ydChjb21wUnVsZXNBbHBoYSk7XG4gICAgaWYgKHVkdENvdW50KSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdWR0Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICB1ZHRJbmRleEFycmF5LnB1c2goaSk7XG4gICAgICB9XG4gICAgICB1ZHRBbHBoYUFycmF5ID0gdWR0SW5kZXhBcnJheS5zbGljZSgwKTtcbiAgICAgIHVkdEFscGhhQXJyYXkuc29ydChjb21wVWR0c0FscGhhKTtcbiAgICB9XG4gICAgaWYgKG9yZGVyLmNoYXJDb2RlQXQoMCkgPT09IDk3KSB7XG4gICAgICBzdHIgKz0gJyAtIGFscGhhYmV0aWNhbCBieSBydWxlL1VEVCBuYW1lXFxuJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBydWxlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYCR7aX06ICR7YWxwaGFBcnJheVtpXX06ICR7cnVsZXNbYWxwaGFBcnJheVtpXV0ubmFtZX1cXG5gO1xuICAgICAgfVxuICAgICAgaWYgKHVkdENvdW50KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRDb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgc3RyICs9IGAke2l9OiAke3VkdEFscGhhQXJyYXlbaV19OiAke3VkdHNbdWR0QWxwaGFBcnJheVtpXV0ubmFtZX1cXG5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnIC0gb3JkZXJlZCBieSBydWxlL1VEVCBpbmRleFxcbic7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZUNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGAke2l9OiAke3J1bGVzW2ldLm5hbWV9XFxuYDtcbiAgICAgIH1cbiAgICAgIGlmICh1ZHRDb3VudCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdWR0Q291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgIHN0ciArPSBgJHtpfTogJHt1ZHRzW2ldLm5hbWV9XFxuYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICByZXR1cm4gc2hvd1J1bGVzO1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/show-rules.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-api/syntax-callbacks.js":
/*!*************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-api/syntax-callbacks.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const thisFileName = 'syntax-callbacks.js: ';\n  const apglib = __webpack_require__(/*! ../apg-lib/node-exports */ \"(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\");\n  const id = apglib.ids;\n  let topAlt;\n  /* syntax, RNM, callback functions */\n  const synFile = function synFile(result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack = [];\n        data.repCount = 0;\n        break;\n      case id.EMPTY:\n        data.errors.push({\n          line: 0,\n          char: 0,\n          msg: 'grammar file is empty',\n        });\n        break;\n      case id.MATCH:\n        if (data.ruleCount === 0) {\n          data.errors.push({\n            line: 0,\n            char: 0,\n            msg: 'no rules defined',\n          });\n        }\n        break;\n      case id.NOMATCH:\n        throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // eslint-disable-next-line func-names\n  const synRule = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack.length = 0;\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      case id.EMPTY:\n        throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.ruleCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized SABNF line. Invalid rule, comment or blank line.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleNameError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Rule names must be alphanum and begin with alphabetic character.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synDefinedAsError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: \"Expected '=' or '=/'. Not found.\",\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAndOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'AND operator(&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synNotOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'NOT operator(!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkaOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBknOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAbgOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAenOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkrOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - strict ABNF specified.`,\n          });\n        } else if (data.lite) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - apg-lite specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synUdtOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `UDT operator found(${name}) - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\",\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synStringTab = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.stringTabChar = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.tlsOpen),\n          char: topAlt.tlsOpen,\n          msg: 'Case-insensitive literal string(\"...\") opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.tlsOpen = null;\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.clsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in literal string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.clsOpen),\n          char: topAlt.clsOpen,\n          msg: \"Case-sensitive literal string('...') opened but not closed.\",\n        });\n        topAlt.clsOpen = null;\n        topAlt.basicError = true;\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, topAlt.clsOpen),\n            char: topAlt.clsOpen,\n            msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\",\n          });\n        }\n        topAlt.clsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.prosValOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in prose value string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.prosValOpen = null;\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.',\n        });\n        topAlt.prosValOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: phraseIndex,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.groupOpen),\n          char: topAlt.groupOpen,\n          msg: 'Group \"(...)\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.groupError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: phraseIndex,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.optionOpen),\n          char: topAlt.optionOpen,\n          msg: 'Option \"[...]\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.optionError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBasicElementError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (topAlt.basicError === false) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Unrecognized SABNF element.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEnd = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (result.phraseLength === 1 && data.strict) {\n          const end = chars[phraseIndex] === 13 ? 'CR' : 'LF';\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEndError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized grammar element or characters.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRepetition = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.repCount += 1;\n        break;\n      case id.MATCH:\n        data.repCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // Define the list of callback functions.\n  this.callbacks = [];\n  this.callbacks.andop = synAndOp;\n  this.callbacks.basicelementerr = synBasicElementError;\n  this.callbacks.clsclose = synClsClose;\n  this.callbacks.clsopen = synClsOpen;\n  this.callbacks.clsstring = synClsString;\n  this.callbacks.definedaserror = synDefinedAsError;\n  this.callbacks.file = synFile;\n  this.callbacks.groupclose = synGroupClose;\n  this.callbacks.groupopen = synGroupOpen;\n  this.callbacks.lineenderror = synLineEndError;\n  this.callbacks.lineend = synLineEnd;\n  this.callbacks.notop = synNotOp;\n  this.callbacks.optionclose = synOptionClose;\n  this.callbacks.optionopen = synOptionOpen;\n  this.callbacks.prosvalclose = synProsValClose;\n  this.callbacks.prosvalopen = synProsValOpen;\n  this.callbacks.prosvalstring = synProsValString;\n  this.callbacks.repetition = synRepetition;\n  this.callbacks.rule = synRule;\n  this.callbacks.ruleerror = synRuleError;\n  this.callbacks.rulenameerror = synRuleNameError;\n  this.callbacks.stringtab = synStringTab;\n  this.callbacks.tlsclose = synTlsClose;\n  this.callbacks.tlsopen = synTlsOpen;\n  this.callbacks.tlsstring = synTlsString;\n  this.callbacks.udtop = synUdtOp;\n  this.callbacks.bkaop = synBkaOp;\n  this.callbacks.bknop = synBknOp;\n  this.callbacks.bkrop = synBkrOp;\n  this.callbacks.abgop = synAbgOp;\n  this.callbacks.aenop = synAenOp;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctYXBpL3N5bnRheC1jYWxsYmFja3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxLQUFLO0FBQ2pELFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1hcGkvc3ludGF4LWNhbGxiYWNrcy5qcz82N2E5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGhhcyBhbGwgb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIHN5bnRheCBwaGFzZSBvZiB0aGUgZ2VuZXJhdGlvbi5cbi8vIFNlZTo8YnI+XG4vLyBgLi9kaXN0L2FibmYtZm9yLXNhYm5mLWdyYW1tYXIuYm5mYDxicj5cbi8vIGZvciB0aGUgZ3JhbW1hciBmaWxlIHRoZXNlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhcmUgYmFzZWQgb24uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4Zm4oKSB7XG4gIGNvbnN0IHRoaXNGaWxlTmFtZSA9ICdzeW50YXgtY2FsbGJhY2tzLmpzOiAnO1xuICBjb25zdCBhcGdsaWIgPSByZXF1aXJlKCcuLi9hcGctbGliL25vZGUtZXhwb3J0cycpO1xuICBjb25zdCBpZCA9IGFwZ2xpYi5pZHM7XG4gIGxldCB0b3BBbHQ7XG4gIC8qIHN5bnRheCwgUk5NLCBjYWxsYmFjayBmdW5jdGlvbnMgKi9cbiAgY29uc3Qgc3luRmlsZSA9IGZ1bmN0aW9uIHN5bkZpbGUocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuYWx0U3RhY2sgPSBbXTtcbiAgICAgICAgZGF0YS5yZXBDb3VudCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICBjaGFyOiAwLFxuICAgICAgICAgIG1zZzogJ2dyYW1tYXIgZmlsZSBpcyBlbXB0eScsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnJ1bGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogMCxcbiAgICAgICAgICAgIGNoYXI6IDAsXG4gICAgICAgICAgICBtc2c6ICdubyBydWxlcyBkZWZpbmVkJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiBncmFtbWFyIGZpbGUgTk9NQVRDSDogZGVzaWduIGVycm9yOiBzaG91bGQgbmV2ZXIgaGFwcGVuLmApO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIGNvbnN0IHN5blJ1bGUgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGRhdGEuYWx0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogbnVsbCxcbiAgICAgICAgICBncm91cEVycm9yOiBmYWxzZSxcbiAgICAgICAgICBvcHRpb25PcGVuOiBudWxsLFxuICAgICAgICAgIG9wdGlvbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICB0bHNPcGVuOiBudWxsLFxuICAgICAgICAgIGNsc09wZW46IG51bGwsXG4gICAgICAgICAgcHJvc1ZhbE9wZW46IG51bGwsXG4gICAgICAgICAgYmFzaWNFcnJvcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaCh0b3BBbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luUnVsZTogRU1QVFk6IHJ1bGUgY2Fubm90IGJlIGVtcHR5YCk7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5ydWxlQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUnVsZUVycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogJ1VucmVjb2duaXplZCBTQUJORiBsaW5lLiBJbnZhbGlkIHJ1bGUsIGNvbW1lbnQgb3IgYmxhbmsgbGluZS4nLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUnVsZU5hbWVFcnJvciA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBtc2c6ICdSdWxlIG5hbWVzIG11c3QgYmUgYWxwaGFudW0gYW5kIGJlZ2luIHdpdGggYWxwaGFiZXRpYyBjaGFyYWN0ZXIuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkRlZmluZWRBc0Vycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogXCJFeHBlY3RlZCAnPScgb3IgJz0vJy4gTm90IGZvdW5kLlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQW5kT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQU5EIG9wZXJhdG9yKCYpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luTm90T3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTk9UIG9wZXJhdG9yKCEpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmthT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnUG9zaXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoJiYpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5saXRlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnUG9zaXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoJiYpIGZvdW5kIC0gYXBnLWxpdGUgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmtuT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTmVnYXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoISEpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5saXRlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnTmVnYXRpdmUgbG9vay1iZWhpbmQgb3BlcmF0b3IoISEpIGZvdW5kIC0gYXBnLWxpdGUgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQWJnT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQmVnaW5uaW5nIG9mIHN0cmluZyBhbmNob3IoJV4pIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5saXRlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnQmVnaW5uaW5nIG9mIHN0cmluZyBhbmNob3IoJV4pIGZvdW5kIC0gYXBnLWxpdGUgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQWVuT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnRW5kIG9mIHN0cmluZyBhbmNob3IoJSQpIGZvdW5kIC0gc3RyaWN0IEFCTkYgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5saXRlKSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiAnRW5kIG9mIHN0cmluZyBhbmNob3IoJSQpIGZvdW5kIC0gYXBnLWxpdGUgc3BlY2lmaWVkLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQmtyT3AgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IGFwZ2xpYi51dGlscy5jaGFyc1RvU3RyaW5nKGNoYXJzLCBwaHJhc2VJbmRleCwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgQmFjayByZWZlcmVuY2Ugb3BlcmF0b3IoJHtuYW1lfSkgZm91bmQgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuYCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmxpdGUpIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYXBnbGliLnV0aWxzLmNoYXJzVG9TdHJpbmcoY2hhcnMsIHBocmFzZUluZGV4LCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6IGBCYWNrIHJlZmVyZW5jZSBvcGVyYXRvcigke25hbWV9KSBmb3VuZCAtIGFwZy1saXRlIHNwZWNpZmllZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blVkdE9wID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChkYXRhLnN0cmljdCkge1xuICAgICAgICAgIGNvbnN0IG5hbWUgPSBhcGdsaWIudXRpbHMuY2hhcnNUb1N0cmluZyhjaGFycywgcGhyYXNlSW5kZXgsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBwaHJhc2VJbmRleCwgZGF0YS5jaGFyc0xlbmd0aCksXG4gICAgICAgICAgICBjaGFyOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICAgIG1zZzogYFVEVCBvcGVyYXRvciBmb3VuZCgke25hbWV9KSAtIHN0cmljdCBBQk5GIHNwZWNpZmllZC5gLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blRsc09wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0LnRsc09wZW4gPSBwaHJhc2VJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luVGxzU3RyaW5nID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBkYXRhLnN0cmluZ1RhYkNoYXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBpZiAoZGF0YS5zdHJpbmdUYWJDaGFyICE9PSBmYWxzZSkge1xuICAgICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCBkYXRhLnN0cmluZ1RhYkNoYXIpLFxuICAgICAgICAgICAgY2hhcjogZGF0YS5zdHJpbmdUYWJDaGFyLFxuICAgICAgICAgICAgbXNnOiBcIlRhYiBjaGFyYWN0ZXIgKFxcXFx0LCB4MDkpIG5vdCBhbGxvd2VkIGluIGxpdGVyYWwgc3RyaW5nIChzZWUgJ3F1b3RlZC1zdHJpbmcnIGRlZmluaXRpb24sIFJGQyA3NDA1LilcIixcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5TdHJpbmdUYWIgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5zdHJpbmdUYWJDaGFyID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blRsc0Nsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC50bHNPcGVuKSxcbiAgICAgICAgICBjaGFyOiB0b3BBbHQudGxzT3BlbixcbiAgICAgICAgICBtc2c6ICdDYXNlLWluc2Vuc2l0aXZlIGxpdGVyYWwgc3RyaW5nKFwiLi4uXCIpIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0LmJhc2ljRXJyb3IgPSB0cnVlO1xuICAgICAgICB0b3BBbHQudGxzT3BlbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0LnRsc09wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5DbHNPcGVuID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4KSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdC5jbHNPcGVuID0gcGhyYXNlSW5kZXg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkNsc1N0cmluZyA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgZGF0YS5zdHJpbmdUYWJDaGFyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaW5nVGFiQ2hhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgZGF0YS5zdHJpbmdUYWJDaGFyKSxcbiAgICAgICAgICAgIGNoYXI6IGRhdGEuc3RyaW5nVGFiQ2hhcixcbiAgICAgICAgICAgIG1zZzogJ1RhYiBjaGFyYWN0ZXIgKFxcXFx0LCB4MDkpIG5vdCBhbGxvd2VkIGluIGxpdGVyYWwgc3RyaW5nLicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luQ2xzQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0LmNsc09wZW4pLFxuICAgICAgICAgIGNoYXI6IHRvcEFsdC5jbHNPcGVuLFxuICAgICAgICAgIG1zZzogXCJDYXNlLXNlbnNpdGl2ZSBsaXRlcmFsIHN0cmluZygnLi4uJykgb3BlbmVkIGJ1dCBub3QgY2xvc2VkLlwiLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0LmNsc09wZW4gPSBudWxsO1xuICAgICAgICB0b3BBbHQuYmFzaWNFcnJvciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaWN0KSB7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5jbHNPcGVuKSxcbiAgICAgICAgICAgIGNoYXI6IHRvcEFsdC5jbHNPcGVuLFxuICAgICAgICAgICAgbXNnOiBcIkNhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcGVyYXRvcignLi4uJykgZm91bmQgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQuXCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9wQWx0LmNsc09wZW4gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Qcm9zVmFsT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQucHJvc1ZhbE9wZW4gPSBwaHJhc2VJbmRleDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUHJvc1ZhbFN0cmluZyA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgZGF0YS5zdHJpbmdUYWJDaGFyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKGRhdGEuc3RyaW5nVGFiQ2hhciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgZGF0YS5zdHJpbmdUYWJDaGFyKSxcbiAgICAgICAgICAgIGNoYXI6IGRhdGEuc3RyaW5nVGFiQ2hhcixcbiAgICAgICAgICAgIG1zZzogJ1RhYiBjaGFyYWN0ZXIgKFxcXFx0LCB4MDkpIG5vdCBhbGxvd2VkIGluIHByb3NlIHZhbHVlIHN0cmluZy4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5blByb3NWYWxDbG9zZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQucHJvc1ZhbE9wZW4pLFxuICAgICAgICAgIGNoYXI6IHRvcEFsdC5wcm9zVmFsT3BlbixcbiAgICAgICAgICBtc2c6ICdQcm9zZSB2YWx1ZSBvcGVyYXRvcig8Li4uPikgb3BlbmVkIGJ1dCBub3QgY2xvc2VkLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQuYmFzaWNFcnJvciA9IHRydWU7XG4gICAgICAgIHRvcEFsdC5wcm9zVmFsT3BlbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgbGluZTogZGF0YS5maW5kTGluZShkYXRhLmxpbmVzLCB0b3BBbHQucHJvc1ZhbE9wZW4pLFxuICAgICAgICAgIGNoYXI6IHRvcEFsdC5wcm9zVmFsT3BlbixcbiAgICAgICAgICBtc2c6ICdQcm9zZSB2YWx1ZSBvcGVyYXRvcig8Li4uPikgZm91bmQuIFRoZSBBQk5GIHN5bnRheCBpcyB2YWxpZCwgYnV0IGEgcGFyc2VyIGNhbm5vdCBiZSBnZW5lcmF0ZWQgZnJvbSB0aGlzIGdyYW1tYXIuJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRvcEFsdC5wcm9zVmFsT3BlbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkdyb3VwT3BlbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICB0b3BBbHQgPSB7XG4gICAgICAgICAgZ3JvdXBPcGVuOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBncm91cEVycm9yOiBmYWxzZSxcbiAgICAgICAgICBvcHRpb25PcGVuOiBudWxsLFxuICAgICAgICAgIG9wdGlvbkVycm9yOiBmYWxzZSxcbiAgICAgICAgICB0bHNPcGVuOiBudWxsLFxuICAgICAgICAgIGNsc09wZW46IG51bGwsXG4gICAgICAgICAgcHJvc1ZhbE9wZW46IG51bGwsXG4gICAgICAgICAgYmFzaWNFcnJvcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGRhdGEuYWx0U3RhY2sucHVzaCh0b3BBbHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9c3luRmlsZTogdW5yZWNvZ25pemVkIGNhc2UuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBzeW5Hcm91cENsb3NlID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHRvcEFsdC5ncm91cE9wZW4pLFxuICAgICAgICAgIGNoYXI6IHRvcEFsdC5ncm91cE9wZW4sXG4gICAgICAgICAgbXNnOiAnR3JvdXAgXCIoLi4uKVwiIG9wZW5lZCBidXQgbm90IGNsb3NlZC4nLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9wQWx0ID0gZGF0YS5hbHRTdGFjay5wb3AoKTtcbiAgICAgICAgdG9wQWx0Lmdyb3VwRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdCA9IGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bk9wdGlvbk9wZW4gPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgdG9wQWx0ID0ge1xuICAgICAgICAgIGdyb3VwT3BlbjogbnVsbCxcbiAgICAgICAgICBncm91cEVycm9yOiBmYWxzZSxcbiAgICAgICAgICBvcHRpb25PcGVuOiBwaHJhc2VJbmRleCxcbiAgICAgICAgICBvcHRpb25FcnJvcjogZmFsc2UsXG4gICAgICAgICAgdGxzT3BlbjogbnVsbCxcbiAgICAgICAgICBjbHNPcGVuOiBudWxsLFxuICAgICAgICAgIHByb3NWYWxPcGVuOiBudWxsLFxuICAgICAgICAgIGJhc2ljRXJyb3I6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBkYXRhLmFsdFN0YWNrLnB1c2godG9wQWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luT3B0aW9uQ2xvc2UgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgdG9wQWx0Lm9wdGlvbk9wZW4pLFxuICAgICAgICAgIGNoYXI6IHRvcEFsdC5vcHRpb25PcGVuLFxuICAgICAgICAgIG1zZzogJ09wdGlvbiBcIlsuLi5dXCIgb3BlbmVkIGJ1dCBub3QgY2xvc2VkLicsXG4gICAgICAgIH0pO1xuICAgICAgICB0b3BBbHQgPSBkYXRhLmFsdFN0YWNrLnBvcCgpO1xuICAgICAgICB0b3BBbHQub3B0aW9uRXJyb3IgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIHRvcEFsdCA9IGRhdGEuYWx0U3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkJhc2ljRWxlbWVudEVycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmICh0b3BBbHQuYmFzaWNFcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkYXRhLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgICAgY2hhcjogcGhyYXNlSW5kZXgsXG4gICAgICAgICAgICBtc2c6ICdVbnJlY29nbml6ZWQgU0FCTkYgZWxlbWVudC4nLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1zeW5GaWxlOiB1bnJlY29nbml6ZWQgY2FzZS5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN5bkxpbmVFbmQgPSBmdW5jdGlvbiAocmVzdWx0LCBjaGFycywgcGhyYXNlSW5kZXgsIGRhdGEpIHtcbiAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHJlc3VsdC5waHJhc2VMZW5ndGggPT09IDEgJiYgZGF0YS5zdHJpY3QpIHtcbiAgICAgICAgICBjb25zdCBlbmQgPSBjaGFyc1twaHJhc2VJbmRleF0gPT09IDEzID8gJ0NSJyA6ICdMRic7XG4gICAgICAgICAgZGF0YS5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiBkYXRhLmZpbmRMaW5lKGRhdGEubGluZXMsIHBocmFzZUluZGV4LCBkYXRhLmNoYXJzTGVuZ3RoKSxcbiAgICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgICAgbXNnOiBgTGluZSBlbmQgJyR7ZW5kfScgZm91bmQgLSBzdHJpY3QgQUJORiBzcGVjaWZpZWQsIG9ubHkgQ1JMRiBhbGxvd2VkLmAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luTGluZUVuZEVycm9yID0gZnVuY3Rpb24gKHJlc3VsdCwgY2hhcnMsIHBocmFzZUluZGV4LCBkYXRhKSB7XG4gICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEuZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IGRhdGEuZmluZExpbmUoZGF0YS5saW5lcywgcGhyYXNlSW5kZXgsIGRhdGEuY2hhcnNMZW5ndGgpLFxuICAgICAgICAgIGNoYXI6IHBocmFzZUluZGV4LFxuICAgICAgICAgIG1zZzogJ1VucmVjb2duaXplZCBncmFtbWFyIGVsZW1lbnQgb3IgY2hhcmFjdGVycy4nLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3luUmVwZXRpdGlvbiA9IGZ1bmN0aW9uIChyZXN1bHQsIGNoYXJzLCBwaHJhc2VJbmRleCwgZGF0YSkge1xuICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgZGF0YS5yZXBDb3VudCArPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGRhdGEucmVwQ291bnQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfXN5bkZpbGU6IHVucmVjb2duaXplZCBjYXNlLmApO1xuICAgIH1cbiAgfTtcbiAgLy8gRGVmaW5lIHRoZSBsaXN0IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5jYWxsYmFja3MuYW5kb3AgPSBzeW5BbmRPcDtcbiAgdGhpcy5jYWxsYmFja3MuYmFzaWNlbGVtZW50ZXJyID0gc3luQmFzaWNFbGVtZW50RXJyb3I7XG4gIHRoaXMuY2FsbGJhY2tzLmNsc2Nsb3NlID0gc3luQ2xzQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLmNsc29wZW4gPSBzeW5DbHNPcGVuO1xuICB0aGlzLmNhbGxiYWNrcy5jbHNzdHJpbmcgPSBzeW5DbHNTdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLmRlZmluZWRhc2Vycm9yID0gc3luRGVmaW5lZEFzRXJyb3I7XG4gIHRoaXMuY2FsbGJhY2tzLmZpbGUgPSBzeW5GaWxlO1xuICB0aGlzLmNhbGxiYWNrcy5ncm91cGNsb3NlID0gc3luR3JvdXBDbG9zZTtcbiAgdGhpcy5jYWxsYmFja3MuZ3JvdXBvcGVuID0gc3luR3JvdXBPcGVuO1xuICB0aGlzLmNhbGxiYWNrcy5saW5lZW5kZXJyb3IgPSBzeW5MaW5lRW5kRXJyb3I7XG4gIHRoaXMuY2FsbGJhY2tzLmxpbmVlbmQgPSBzeW5MaW5lRW5kO1xuICB0aGlzLmNhbGxiYWNrcy5ub3RvcCA9IHN5bk5vdE9wO1xuICB0aGlzLmNhbGxiYWNrcy5vcHRpb25jbG9zZSA9IHN5bk9wdGlvbkNsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy5vcHRpb25vcGVuID0gc3luT3B0aW9uT3BlbjtcbiAgdGhpcy5jYWxsYmFja3MucHJvc3ZhbGNsb3NlID0gc3luUHJvc1ZhbENsb3NlO1xuICB0aGlzLmNhbGxiYWNrcy5wcm9zdmFsb3BlbiA9IHN5blByb3NWYWxPcGVuO1xuICB0aGlzLmNhbGxiYWNrcy5wcm9zdmFsc3RyaW5nID0gc3luUHJvc1ZhbFN0cmluZztcbiAgdGhpcy5jYWxsYmFja3MucmVwZXRpdGlvbiA9IHN5blJlcGV0aXRpb247XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGUgPSBzeW5SdWxlO1xuICB0aGlzLmNhbGxiYWNrcy5ydWxlZXJyb3IgPSBzeW5SdWxlRXJyb3I7XG4gIHRoaXMuY2FsbGJhY2tzLnJ1bGVuYW1lZXJyb3IgPSBzeW5SdWxlTmFtZUVycm9yO1xuICB0aGlzLmNhbGxiYWNrcy5zdHJpbmd0YWIgPSBzeW5TdHJpbmdUYWI7XG4gIHRoaXMuY2FsbGJhY2tzLnRsc2Nsb3NlID0gc3luVGxzQ2xvc2U7XG4gIHRoaXMuY2FsbGJhY2tzLnRsc29wZW4gPSBzeW5UbHNPcGVuO1xuICB0aGlzLmNhbGxiYWNrcy50bHNzdHJpbmcgPSBzeW5UbHNTdHJpbmc7XG4gIHRoaXMuY2FsbGJhY2tzLnVkdG9wID0gc3luVWR0T3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrYW9wID0gc3luQmthT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrbm9wID0gc3luQmtuT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmJrcm9wID0gc3luQmtyT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmFiZ29wID0gc3luQWJnT3A7XG4gIHRoaXMuY2FsbGJhY2tzLmFlbm9wID0gc3luQWVuT3A7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-api/syntax-callbacks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js":
/*!***********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-conv-api/converter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\n'use strict;';\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\nconst trans = __webpack_require__(/*! ./transformers */ \"(ssr)/./node_modules/apg-js/src/apg-conv-api/transformers.js\");\n\n/* types */\nconst UTF8 = 'UTF8';\nconst UTF16 = 'UTF16';\nconst UTF16BE = 'UTF16BE';\nconst UTF16LE = 'UTF16LE';\nconst UTF32 = 'UTF32';\nconst UTF32BE = 'UTF32BE';\nconst UTF32LE = 'UTF32LE';\nconst UINT7 = 'UINT7';\nconst ASCII = 'ASCII';\nconst BINARY = 'BINARY';\nconst UINT8 = 'UINT8';\nconst UINT16 = 'UINT16';\nconst UINT16LE = 'UINT16LE';\nconst UINT16BE = 'UINT16BE';\nconst UINT32 = 'UINT32';\nconst UINT32LE = 'UINT32LE';\nconst UINT32BE = 'UINT32BE';\nconst ESCAPED = 'ESCAPED';\nconst STRING = 'STRING';\n\n/* private functions */\n// Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n  src.type = UTF8;\n  const buf = src.data;\n  src.bom = 0;\n  if (buf.length >= 3) {\n    if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n      src.bom = 3;\n    }\n  }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF16:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.type = UTF16LE;\n          src.bom = 2;\n        }\n      }\n      break;\n    case UTF16BE:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n        }\n      }\n      break;\n    case UTF16LE:\n      src.type = UTF16LE;\n      if (buf.length >= 0) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.bom = 2;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF32:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.type = UTF32LE;\n          src.bom = 4;\n        }\n      }\n      break;\n    case UTF32BE:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n        }\n      }\n      break;\n    case UTF32LE:\n      src.type = UTF32LE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.bom = 4;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n  function getType(typeArg) {\n    const ret = {\n      type: '',\n      base64: false,\n    };\n    const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n    const result = rx.exec(typeArg);\n    if (result) {\n      if (result[2]) {\n        ret.type = result[2].toUpperCase();\n      }\n      if (result[1]) {\n        ret.base64 = true;\n      }\n    }\n    return ret;\n  }\n  const ret = getType(type.toUpperCase());\n  if (ret.base64) {\n    /* handle base 64 */\n    if (ret.type === STRING) {\n      throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n    }\n    if (Buffer.isBuffer(data)) {\n      ret.data = trans.base64.decode(data);\n    } else if (typeof data === 'string') {\n      const buf = Buffer.from(data, 'ascii');\n      ret.data = trans.base64.decode(buf);\n    } else {\n      throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n    }\n  } else {\n    ret.data = data;\n  }\n  switch (ret.type) {\n    case UTF8:\n      bom8(ret);\n      break;\n    case UTF16:\n    case UTF16BE:\n    case UTF16LE:\n      bom16(ret);\n      break;\n    case UTF32:\n    case UTF32BE:\n    case UTF32LE:\n      bom32(ret);\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case STRING:\n    case ESCAPED:\n      break;\n    default:\n      throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  if (ret.type === STRING) {\n    if (typeof ret.data !== 'string') {\n      throw new TypeError(`type: \"${type}\" but data is not a string`);\n    }\n  } else if (!Buffer.isBuffer(ret.data)) {\n    throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n  }\n  return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n  function getType(typeArg) {\n    let fix;\n    let rem;\n    const ret = {\n      crlf: false,\n      lf: false,\n      base64: false,\n      type: '',\n    };\n    /* prefix, if any */\n    const TRUE = true;\n    while (TRUE) {\n      rem = typeArg;\n      fix = typeArg.slice(0, 5);\n      if (fix === 'CRLF:') {\n        ret.crlf = true;\n        rem = typeArg.slice(5);\n        break;\n      }\n      fix = typeArg.slice(0, 3);\n      if (fix === 'LF:') {\n        ret.lf = true;\n        rem = typeArg.slice(3);\n        break;\n      }\n      break;\n    }\n    /* suffix, if any */\n    fix = rem.split(':');\n    if (fix.length === 1) {\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    } else if (fix.length === 2 && fix[1] === 'BASE64') {\n      ret.base64 = true;\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    }\n    return ret;\n  }\n  if (!Array.isArray(chars)) {\n    throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`dst type: not string: \"${typeof type}`);\n  }\n  const ret = getType(type.toUpperCase());\n  switch (ret.type) {\n    case UTF8:\n    case UTF16BE:\n    case UTF16LE:\n    case UTF32BE:\n    case UTF32LE:\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case ESCAPED:\n      break;\n    case STRING:\n      if (ret.base64) {\n        throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n      }\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UTF16:\n      ret.type = UTF16BE;\n      break;\n    case UTF32:\n      ret.type = UTF32BE;\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    default:\n      throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n  }\n  return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n  switch (type) {\n    case UTF8:\n      return trans.utf8.encode(chars);\n    case UTF16BE:\n      return trans.utf16be.encode(chars);\n    case UTF16LE:\n      return trans.utf16le.encode(chars);\n    case UTF32BE:\n      return trans.utf32be.encode(chars);\n    case UTF32LE:\n      return trans.utf32le.encode(chars);\n    case UINT7:\n      return trans.uint7.encode(chars);\n    case UINT8:\n      return trans.uint8.encode(chars);\n    case UINT16BE:\n      return trans.uint16be.encode(chars);\n    case UINT16LE:\n      return trans.uint16le.encode(chars);\n    case UINT32BE:\n      return trans.uint32be.encode(chars);\n    case UINT32LE:\n      return trans.uint32le.encode(chars);\n    case STRING:\n      return trans.string.encode(chars);\n    case ESCAPED:\n      return trans.escaped.encode(chars);\n    default:\n      throw new TypeError(`encode type \"${type}\" not recognized`);\n  }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n  switch (src.type) {\n    case UTF8:\n      return trans.utf8.decode(src.data, src.bom);\n    case UTF16LE:\n      return trans.utf16le.decode(src.data, src.bom);\n    case UTF16BE:\n      return trans.utf16be.decode(src.data, src.bom);\n    case UTF32BE:\n      return trans.utf32be.decode(src.data, src.bom);\n    case UTF32LE:\n      return trans.utf32le.decode(src.data, src.bom);\n    case UINT7:\n      return trans.uint7.decode(src.data);\n    case UINT8:\n      return trans.uint8.decode(src.data);\n    case UINT16BE:\n      return trans.uint16be.decode(src.data);\n    case UINT16LE:\n      return trans.uint16le.decode(src.data);\n    case UINT32BE:\n      return trans.uint32be.decode(src.data);\n    case UINT32LE:\n      return trans.uint32le.decode(src.data);\n    case STRING:\n      return trans.string.decode(src.data);\n    case ESCAPED:\n      return trans.escaped.decode(src.data);\n    default:\n      throw new TypeError(`decode type \"${src.type}\" not recognized`);\n  }\n};\n\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n  const src = validateSrc(type, data);\n  return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n  let c;\n  let buf;\n  const dst = validateDst(type, chars);\n  if (dst.crlf) {\n    /* prefix with CRLF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.crlf(chars);\n    buf = encode(dst.type, c);\n  } else if (dst.lf) {\n    /* prefix with LF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.lf(chars);\n    buf = encode(dst.type, c);\n  } else {\n    buf = encode(dst.type, chars);\n  }\n  if (dst.base64) {\n    /* post base 64 encoding */\n    buf = trans.base64.encode(buf);\n  }\n  return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nconst convert = function convert(srcType, srcData, dstType) {\n  return exports.encode(dstType, exports.decode(srcType, srcData));\n};\nexports.convert = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkMsY0FBYyxtQkFBTyxDQUFDLG9GQUFnQjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNENBQTRDLFFBQVEsOEJBQThCLFFBQVE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsMkJBQTJCLFFBQVE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSw4QkFBOEIsUUFBUTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLHlDQUF5QyxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9DQUFvQyxNQUFNLHdDQUF3QyxZQUFZO0FBQzlGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBLElBQUk7QUFDSixrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRDtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLE9BQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvY29udmVydGVyLmpzPzYyMzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgZXhwb3NlcyB0aGUgcHVibGljIGVuY29kaW5nLCBkZWNvZGluZyBhbmQgY29udmVyc2lvbiBmdW5jdGlvbnMuXG4vLyBJdHMgcHJpdmF0ZSBmdW5jdGlvbnMgcHJvdmlkZSB0aGUgZGlzYXNzZW1ibGluZyBhbmQgaW50ZXJwZXRhdGlvbiBvZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBlbmNvZGluZyB0eXBlcy5cbi8vIEluIHRoZSBjYXNlIG9mIFVuaWNvZGUgZW5jb2RpbmdzLCBwcml2YXRlIGZ1bmN0aW9ucyBkZXRlcm1pbmUgdGhlIHByZXNlbmNlIG9mIEJ5dGUgT3JkZXIgTWFya3MgKEJPTXMpLCBpZiBhbnkuXG4vL1xuLy8gVGhyb3dzIFwiVHlwZUVycm9yXCIgZXhjZXB0aW9ucyBvbiBpbnB1dCBlcnJvcnMuXG4vL1xuXG4ndXNlIHN0cmljdDsnO1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5cbmNvbnN0IHRyYW5zID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1lcnMnKTtcblxuLyogdHlwZXMgKi9cbmNvbnN0IFVURjggPSAnVVRGOCc7XG5jb25zdCBVVEYxNiA9ICdVVEYxNic7XG5jb25zdCBVVEYxNkJFID0gJ1VURjE2QkUnO1xuY29uc3QgVVRGMTZMRSA9ICdVVEYxNkxFJztcbmNvbnN0IFVURjMyID0gJ1VURjMyJztcbmNvbnN0IFVURjMyQkUgPSAnVVRGMzJCRSc7XG5jb25zdCBVVEYzMkxFID0gJ1VURjMyTEUnO1xuY29uc3QgVUlOVDcgPSAnVUlOVDcnO1xuY29uc3QgQVNDSUkgPSAnQVNDSUknO1xuY29uc3QgQklOQVJZID0gJ0JJTkFSWSc7XG5jb25zdCBVSU5UOCA9ICdVSU5UOCc7XG5jb25zdCBVSU5UMTYgPSAnVUlOVDE2JztcbmNvbnN0IFVJTlQxNkxFID0gJ1VJTlQxNkxFJztcbmNvbnN0IFVJTlQxNkJFID0gJ1VJTlQxNkJFJztcbmNvbnN0IFVJTlQzMiA9ICdVSU5UMzInO1xuY29uc3QgVUlOVDMyTEUgPSAnVUlOVDMyTEUnO1xuY29uc3QgVUlOVDMyQkUgPSAnVUlOVDMyQkUnO1xuY29uc3QgRVNDQVBFRCA9ICdFU0NBUEVEJztcbmNvbnN0IFNUUklORyA9ICdTVFJJTkcnO1xuXG4vKiBwcml2YXRlIGZ1bmN0aW9ucyAqL1xuLy8gRmluZCB0aGUgVVRGOCBCT00sIGlmIGFueS5cbmNvbnN0IGJvbTggPSBmdW5jdGlvbiBib204KHNyYykge1xuICBzcmMudHlwZSA9IFVURjg7XG4gIGNvbnN0IGJ1ZiA9IHNyYy5kYXRhO1xuICBzcmMuYm9tID0gMDtcbiAgaWYgKGJ1Zi5sZW5ndGggPj0gMykge1xuICAgIGlmIChidWZbMF0gPT09IDB4ZWYgJiYgYnVmWzFdID09PSAweGJiICYmIGJ1ZlsyXSA9PT0gMHhiZikge1xuICAgICAgc3JjLmJvbSA9IDM7XG4gICAgfVxuICB9XG59O1xuLy8gRmluZCB0aGUgVVRGMTYgQk9NLCBpZiBhbnksIGFuZCBkZXRlcm1pbmUgdGhlIFVURjE2IHR5cGUuXG4vLyBEZWZhdWx0cyB0byBVVEYxNkJFLlxuLy8gVGhyb3dzIFR5cGVFcnJvciBleGNlcHRpb24gaWYgQk9NIGRvZXMgbm90IG1hdGNoIHRoZSBzcGVjaWZpZWQgdHlwZS5cbmNvbnN0IGJvbTE2ID0gZnVuY3Rpb24gYm9tMTYoc3JjKSB7XG4gIGNvbnN0IGJ1ZiA9IHNyYy5kYXRhO1xuICBzcmMuYm9tID0gMDtcbiAgc3dpdGNoIChzcmMudHlwZSkge1xuICAgIGNhc2UgVVRGMTY6XG4gICAgICBzcmMudHlwZSA9IFVURjE2QkU7XG4gICAgICBpZiAoYnVmLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmUgJiYgYnVmWzFdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSkge1xuICAgICAgICAgIHNyYy50eXBlID0gVVRGMTZMRTtcbiAgICAgICAgICBzcmMuYm9tID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYxNkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gMikge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAweGZlICYmIGJ1ZlsxXSA9PT0gMHhmZikge1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogXCIke1VURjE2QkV9XCIgc3BlY2lmaWVkIGJ1dCBCT00gaXMgZm9yIFwiJHtVVEYxNkxFfVwiYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIHNyYy50eXBlID0gVVRGMTZMRTtcbiAgICAgIGlmIChidWYubGVuZ3RoID49IDApIHtcbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZSAmJiBidWZbMV0gPT09IDB4ZmYpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzcmMgdHlwZTogXCIke1VURjE2TEV9XCIgc3BlY2lmaWVkIGJ1dCBCT00gaXMgZm9yIFwiJHtVVEYxNkJFfVwiYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYnVmWzBdID09PSAweGZmICYmIGJ1ZlsxXSA9PT0gMHhmZSkge1xuICAgICAgICAgIHNyYy5ib20gPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVVRGMTYgQk9NOiBzcmMgdHlwZSBcIiR7c3JjLnR5cGV9XCIgdW5yZWNvZ25pemVkYCk7XG4gIH1cbn07XG4vLyBGaW5kIHRoZSBVVEYzMiBCT00sIGlmIGFueSwgYW5kIGRldGVybWluZSB0aGUgVVRGMzIgdHlwZS5cbi8vIERlZmF1bHRzIHRvIFVURjMyQkUuXG4vLyBUaHJvd3MgZXhjZXB0aW9uIGlmIEJPTSBkb2VzIG5vdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHR5cGUuXG5jb25zdCBib20zMiA9IGZ1bmN0aW9uIGJvbTMyKHNyYykge1xuICBjb25zdCBidWYgPSBzcmMuZGF0YTtcbiAgc3JjLmJvbSA9IDA7XG4gIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICBjYXNlIFVURjMyOlxuICAgICAgc3JjLnR5cGUgPSBVVEYzMkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAwICYmIGJ1ZlsxXSA9PT0gMCAmJiBidWZbMl0gPT09IDB4ZmUgJiYgYnVmWzNdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUgJiYgYnVmWzJdID09PSAwICYmIGJ1ZlszXSA9PT0gMCkge1xuICAgICAgICAgIHNyYy50eXBlID0gVVRGMzJMRTtcbiAgICAgICAgICBzcmMuYm9tID0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYzMkJFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAwICYmIGJ1ZlsxXSA9PT0gMCAmJiBidWZbMl0gPT09IDB4ZmUgJiYgYnVmWzNdID09PSAweGZmKSB7XG4gICAgICAgICAgc3JjLmJvbSA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZlswXSA9PT0gMHhmZiAmJiBidWZbMV0gPT09IDB4ZmUgJiYgYnVmWzJdID09PSAwICYmIGJ1ZlszXSA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHNyYyB0eXBlOiAke1VURjMyQkV9IHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciAke1VURjMyTEV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgc3JjLnR5cGUgPSBVVEYzMkxFO1xuICAgICAgaWYgKGJ1Zi5sZW5ndGggPj0gNCkge1xuICAgICAgICBpZiAoYnVmWzBdID09PSAwICYmIGJ1ZlsxXSA9PT0gMCAmJiBidWZbMl0gPT09IDB4ZmUgJiYgYnVmWzNdID09PSAweGZmKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3JjIHR5cGU6IFwiJHtVVEYzMkxFfVwiIHNwZWNpZmllZCBidXQgQk9NIGlzIGZvciBcIiR7VVRGMzJCRX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbMF0gPT09IDB4ZmYgJiYgYnVmWzFdID09PSAweGZlICYmIGJ1ZlsyXSA9PT0gMCAmJiBidWZbM10gPT09IDApIHtcbiAgICAgICAgICBzcmMuYm9tID0gNDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVURjMyIEJPTTogc3JjIHR5cGUgXCIke3NyYy50eXBlfVwiIHVucmVjb2duaXplZGApO1xuICB9XG59O1xuLy8gVmFsaWRhdGVzIHRoZSBzb3VyY2UgZW5jb2RpbmcgdHlwZSBhbmQgbWF0Y2hpbmcgZGF0YS5cbi8vIElmIHRoZSBCQVNFNjQ6IHByZWZpeCBpcyBwcmVzZW50LCB0aGUgYmFzZSA2NCBkZWNvZGluZyBpcyBkb25lIGhlcmUgYXMgdGhlIGluaXRpYWwgc3RlcC5cbi8vIC0gRm9yIHR5cGUgU1RSSU5HLCBkYXRhIG11c3QgYmUgYSBKYXZhU2NyaXB0IHN0cmluZy5cbi8vIC0gRm9yIHR5cGUgQkFTRTY0OiosIGRhdGEgbWF5IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlci5cbi8vIC0gRm9yIGFsbCBvdGhlciB0eXBlcywgZGF0YSBtdXN0IGJlIGEgQnVmZmVyLlxuLy8gLSBUaGUgQkFTRTY0OiBwcmVmaXggaXMgbm90IGFsbG93ZWQgZm9yIHR5cGUgU1RSSU5HLlxuY29uc3QgdmFsaWRhdGVTcmMgPSBmdW5jdGlvbiB2YWxpZGF0ZVNyYyh0eXBlLCBkYXRhKSB7XG4gIGZ1bmN0aW9uIGdldFR5cGUodHlwZUFyZykge1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIHR5cGU6ICcnLFxuICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IHJ4ID0gL14oYmFzZTY0Oik/KFthLXpBLVowLTldKykkL2k7XG4gICAgY29uc3QgcmVzdWx0ID0gcnguZXhlYyh0eXBlQXJnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0WzJdKSB7XG4gICAgICAgIHJldC50eXBlID0gcmVzdWx0WzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIHJldC5iYXNlNjQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGNvbnN0IHJldCA9IGdldFR5cGUodHlwZS50b1VwcGVyQ2FzZSgpKTtcbiAgaWYgKHJldC5iYXNlNjQpIHtcbiAgICAvKiBoYW5kbGUgYmFzZSA2NCAqL1xuICAgIGlmIChyZXQudHlwZSA9PT0gU1RSSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX0gXCJCQVNFNjQ6XCIgcHJlZml4IG5vdCBhbGxvd2VkIHdpdGggdHlwZSAke1NUUklOR31gKTtcbiAgICB9XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgcmV0LmRhdGEgPSB0cmFucy5iYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShkYXRhLCAnYXNjaWknKTtcbiAgICAgIHJldC5kYXRhID0gdHJhbnMuYmFzZTY0LmRlY29kZShidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX0gdW5yZWNvZ25pemVkIGRhdGEgdHlwZTogdHlwZW9mKGRhdGEpOiAke3R5cGVvZiBkYXRhfWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXQuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3dpdGNoIChyZXQudHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICAgIGJvbTgocmV0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMTY6XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIGJvbTE2KHJldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVURjMyOlxuICAgIGNhc2UgVVRGMzJCRTpcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgICBib20zMihyZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMTY6XG4gICAgICByZXQudHlwZSA9IFVJTlQxNkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVSU5UMzI6XG4gICAgICByZXQudHlwZSA9IFVJTlQzMkJFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU0NJSTpcbiAgICAgIHJldC50eXBlID0gVUlOVDc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJJTkFSWTpcbiAgICAgIHJldC50eXBlID0gVUlOVDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQ3OlxuICAgIGNhc2UgVUlOVDg6XG4gICAgY2FzZSBVSU5UMTZMRTpcbiAgICBjYXNlIFVJTlQxNkJFOlxuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICBjYXNlIFNUUklORzpcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZTogXCIke3R5cGV9XCIgbm90IHJlY29nbml6ZWRgKTtcbiAgfVxuICBpZiAocmV0LnR5cGUgPT09IFNUUklORykge1xuICAgIGlmICh0eXBlb2YgcmV0LmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX1cIiBidXQgZGF0YSBpcyBub3QgYSBzdHJpbmdgKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihyZXQuZGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlOiBcIiR7dHlwZX1cIiBidXQgZGF0YSBpcyBub3QgYSBCdWZmZXJgKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIERpc2Fzc2VtYmxlcyBhbmQgdmFsaWRhdGVzIHRoZSBkZXN0aW5hdGlvbiB0eXBlLlxuLy8gYGNoYXJzYCBtdXN0IGJlIGFuIEFycmF5IG9mIGludGVnZXJzLlxuLy8gVGhlIDpCQVNFNjQgc3VmZml4IGlzIG5vdCBhbGxvd2VkIGZvciB0eXBlIFNUUklORy5cbmNvbnN0IHZhbGlkYXRlRHN0ID0gZnVuY3Rpb24gdmFsaWRhdGVEc3QodHlwZSwgY2hhcnMpIHtcbiAgZnVuY3Rpb24gZ2V0VHlwZSh0eXBlQXJnKSB7XG4gICAgbGV0IGZpeDtcbiAgICBsZXQgcmVtO1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIGNybGY6IGZhbHNlLFxuICAgICAgbGY6IGZhbHNlLFxuICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgIHR5cGU6ICcnLFxuICAgIH07XG4gICAgLyogcHJlZml4LCBpZiBhbnkgKi9cbiAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICB3aGlsZSAoVFJVRSkge1xuICAgICAgcmVtID0gdHlwZUFyZztcbiAgICAgIGZpeCA9IHR5cGVBcmcuc2xpY2UoMCwgNSk7XG4gICAgICBpZiAoZml4ID09PSAnQ1JMRjonKSB7XG4gICAgICAgIHJldC5jcmxmID0gdHJ1ZTtcbiAgICAgICAgcmVtID0gdHlwZUFyZy5zbGljZSg1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXggPSB0eXBlQXJnLnNsaWNlKDAsIDMpO1xuICAgICAgaWYgKGZpeCA9PT0gJ0xGOicpIHtcbiAgICAgICAgcmV0LmxmID0gdHJ1ZTtcbiAgICAgICAgcmVtID0gdHlwZUFyZy5zbGljZSgzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLyogc3VmZml4LCBpZiBhbnkgKi9cbiAgICBmaXggPSByZW0uc3BsaXQoJzonKTtcbiAgICBpZiAoZml4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICByZXQudHlwZSA9IGZpeFswXTtcbiAgICB9IGVsc2UgaWYgKGZpeC5sZW5ndGggPT09IDIgJiYgZml4WzFdID09PSAnQkFTRTY0Jykge1xuICAgICAgcmV0LmJhc2U2NCA9IHRydWU7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHJldC50eXBlID0gZml4WzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkc3QgY2hhcnM6IG5vdCBhcnJheTogXCIke3R5cGVvZiBjaGFyc31gKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHN0IHR5cGU6IG5vdCBzdHJpbmc6IFwiJHt0eXBlb2YgdHlwZX1gKTtcbiAgfVxuICBjb25zdCByZXQgPSBnZXRUeXBlKHR5cGUudG9VcHBlckNhc2UoKSk7XG4gIHN3aXRjaCAocmV0LnR5cGUpIHtcbiAgICBjYXNlIFVURjg6XG4gICAgY2FzZSBVVEYxNkJFOlxuICAgIGNhc2UgVVRGMTZMRTpcbiAgICBjYXNlIFVURjMyQkU6XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgIGNhc2UgVUlOVDc6XG4gICAgY2FzZSBVSU5UODpcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgY2FzZSBVSU5UMzJMRTpcbiAgICBjYXNlIFVJTlQzMkJFOlxuICAgIGNhc2UgRVNDQVBFRDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgaWYgKHJldC5iYXNlNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCI6QkFTRTY0XCIgc3VmZml4IG5vdCBhbGxvd2VkIHdpdGggdHlwZSAke1NUUklOR31gKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQVNDSUk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ3O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCSU5BUlk6XG4gICAgICByZXQudHlwZSA9IFVJTlQ4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBVVEYxNjpcbiAgICAgIHJldC50eXBlID0gVVRGMTZCRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVVRGMzI6XG4gICAgICByZXQudHlwZSA9IFVURjMyQkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQxNjpcbiAgICAgIHJldC50eXBlID0gVUlOVDE2QkU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFVJTlQzMjpcbiAgICAgIHJldC50eXBlID0gVUlOVDMyQkU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZHN0IHR5cGUgdW5yZWNvZ25pemVkOiBcIiR7dHlwZX1cIiA6IG11c3QgaGF2ZSBmb3JtIFtjcmxmOnxsZjpddHlwZVs6YmFzZTY0XWApO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gU2VsZWN0IGFuZCBjYWxsIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcgZnVuY3Rpb24uXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUodHlwZSwgY2hhcnMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBVVEY4OlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjguZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVVRGMTZMRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYxNmxlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVVEYzMkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMyYmUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVURjMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMzJsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDc6XG4gICAgICByZXR1cm4gdHJhbnMudWludDcuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQ4OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ4LmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMTZCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MTZiZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgVUlOVDE2TEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2bGUuZW5jb2RlKGNoYXJzKTtcbiAgICBjYXNlIFVJTlQzMkJFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQzMmJlLmVuY29kZShjaGFycyk7XG4gICAgY2FzZSBVSU5UMzJMRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJsZS5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgU1RSSU5HOlxuICAgICAgcmV0dXJuIHRyYW5zLnN0cmluZy5lbmNvZGUoY2hhcnMpO1xuICAgIGNhc2UgRVNDQVBFRDpcbiAgICAgIHJldHVybiB0cmFucy5lc2NhcGVkLmVuY29kZShjaGFycyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGVuY29kZSB0eXBlIFwiJHt0eXBlfVwiIG5vdCByZWNvZ25pemVkYCk7XG4gIH1cbn07XG4vLyBTZWxlY3QgYW5kIGNhbGwgdGhlIHJlcXVlc3RlZCBkZWNvZGluZyBmdW5jdGlvbi5cbi8vIGBzcmNgIGNvbnRhaW5zIEJPTSBpbmZvcm1hdGlvbiBhcyB3ZWxsIGFzIHRoZSBzb3VyY2UgdHlwZSBhbmQgZGF0YS5cbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzcmMpIHtcbiAgc3dpdGNoIChzcmMudHlwZSkge1xuICAgIGNhc2UgVVRGODpcbiAgICAgIHJldHVybiB0cmFucy51dGY4LmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjE2bGUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVURjE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudXRmMTZiZS5kZWNvZGUoc3JjLmRhdGEsIHNyYy5ib20pO1xuICAgIGNhc2UgVVRGMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51dGYzMmJlLmRlY29kZShzcmMuZGF0YSwgc3JjLmJvbSk7XG4gICAgY2FzZSBVVEYzMkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnV0ZjMybGUuZGVjb2RlKHNyYy5kYXRhLCBzcmMuYm9tKTtcbiAgICBjYXNlIFVJTlQ3OlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQ3LmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UODpcbiAgICAgIHJldHVybiB0cmFucy51aW50OC5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDE2QkU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDE2YmUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFVJTlQxNkxFOlxuICAgICAgcmV0dXJuIHRyYW5zLnVpbnQxNmxlLmRlY29kZShzcmMuZGF0YSk7XG4gICAgY2FzZSBVSU5UMzJCRTpcbiAgICAgIHJldHVybiB0cmFucy51aW50MzJiZS5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGNhc2UgVUlOVDMyTEU6XG4gICAgICByZXR1cm4gdHJhbnMudWludDMybGUuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIFNUUklORzpcbiAgICAgIHJldHVybiB0cmFucy5zdHJpbmcuZGVjb2RlKHNyYy5kYXRhKTtcbiAgICBjYXNlIEVTQ0FQRUQ6XG4gICAgICByZXR1cm4gdHJhbnMuZXNjYXBlZC5kZWNvZGUoc3JjLmRhdGEpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkZWNvZGUgdHlwZSBcIiR7c3JjLnR5cGV9XCIgbm90IHJlY29nbml6ZWRgKTtcbiAgfVxufTtcblxuLy8gVGhlIHB1YmxpYyBkZWNvZGluZyBmdW5jdGlvbi4gUmV0dXJucyBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gZXhwb3J0c0RlY29kZSh0eXBlLCBkYXRhKSB7XG4gIGNvbnN0IHNyYyA9IHZhbGlkYXRlU3JjKHR5cGUsIGRhdGEpO1xuICByZXR1cm4gZGVjb2RlKHNyYyk7XG59O1xuLy8gVGhlIHB1YmxpYyBlbmNvZGluZyBmdW5jdGlvbi4gUmV0dXJucyBhIEJ1ZmZlci10eXBlZCBieXRlIGFycmF5LlxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBleHBvcnRzRW5jb2RlKHR5cGUsIGNoYXJzKSB7XG4gIGxldCBjO1xuICBsZXQgYnVmO1xuICBjb25zdCBkc3QgPSB2YWxpZGF0ZURzdCh0eXBlLCBjaGFycyk7XG4gIGlmIChkc3QuY3JsZikge1xuICAgIC8qIHByZWZpeCB3aXRoIENSTEYgbGluZSBlbmQgY29udmVyc2lvbiwgZG9uJ3QgY29udGFtaW5hdGUgY2FsbGVyJ3MgY2hhcnMgYXJyYXkgKi9cbiAgICBjID0gdHJhbnMubGluZUVuZHMuY3JsZihjaGFycyk7XG4gICAgYnVmID0gZW5jb2RlKGRzdC50eXBlLCBjKTtcbiAgfSBlbHNlIGlmIChkc3QubGYpIHtcbiAgICAvKiBwcmVmaXggd2l0aCBMRiBsaW5lIGVuZCBjb252ZXJzaW9uLCBkb24ndCBjb250YW1pbmF0ZSBjYWxsZXIncyBjaGFycyBhcnJheSAqL1xuICAgIGMgPSB0cmFucy5saW5lRW5kcy5sZihjaGFycyk7XG4gICAgYnVmID0gZW5jb2RlKGRzdC50eXBlLCBjKTtcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBlbmNvZGUoZHN0LnR5cGUsIGNoYXJzKTtcbiAgfVxuICBpZiAoZHN0LmJhc2U2NCkge1xuICAgIC8qIHBvc3QgYmFzZSA2NCBlbmNvZGluZyAqL1xuICAgIGJ1ZiA9IHRyYW5zLmJhc2U2NC5lbmNvZGUoYnVmKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcbi8vIENvbnZlcnRzIGRhdGEgb2YgdHlwZSBgc3JjVHlwZWAgdG8gZGF0YSBvZiB0eXBlIGBkc3RUeXBlYC5cbi8vIGBzcmNEYXRhYCBtYXkgYmUgYSBKYXZhU2NyaXB0IFN0cmluZywgb3Igbm9kZS5qcyBCdWZmZXIsIGRlcGVuZGluZyBvbiB0aGUgY29ycmVzcG9uZGluZyB0eXBlLlxuY29uc3QgY29udmVydCA9IGZ1bmN0aW9uIGNvbnZlcnQoc3JjVHlwZSwgc3JjRGF0YSwgZHN0VHlwZSkge1xuICByZXR1cm4gZXhwb3J0cy5lbmNvZGUoZHN0VHlwZSwgZXhwb3J0cy5kZWNvZGUoc3JjVHlwZSwgc3JjRGF0YSkpO1xufTtcbmV4cG9ydHMuY29udmVydCA9IGNvbnZlcnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-conv-api/transformers.js":
/*!**************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-conv-api/transformers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable prefer-destructuring */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-bitwise */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\n'use strict;';\n\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\n\n/* decoding error codes */\nconst NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */\nconst mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];\n\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */\nconst ascii = [\n  '00',\n  '01',\n  '02',\n  '03',\n  '04',\n  '05',\n  '06',\n  '07',\n  '08',\n  '09',\n  '0A',\n  '0B',\n  '0C',\n  '0D',\n  '0E',\n  '0F',\n  '10',\n  '11',\n  '12',\n  '13',\n  '14',\n  '15',\n  '16',\n  '17',\n  '18',\n  '19',\n  '1A',\n  '1B',\n  '1C',\n  '1D',\n  '1E',\n  '1F',\n  '20',\n  '21',\n  '22',\n  '23',\n  '24',\n  '25',\n  '26',\n  '27',\n  '28',\n  '29',\n  '2A',\n  '2B',\n  '2C',\n  '2D',\n  '2E',\n  '2F',\n  '30',\n  '31',\n  '32',\n  '33',\n  '34',\n  '35',\n  '36',\n  '37',\n  '38',\n  '39',\n  '3A',\n  '3B',\n  '3C',\n  '3D',\n  '3E',\n  '3F',\n  '40',\n  '41',\n  '42',\n  '43',\n  '44',\n  '45',\n  '46',\n  '47',\n  '48',\n  '49',\n  '4A',\n  '4B',\n  '4C',\n  '4D',\n  '4E',\n  '4F',\n  '50',\n  '51',\n  '52',\n  '53',\n  '54',\n  '55',\n  '56',\n  '57',\n  '58',\n  '59',\n  '5A',\n  '5B',\n  '5C',\n  '5D',\n  '5E',\n  '5F',\n  '60',\n  '61',\n  '62',\n  '63',\n  '64',\n  '65',\n  '66',\n  '67',\n  '68',\n  '69',\n  '6A',\n  '6B',\n  '6C',\n  '6D',\n  '6E',\n  '6F',\n  '70',\n  '71',\n  '72',\n  '73',\n  '74',\n  '75',\n  '76',\n  '77',\n  '78',\n  '79',\n  '7A',\n  '7B',\n  '7C',\n  '7D',\n  '7E',\n  '7F',\n  '80',\n  '81',\n  '82',\n  '83',\n  '84',\n  '85',\n  '86',\n  '87',\n  '88',\n  '89',\n  '8A',\n  '8B',\n  '8C',\n  '8D',\n  '8E',\n  '8F',\n  '90',\n  '91',\n  '92',\n  '93',\n  '94',\n  '95',\n  '96',\n  '97',\n  '98',\n  '99',\n  '9A',\n  '9B',\n  '9C',\n  '9D',\n  '9E',\n  '9F',\n  'A0',\n  'A1',\n  'A2',\n  'A3',\n  'A4',\n  'A5',\n  'A6',\n  'A7',\n  'A8',\n  'A9',\n  'AA',\n  'AB',\n  'AC',\n  'AD',\n  'AE',\n  'AF',\n  'B0',\n  'B1',\n  'B2',\n  'B3',\n  'B4',\n  'B5',\n  'B6',\n  'B7',\n  'B8',\n  'B9',\n  'BA',\n  'BB',\n  'BC',\n  'BD',\n  'BE',\n  'BF',\n  'C0',\n  'C1',\n  'C2',\n  'C3',\n  'C4',\n  'C5',\n  'C6',\n  'C7',\n  'C8',\n  'C9',\n  'CA',\n  'CB',\n  'CC',\n  'CD',\n  'CE',\n  'CF',\n  'D0',\n  'D1',\n  'D2',\n  'D3',\n  'D4',\n  'D5',\n  'D6',\n  'D7',\n  'D8',\n  'D9',\n  'DA',\n  'DB',\n  'DC',\n  'DD',\n  'DE',\n  'DF',\n  'E0',\n  'E1',\n  'E2',\n  'E3',\n  'E4',\n  'E5',\n  'E6',\n  'E7',\n  'E8',\n  'E9',\n  'EA',\n  'EB',\n  'EC',\n  'ED',\n  'EE',\n  'EF',\n  'F0',\n  'F1',\n  'F2',\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'FA',\n  'FB',\n  'FC',\n  'FD',\n  'FE',\n  'FF',\n];\n\n/* vector of base 64 characters */\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');\n\n/* vector of base 64 character codes */\nconst base64codes = [];\nbase64chars.forEach((char) => {\n  base64codes.push(char.charCodeAt(0));\n});\n\n// The UTF8 algorithms.\nexports.utf8 = {\n  encode(chars) {\n    const bytes = [];\n    chars.forEach((char) => {\n      if (char >= 0 && char <= 0x7f) {\n        bytes.push(char);\n      } else if (char <= 0x7ff) {\n        bytes.push(0xc0 + ((char >> 6) & mask[5]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char < 0xd800 || (char > 0xdfff && char <= 0xffff)) {\n        bytes.push(0xe0 + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        const u = (char >> 16) & mask[5];\n        bytes.push(0xf0 + (u >> 2));\n        bytes.push(0x80 + ((u & mask[2]) << 4) + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else {\n        throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n      }\n    });\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* bytes functions return error for non-shortest forms & values out of range */\n    function bytes2(b1, b2) {\n      /* U+0080..U+07FF */\n      /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */\n      if ((b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n      if (x < 0x80) {\n        return NON_SHORTEST;\n      }\n      return x;\n    }\n    function bytes3(b1, b2, b3) {\n      /* U+0800..U+FFFF */\n      /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */\n      if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n      if (x < 0x800) {\n        return NON_SHORTEST;\n      }\n      if (x >= 0xd800 && x <= 0xdfff) {\n        return RANGE;\n      }\n      return x;\n    }\n    function bytes4(b1, b2, b3, b4) {\n      /* U+10000..U+10FFFF */\n      /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */\n      if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x =\n        ((((b1 & mask[3]) << 2) + ((b2 >> 4) & mask[2])) << 16) +\n        ((b2 & mask[4]) << 12) +\n        ((b3 & mask[6]) << 6) +\n        (b4 & mask[6]);\n      if (x < 0x10000) {\n        return NON_SHORTEST;\n      }\n      if (x > 0x10ffff) {\n        return RANGE;\n      }\n      return x;\n    }\n    let c;\n    let b1;\n    let i1;\n    let i2;\n    let i3;\n    let inc;\n    const len = buf.length;\n    let i = bom ? 3 : 0;\n    const chars = [];\n    while (i < len) {\n      b1 = buf[i];\n      c = ILL_FORMED;\n      const TRUE = true;\n      while (TRUE) {\n        if (b1 >= 0 && b1 <= 0x7f) {\n          /* U+0000..U+007F 00..7F */\n          c = b1;\n          inc = 1;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n          /* U+0080..U+07FF C2..DF 80..BF */\n          c = bytes2(b1, buf[i1]);\n          inc = 2;\n          break;\n        }\n        i2 = i + 2;\n        if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n          /* U+0800..U+FFFF */\n          c = bytes3(b1, buf[i1], buf[i2]);\n          inc = 3;\n          break;\n        }\n        i3 = i + 3;\n        if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n          /* U+10000..U+10FFFF */\n          c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n          inc = 4;\n          break;\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        break;\n      }\n      if (c > 0x10ffff) {\n        const at = `byte[${i}]`;\n        if (c === ILL_FORMED) {\n          throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n        }\n        if (c === TRAILING) {\n          throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n        }\n        if (c === RANGE) {\n          throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n        }\n        if (c === NON_SHORTEST) {\n          throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n        }\n        throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n      }\n      chars.push(c);\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16BE algorithms.\nexports.utf16be = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push((char >> 8) & mask[8]);\n        bytes.push(char & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(h & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n      } else {\n        throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i] << 8) + buf[i1];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i + 2] << 8) + buf[i3];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16LE algorithms.\nexports.utf16le = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push(char & mask[8]);\n        bytes.push((char >> 8) & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push(h & mask[8]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n      } else {\n        throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i1] << 8) + buf[i];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i3] << 8) + buf[i + 2];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF32BE algorithms.\nexports.utf32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UTF32LE algorithms.\nexports.utf32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0x7f) {\n        throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      if (buf[i] > 0x7f) {\n        throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n      }\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0xff) {\n        throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i] << 8) + buf[i + 1]);\n    }\n    return chars;\n  },\n};\n\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n  encode(chars) {\n    return exports.utf16le.encode(chars).toString('utf16le');\n  },\n  decode(str) {\n    return exports.utf16le.decode(Buffer.from(str, 'utf16le'), 0);\n  },\n};\n\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n  // Encodes an Array of 32-bit integers into ESCAPED format.\n  encode(chars) {\n    const bytes = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      const char = chars[i];\n      if (char === 96) {\n        bytes.push(char);\n        bytes.push(char);\n      } else if (char === 10) {\n        bytes.push(char);\n      } else if (char >= 32 && char <= 126) {\n        bytes.push(char);\n      } else {\n        let str = '';\n        if (char >= 0 && char <= 31) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 127 && char <= 255) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 0x100 && char <= 0xffff) {\n          str += `\\`u${ascii[(char >> 8) & mask[8]]}${ascii[char & mask[8]]}`;\n        } else if (char >= 0x10000 && char <= 0xffffffff) {\n          str += '`u{';\n          const digit = (char >> 24) & mask[8];\n          if (digit > 0) {\n            str += ascii[digit];\n          }\n          str += `${ascii[(char >> 16) & mask[8]] + ascii[(char >> 8) & mask[8]] + ascii[char & mask[8]]}}`;\n        } else {\n          throw new Error('escape.encode(char): char > 0xffffffff not allowed');\n        }\n        const buf = Buffer.from(str);\n        buf.forEach((b) => {\n          bytes.push(b);\n        });\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n  decode(buf) {\n    function isHex(hex) {\n      if ((hex >= 48 && hex <= 57) || (hex >= 65 && hex <= 70) || (hex >= 97 && hex <= 102)) {\n        return true;\n      }\n      return false;\n    }\n    function getx(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 2, error: true };\n      if (i + 1 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getu(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      if (i + 3 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getU(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      let str = '';\n      while (i < len && isHex(bufArg[i])) {\n        str += String.fromCodePoint(bufArg[i]);\n        // eslint-disable-next-line no-param-reassign\n        i += 1;\n      }\n      ret.char = parseInt(str, 16);\n      if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n        ret.error = false;\n      }\n      ret.nexti = i + 1;\n      return ret;\n    }\n    const chars = [];\n    const len = buf.length;\n    let i1;\n    let ret;\n    let error;\n    let i = 0;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        error = true;\n        if (buf[i] !== 96) {\n          /* unescaped character */\n          chars.push(buf[i]);\n          i += 1;\n          error = false;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 >= len) {\n          break;\n        }\n        if (buf[i1] === 96) {\n          /* escaped grave accent */\n          chars.push(96);\n          i += 2;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 120) {\n          ret = getx(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped hex */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 117) {\n          if (buf[i1 + 1] === 123) {\n            ret = getU(i1 + 2, len, buf);\n            if (ret.error) {\n              break;\n            }\n            /* escaped utf-32 */\n            chars.push(ret.char);\n            i = ret.nexti;\n            error = false;\n            break;\n          }\n          ret = getu(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped utf-16 */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        break;\n      }\n      if (error) {\n        throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n      }\n    }\n    return chars;\n  },\n};\n\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n  crlf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(CR);\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(CR);\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(CR);\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n  lf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n};\n\n// The base 64 algorithms.\nexports.base64 = {\n  encode(buf) {\n    if (buf.length === 0) {\n      return Buffer.alloc(0);\n    }\n    let i;\n    let j;\n    let n;\n    let tail = buf.length % 3;\n    tail = tail > 0 ? 3 - tail : 0;\n    let units = (buf.length + tail) / 3;\n    const base64 = Buffer.alloc(units * 4);\n    if (tail > 0) {\n      units -= 1;\n    }\n    i = 0;\n    j = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = buf[i++] << 16;\n      n += buf[i++] << 8;\n      n += buf[i++];\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j++] = base64codes[n & mask[6]];\n    }\n    if (tail === 0) {\n      return base64;\n    }\n    if (tail === 1) {\n      n = buf[i++] << 16;\n      n += buf[i] << 8;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    if (tail === 2) {\n      n = buf[i] << 16;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[64];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    return undefined;\n  },\n  decode(codes) {\n    /* remove white space and ctrl characters, validate & translate characters */\n    function validate(buf) {\n      const chars = [];\n      let tail = 0;\n      for (let i = 0; i < buf.length; i += 1) {\n        const char = buf[i];\n        const TRUE = true;\n        while (TRUE) {\n          if (char === 32 || char === 9 || char === 10 || char === 13) {\n            break;\n          }\n          if (char >= 65 && char <= 90) {\n            chars.push(char - 65);\n            break;\n          }\n          if (char >= 97 && char <= 122) {\n            chars.push(char - 71);\n            break;\n          }\n          if (char >= 48 && char <= 57) {\n            chars.push(char + 4);\n            break;\n          }\n          if (char === 43) {\n            chars.push(62);\n            break;\n          }\n          if (char === 47) {\n            chars.push(63);\n            break;\n          }\n          if (char === 61) {\n            chars.push(64);\n            tail += 1;\n            break;\n          }\n          /* invalid character */\n          throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n        }\n      }\n      /* validate length */\n      if (chars.length % 4 > 0) {\n        throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n      }\n      /* validate tail */\n      switch (tail) {\n        case 0:\n          break;\n        case 1:\n          if (chars[chars.length - 1] !== 64) {\n            throw new RangeError('base64.decode: one tail character found: not last character');\n          }\n          break;\n        case 2:\n          if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n            throw new RangeError('base64.decode: two tail characters found: not last characters');\n          }\n          break;\n        default:\n          throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n      }\n      return { tail, buf: Buffer.from(chars) };\n    }\n\n    if (codes.length === 0) {\n      return Buffer.alloc(0);\n    }\n    const val = validate(codes);\n    const { tail } = val;\n    const base64 = val.buf;\n    let i;\n    let j;\n    let n;\n    let units = base64.length / 4;\n    const buf = Buffer.alloc(units * 3 - tail);\n    if (tail > 0) {\n      units -= 1;\n    }\n    j = 0;\n    i = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i++] << 6;\n      n += base64[i++];\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j++] = (n >> 8) & mask[8];\n      buf[j++] = n & mask[8];\n    }\n    if (tail === 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i] << 6;\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j] = (n >> 8) & mask[8];\n    }\n    if (tail === 2) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      buf[j] = (n >> 16) & mask[8];\n    }\n    return buf;\n  },\n  // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n  toString(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n    }\n    let str = '';\n    let lineLen = 0;\n    function buildLine(c1, c2, c3, c4) {\n      switch (lineLen) {\n        case 76:\n          str += `\\r\\n${c1}${c2}${c3}${c4}`;\n          lineLen = 4;\n          break;\n        case 75:\n          str += `${c1}\\r\\n${c2}${c3}${c4}`;\n          lineLen = 3;\n          break;\n        case 74:\n          str += `${c1 + c2}\\r\\n${c3}${c4}`;\n          lineLen = 2;\n          break;\n        case 73:\n          str += `${c1 + c2 + c3}\\r\\n${c4}`;\n          lineLen = 1;\n          break;\n        default:\n          str += c1 + c2 + c3 + c4;\n          lineLen += 4;\n          break;\n      }\n    }\n    function validate(c) {\n      if (c >= 65 && c <= 90) {\n        return true;\n      }\n      if (c >= 97 && c <= 122) {\n        return true;\n      }\n      if (c >= 48 && c <= 57) {\n        return true;\n      }\n      if (c === 43) {\n        return true;\n      }\n      if (c === 47) {\n        return true;\n      }\n      if (c === 61) {\n        return true;\n      }\n      return false;\n    }\n    for (let i = 0; i < buf.length; i += 4) {\n      for (let j = i; j < i + 4; j += 1) {\n        if (!validate(buf[j])) {\n          throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n        }\n      }\n      buildLine(\n        String.fromCharCode(buf[i]),\n        String.fromCharCode(buf[i + 1]),\n        String.fromCharCode(buf[i + 2]),\n        String.fromCharCode(buf[i + 3])\n      );\n    }\n    return str;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctY29udi1hcGkvdHJhbnNmb3JtZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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b0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxFQUFFLEtBQUssS0FBSztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixhQUFhO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLEtBQUs7QUFDM0Y7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsV0FBVztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxNQUFNLEdBQUcsRUFBRSxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhLE1BQU0sR0FBRztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxzQkFBc0IsV0FBVztBQUNqQztBQUNBLHVEQUF1RCxFQUFFLEtBQUssUUFBUTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWNvbnYtYXBpL3RyYW5zZm9ybWVycy5qcz85Njk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wbHVzcGx1cyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgY29udGFpbnMgdGhlIGFjdHVhbCBlbmNvZGluZyBhbmQgZGVjb2RpbmcgYWxnb3JpdGhtcy5cbi8vIFRocm93cyBcIlJhbmdlRXJyb3JcIiBleGNlcHRpb25zIG9uIGNoYXJhY3RlcnMgb3IgYnl0ZXMgb3V0IG9mIHJhbmdlIGZvciB0aGUgZ2l2ZW4gZW5jb2RpbmcuXG5cbid1c2Ugc3RyaWN0Oyc7XG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuLyogZGVjb2RpbmcgZXJyb3IgY29kZXMgKi9cbmNvbnN0IE5PTl9TSE9SVEVTVCA9IDB4ZmZmZmZmZmM7XG5jb25zdCBUUkFJTElORyA9IDB4ZmZmZmZmZmQ7XG5jb25zdCBSQU5HRSA9IDB4ZmZmZmZmZmU7XG5jb25zdCBJTExfRk9STUVEID0gMHhmZmZmZmZmZjtcblxuLyogbWFza1tuXSA9IDIqKm4gLSAxLCBpZS4gbWFza1tuXSA9IG4gYml0cyBvbi4gZS5nLiBtYXNrWzZdID0gJWIxMTExMTEgKi9cbmNvbnN0IG1hc2sgPSBbMCwgMSwgMywgNywgMTUsIDMxLCA2MywgMTI3LCAyNTUsIDUxMSwgMTAyM107XG5cbi8qIGFzY2lpW25dID0gJ0hIJywgd2hlcmUgMHhISCA9IG4sIGVnLiBhc2NpaVsyNTRdID0gJ0ZFJyAqL1xuY29uc3QgYXNjaWkgPSBbXG4gICcwMCcsXG4gICcwMScsXG4gICcwMicsXG4gICcwMycsXG4gICcwNCcsXG4gICcwNScsXG4gICcwNicsXG4gICcwNycsXG4gICcwOCcsXG4gICcwOScsXG4gICcwQScsXG4gICcwQicsXG4gICcwQycsXG4gICcwRCcsXG4gICcwRScsXG4gICcwRicsXG4gICcxMCcsXG4gICcxMScsXG4gICcxMicsXG4gICcxMycsXG4gICcxNCcsXG4gICcxNScsXG4gICcxNicsXG4gICcxNycsXG4gICcxOCcsXG4gICcxOScsXG4gICcxQScsXG4gICcxQicsXG4gICcxQycsXG4gICcxRCcsXG4gICcxRScsXG4gICcxRicsXG4gICcyMCcsXG4gICcyMScsXG4gICcyMicsXG4gICcyMycsXG4gICcyNCcsXG4gICcyNScsXG4gICcyNicsXG4gICcyNycsXG4gICcyOCcsXG4gICcyOScsXG4gICcyQScsXG4gICcyQicsXG4gICcyQycsXG4gICcyRCcsXG4gICcyRScsXG4gICcyRicsXG4gICczMCcsXG4gICczMScsXG4gICczMicsXG4gICczMycsXG4gICczNCcsXG4gICczNScsXG4gICczNicsXG4gICczNycsXG4gICczOCcsXG4gICczOScsXG4gICczQScsXG4gICczQicsXG4gICczQycsXG4gICczRCcsXG4gICczRScsXG4gICczRicsXG4gICc0MCcsXG4gICc0MScsXG4gICc0MicsXG4gICc0MycsXG4gICc0NCcsXG4gICc0NScsXG4gICc0NicsXG4gICc0NycsXG4gICc0OCcsXG4gICc0OScsXG4gICc0QScsXG4gICc0QicsXG4gICc0QycsXG4gICc0RCcsXG4gICc0RScsXG4gICc0RicsXG4gICc1MCcsXG4gICc1MScsXG4gICc1MicsXG4gICc1MycsXG4gICc1NCcsXG4gICc1NScsXG4gICc1NicsXG4gICc1NycsXG4gICc1OCcsXG4gICc1OScsXG4gICc1QScsXG4gICc1QicsXG4gICc1QycsXG4gICc1RCcsXG4gICc1RScsXG4gICc1RicsXG4gICc2MCcsXG4gICc2MScsXG4gICc2MicsXG4gICc2MycsXG4gICc2NCcsXG4gICc2NScsXG4gICc2NicsXG4gICc2NycsXG4gICc2OCcsXG4gICc2OScsXG4gICc2QScsXG4gICc2QicsXG4gICc2QycsXG4gICc2RCcsXG4gICc2RScsXG4gICc2RicsXG4gICc3MCcsXG4gICc3MScsXG4gICc3MicsXG4gICc3MycsXG4gICc3NCcsXG4gICc3NScsXG4gICc3NicsXG4gICc3NycsXG4gICc3OCcsXG4gICc3OScsXG4gICc3QScsXG4gICc3QicsXG4gICc3QycsXG4gICc3RCcsXG4gICc3RScsXG4gICc3RicsXG4gICc4MCcsXG4gICc4MScsXG4gICc4MicsXG4gICc4MycsXG4gICc4NCcsXG4gICc4NScsXG4gICc4NicsXG4gICc4NycsXG4gICc4OCcsXG4gICc4OScsXG4gICc4QScsXG4gICc4QicsXG4gICc4QycsXG4gICc4RCcsXG4gICc4RScsXG4gICc4RicsXG4gICc5MCcsXG4gICc5MScsXG4gICc5MicsXG4gICc5MycsXG4gICc5NCcsXG4gICc5NScsXG4gICc5NicsXG4gICc5NycsXG4gICc5OCcsXG4gICc5OScsXG4gICc5QScsXG4gICc5QicsXG4gICc5QycsXG4gICc5RCcsXG4gICc5RScsXG4gICc5RicsXG4gICdBMCcsXG4gICdBMScsXG4gICdBMicsXG4gICdBMycsXG4gICdBNCcsXG4gICdBNScsXG4gICdBNicsXG4gICdBNycsXG4gICdBOCcsXG4gICdBOScsXG4gICdBQScsXG4gICdBQicsXG4gICdBQycsXG4gICdBRCcsXG4gICdBRScsXG4gICdBRicsXG4gICdCMCcsXG4gICdCMScsXG4gICdCMicsXG4gICdCMycsXG4gICdCNCcsXG4gICdCNScsXG4gICdCNicsXG4gICdCNycsXG4gICdCOCcsXG4gICdCOScsXG4gICdCQScsXG4gICdCQicsXG4gICdCQycsXG4gICdCRCcsXG4gICdCRScsXG4gICdCRicsXG4gICdDMCcsXG4gICdDMScsXG4gICdDMicsXG4gICdDMycsXG4gICdDNCcsXG4gICdDNScsXG4gICdDNicsXG4gICdDNycsXG4gICdDOCcsXG4gICdDOScsXG4gICdDQScsXG4gICdDQicsXG4gICdDQycsXG4gICdDRCcsXG4gICdDRScsXG4gICdDRicsXG4gICdEMCcsXG4gICdEMScsXG4gICdEMicsXG4gICdEMycsXG4gICdENCcsXG4gICdENScsXG4gICdENicsXG4gICdENycsXG4gICdEOCcsXG4gICdEOScsXG4gICdEQScsXG4gICdEQicsXG4gICdEQycsXG4gICdERCcsXG4gICdERScsXG4gICdERicsXG4gICdFMCcsXG4gICdFMScsXG4gICdFMicsXG4gICdFMycsXG4gICdFNCcsXG4gICdFNScsXG4gICdFNicsXG4gICdFNycsXG4gICdFOCcsXG4gICdFOScsXG4gICdFQScsXG4gICdFQicsXG4gICdFQycsXG4gICdFRCcsXG4gICdFRScsXG4gICdFRicsXG4gICdGMCcsXG4gICdGMScsXG4gICdGMicsXG4gICdGMycsXG4gICdGNCcsXG4gICdGNScsXG4gICdGNicsXG4gICdGNycsXG4gICdGOCcsXG4gICdGOScsXG4gICdGQScsXG4gICdGQicsXG4gICdGQycsXG4gICdGRCcsXG4gICdGRScsXG4gICdGRicsXG5dO1xuXG4vKiB2ZWN0b3Igb2YgYmFzZSA2NCBjaGFyYWN0ZXJzICovXG5jb25zdCBiYXNlNjRjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPScuc3BsaXQoJycpO1xuXG4vKiB2ZWN0b3Igb2YgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZXMgKi9cbmNvbnN0IGJhc2U2NGNvZGVzID0gW107XG5iYXNlNjRjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gIGJhc2U2NGNvZGVzLnB1c2goY2hhci5jaGFyQ29kZUF0KDApKTtcbn0pO1xuXG4vLyBUaGUgVVRGOCBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGY4ID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmIChjaGFyID49IDAgJiYgY2hhciA8PSAweDdmKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhcik7XG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPD0gMHg3ZmYpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGMwICsgKChjaGFyID4+IDYpICYgbWFza1s1XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoY2hhciAmIG1hc2tbNl0pKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA8IDB4ZDgwMCB8fCAoY2hhciA+IDB4ZGZmZiAmJiBjaGFyIDw9IDB4ZmZmZikpIHtcbiAgICAgICAgYnl0ZXMucHVzaCgweGUwICsgKChjaGFyID4+IDEyKSAmIG1hc2tbNF0pKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKChjaGFyID4+IDYpICYgbWFza1s2XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoY2hhciAmIG1hc2tbNl0pKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMDAwICYmIGNoYXIgPD0gMHgxMGZmZmYpIHtcbiAgICAgICAgY29uc3QgdSA9IChjaGFyID4+IDE2KSAmIG1hc2tbNV07XG4gICAgICAgIGJ5dGVzLnB1c2goMHhmMCArICh1ID4+IDIpKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDgwICsgKCh1ICYgbWFza1syXSkgPDwgNCkgKyAoKGNoYXIgPj4gMTIpICYgbWFza1s0XSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4ODAgKyAoKGNoYXIgPj4gNikgJiBtYXNrWzZdKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHg4MCArIChjaGFyICYgbWFza1s2XSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZW5jb2RlOiBjaGFyYWN0ZXIgb3V0IG9mIHJhbmdlOiBjaGFyOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogYnl0ZXMgZnVuY3Rpb25zIHJldHVybiBlcnJvciBmb3Igbm9uLXNob3J0ZXN0IGZvcm1zICYgdmFsdWVzIG91dCBvZiByYW5nZSAqL1xuICAgIGZ1bmN0aW9uIGJ5dGVzMihiMSwgYjIpIHtcbiAgICAgIC8qIFUrMDA4MC4uVSswN0ZGICovXG4gICAgICAvKiAwMDAwMDAwMCAwMDAwMHl5eSB5eXh4eHh4eCB8IDExMHl5eXl5IDEweHh4eHh4ICovXG4gICAgICBpZiAoKGIyICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIFRSQUlMSU5HO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9ICgoYjEgJiBtYXNrWzVdKSA8PCA2KSArIChiMiAmIG1hc2tbNl0pO1xuICAgICAgaWYgKHggPCAweDgwKSB7XG4gICAgICAgIHJldHVybiBOT05fU0hPUlRFU1Q7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnl0ZXMzKGIxLCBiMiwgYjMpIHtcbiAgICAgIC8qIFUrMDgwMC4uVStGRkZGICovXG4gICAgICAvKiAwMDAwMDAwMCB6enp6eXl5eSB5eXh4eHh4eCB8IDExMTB6enp6IDEweXl5eXl5IDEweHh4eHh4ICovXG4gICAgICBpZiAoKGIzICYgMHhjMCkgIT09IDB4ODAgfHwgKGIyICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgcmV0dXJuIFRSQUlMSU5HO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9ICgoYjEgJiBtYXNrWzRdKSA8PCAxMikgKyAoKGIyICYgbWFza1s2XSkgPDwgNikgKyAoYjMgJiBtYXNrWzZdKTtcbiAgICAgIGlmICh4IDwgMHg4MDApIHtcbiAgICAgICAgcmV0dXJuIE5PTl9TSE9SVEVTVDtcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IDB4ZDgwMCAmJiB4IDw9IDB4ZGZmZikge1xuICAgICAgICByZXR1cm4gUkFOR0U7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnl0ZXM0KGIxLCBiMiwgYjMsIGI0KSB7XG4gICAgICAvKiBVKzEwMDAwLi5VKzEwRkZGRiAqL1xuICAgICAgLyogMDAwdXV1dXUgenp6enl5eXkgeXl4eHh4eHggfCAxMTExMHV1dSAxMHV1enp6eiAxMHl5eXl5eSAxMHh4eHh4eCAqL1xuICAgICAgaWYgKChiNCAmIDB4YzApICE9PSAweDgwIHx8IChiMyAmIDB4YzApICE9PSAweDgwIHx8IChiMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBUUkFJTElORztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPVxuICAgICAgICAoKCgoYjEgJiBtYXNrWzNdKSA8PCAyKSArICgoYjIgPj4gNCkgJiBtYXNrWzJdKSkgPDwgMTYpICtcbiAgICAgICAgKChiMiAmIG1hc2tbNF0pIDw8IDEyKSArXG4gICAgICAgICgoYjMgJiBtYXNrWzZdKSA8PCA2KSArXG4gICAgICAgIChiNCAmIG1hc2tbNl0pO1xuICAgICAgaWYgKHggPCAweDEwMDAwKSB7XG4gICAgICAgIHJldHVybiBOT05fU0hPUlRFU1Q7XG4gICAgICB9XG4gICAgICBpZiAoeCA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHJldHVybiBSQU5HRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBsZXQgYztcbiAgICBsZXQgYjE7XG4gICAgbGV0IGkxO1xuICAgIGxldCBpMjtcbiAgICBsZXQgaTM7XG4gICAgbGV0IGluYztcbiAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICAgIGxldCBpID0gYm9tID8gMyA6IDA7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgYjEgPSBidWZbaV07XG4gICAgICBjID0gSUxMX0ZPUk1FRDtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgaWYgKGIxID49IDAgJiYgYjEgPD0gMHg3Zikge1xuICAgICAgICAgIC8qIFUrMDAwMC4uVSswMDdGIDAwLi43RiAqL1xuICAgICAgICAgIGMgPSBiMTtcbiAgICAgICAgICBpbmMgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkxID0gaSArIDE7XG4gICAgICAgIGlmIChpMSA8IGxlbiAmJiBiMSA+PSAweGMyICYmIGIxIDw9IDB4ZGYpIHtcbiAgICAgICAgICAvKiBVKzAwODAuLlUrMDdGRiBDMi4uREYgODAuLkJGICovXG4gICAgICAgICAgYyA9IGJ5dGVzMihiMSwgYnVmW2kxXSk7XG4gICAgICAgICAgaW5jID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpMiA9IGkgKyAyO1xuICAgICAgICBpZiAoaTIgPCBsZW4gJiYgYjEgPj0gMHhlMCAmJiBiMSA8PSAweGVmKSB7XG4gICAgICAgICAgLyogVSswODAwLi5VK0ZGRkYgKi9cbiAgICAgICAgICBjID0gYnl0ZXMzKGIxLCBidWZbaTFdLCBidWZbaTJdKTtcbiAgICAgICAgICBpbmMgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkzID0gaSArIDM7XG4gICAgICAgIGlmIChpMyA8IGxlbiAmJiBiMSA+PSAweGYwICYmIGIxIDw9IDB4ZjQpIHtcbiAgICAgICAgICAvKiBVKzEwMDAwLi5VKzEwRkZGRiAqL1xuICAgICAgICAgIGMgPSBieXRlczQoYjEsIGJ1ZltpMV0sIGJ1ZltpMl0sIGJ1ZltpM10pO1xuICAgICAgICAgIGluYyA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgd2UgZmFsbCB0aHJvdWdoIHRvIGhlcmUsIGl0IGlzIGFuIGlsbC1mb3JtZWQgc2VxdWVuY2UgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYyA+IDB4MTBmZmZmKSB7XG4gICAgICAgIGNvbnN0IGF0ID0gYGJ5dGVbJHtpfV1gO1xuICAgICAgICBpZiAoYyA9PT0gSUxMX0ZPUk1FRCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGY4LmRlY29kZTogaWxsLWZvcm1lZCBVVEY4IGJ5dGUgc2VxdWVuY2UgZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IFRSQUlMSU5HKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiBpbGxlZ2FsIHRyYWlsaW5nIGJ5dGUgZm91bmQgYXQ6ICR7YXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IFJBTkdFKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiBjb2RlIHBvaW50IG91dCBvZiByYW5nZSBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gTk9OX1NIT1JURVNUKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjguZGVjb2RlOiBub24tc2hvcnRlc3QgZm9ybSBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmOC5kZWNvZGU6IHVucmVjb2duaXplZCBlcnJvciBmb3VuZCBhdDogJHthdH1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goYyk7XG4gICAgICBpICs9IGluYztcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVURjE2QkUgYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmMTZiZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBsZXQgY2hhcjtcbiAgICBsZXQgaDtcbiAgICBsZXQgbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjaGFyID0gY2hhcnNbaV07XG4gICAgICBpZiAoKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDB4ZDdmZikgfHwgKGNoYXIgPj0gMHhlMDAwICYmIGNoYXIgPD0gMHhmZmZmKSkge1xuICAgICAgICBieXRlcy5wdXNoKChjaGFyID4+IDgpICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goY2hhciAmIG1hc2tbOF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweDEwZmZmZikge1xuICAgICAgICBsID0gY2hhciAtIDB4MTAwMDA7XG4gICAgICAgIGggPSAweGQ4MDAgKyAobCA+PiAxMCk7XG4gICAgICAgIGwgPSAweGRjMDAgKyAobCAmIG1hc2tbMTBdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgoaCA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKGggJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgobCA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgICBieXRlcy5wdXNoKGwgJiBtYXNrWzhdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmJlLmVuY29kZTogVVRGMTZCRSB2YWx1ZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpfV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogYXNzdW1lcyBjYWxsZXIgaGFzIGluc3VyZWQgdGhhdCBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDIgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZiZS5kZWNvZGU6IGRhdGEgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiAyOiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICAgIGxldCBpID0gYm9tID8gMiA6IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBjO1xuICAgIGxldCBpbmM7XG4gICAgbGV0IGkxO1xuICAgIGxldCBpMztcbiAgICBsZXQgaGlnaDtcbiAgICBsZXQgbG93O1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGkxID0gaSArIDE7XG4gICAgICAgIGlmIChpMSA8IGxlbikge1xuICAgICAgICAgIGhpZ2ggPSAoYnVmW2ldIDw8IDgpICsgYnVmW2kxXTtcbiAgICAgICAgICBpZiAoaGlnaCA8IDB4ZDgwMCB8fCBoaWdoID4gMHhkZmZmKSB7XG4gICAgICAgICAgICBjID0gaGlnaDtcbiAgICAgICAgICAgIGluYyA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaTMgPSBpICsgMztcbiAgICAgICAgICBpZiAoaTMgPCBsZW4pIHtcbiAgICAgICAgICAgIGxvdyA9IChidWZbaSArIDJdIDw8IDgpICsgYnVmW2kzXTtcbiAgICAgICAgICAgIGlmIChoaWdoIDw9IDB4ZGJmZiAmJiBsb3cgPj0gMHhkYzAwICYmIGxvdyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGhpZ2ggLSAweGQ4MDApIDw8IDEwKSArIChsb3cgLSAweGRjMDApO1xuICAgICAgICAgICAgICBpbmMgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgd2UgZmFsbCB0aHJvdWdoIHRvIGhlcmUsIGl0IGlzIGFuIGlsbC1mb3JtZWQgc2VxdWVuY2UgKi9cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2YmUuZGVjb2RlOiBpbGwtZm9ybWVkIFVURjE2QkUgYnl0ZSBzZXF1ZW5jZSBmb3VuZDogYnl0ZVske2l9XWApO1xuICAgICAgfVxuICAgICAgY2hhcnNbaisrXSA9IGM7XG4gICAgICBpICs9IGluYztcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVURjE2TEUgYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmMTZsZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBsZXQgY2hhcjtcbiAgICBsZXQgaDtcbiAgICBsZXQgbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjaGFyID0gY2hhcnNbaV07XG4gICAgICBpZiAoKGNoYXIgPj0gMCAmJiBjaGFyIDw9IDB4ZDdmZikgfHwgKGNoYXIgPj0gMHhlMDAwICYmIGNoYXIgPD0gMHhmZmZmKSkge1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaCgoY2hhciA+PiA4KSAmIG1hc2tbOF0pO1xuICAgICAgfSBlbHNlIGlmIChjaGFyID49IDB4MTAwMDAgJiYgY2hhciA8PSAweDEwZmZmZikge1xuICAgICAgICBsID0gY2hhciAtIDB4MTAwMDA7XG4gICAgICAgIGggPSAweGQ4MDAgKyAobCA+PiAxMCk7XG4gICAgICAgIGwgPSAweGRjMDAgKyAobCAmIG1hc2tbMTBdKTtcbiAgICAgICAgYnl0ZXMucHVzaChoICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGggPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgICAgYnl0ZXMucHVzaChsICYgbWFza1s4XSk7XG4gICAgICAgIGJ5dGVzLnB1c2goKGwgPj4gOCkgJiBtYXNrWzhdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYxNmxlLmVuY29kZTogVVRGMTZMRSB2YWx1ZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpfV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSxcbiAgZGVjb2RlKGJ1ZiwgYm9tKSB7XG4gICAgLyogYXNzdW1lcyBjYWxsZXIgaGFzIGluc3VyZWQgdGhhdCBidWYgaXMgYSBCdWZmZXIgb2YgYnl0ZXMgKi9cbiAgICBpZiAoYnVmLmxlbmd0aCAlIDIgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMTZsZS5kZWNvZGU6IGRhdGEgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiAyOiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICAgIGxldCBpID0gYm9tID8gMiA6IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBjO1xuICAgIGxldCBpbmM7XG4gICAgbGV0IGkxO1xuICAgIGxldCBpMztcbiAgICBsZXQgaGlnaDtcbiAgICBsZXQgbG93O1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICAgIGkxID0gaSArIDE7XG4gICAgICAgIGlmIChpMSA8IGxlbikge1xuICAgICAgICAgIGhpZ2ggPSAoYnVmW2kxXSA8PCA4KSArIGJ1ZltpXTtcbiAgICAgICAgICBpZiAoaGlnaCA8IDB4ZDgwMCB8fCBoaWdoID4gMHhkZmZmKSB7XG4gICAgICAgICAgICBjID0gaGlnaDtcbiAgICAgICAgICAgIGluYyA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaTMgPSBpICsgMztcbiAgICAgICAgICBpZiAoaTMgPCBsZW4pIHtcbiAgICAgICAgICAgIGxvdyA9IChidWZbaTNdIDw8IDgpICsgYnVmW2kgKyAyXTtcbiAgICAgICAgICAgIGlmIChoaWdoIDw9IDB4ZGJmZiAmJiBsb3cgPj0gMHhkYzAwICYmIGxvdyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGhpZ2ggLSAweGQ4MDApIDw8IDEwKSArIChsb3cgLSAweGRjMDApO1xuICAgICAgICAgICAgICBpbmMgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgd2UgZmFsbCB0aHJvdWdoIHRvIGhlcmUsIGl0IGlzIGFuIGlsbC1mb3JtZWQgc2VxdWVuY2UgKi9cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjE2bGUuZGVjb2RlOiBpbGwtZm9ybWVkIFVURjE2TEUgYnl0ZSBzZXF1ZW5jZSBmb3VuZDogYnl0ZVske2l9XWApO1xuICAgICAgfVxuICAgICAgY2hhcnNbaisrXSA9IGM7XG4gICAgICBpICs9IGluYztcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVURjMyQkUgYWxnb3JpdGhtcy5cbmV4cG9ydHMudXRmMzJiZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBpZiAoKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB8fCBjaGFyID4gMHgxMGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMyYmUuZW5jb2RlOiBVVEYzMkJFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyA0fV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMjQpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gMTYpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmLCBib20pIHtcbiAgICAvKiBjYWxsZXIgdG8gaW5zdXJlIGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmJlLmRlY29kZTogVVRGMzJCRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgNDogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgbGV0IGkgPSBib20gPyA0IDogMDtcbiAgICBmb3IgKDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgY29uc3QgY2hhciA9IChidWZbaV0gPDwgMjQpICsgKGJ1ZltpICsgMV0gPDwgMTYpICsgKGJ1ZltpICsgMl0gPDwgOCkgKyBidWZbaSArIDNdO1xuICAgICAgaWYgKChjaGFyID49IDB4ZDgwMCAmJiBjaGFyIDw9IDB4ZGZmZikgfHwgY2hhciA+IDB4MTBmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1dGYzMmJlLmRlY29kZTogVVRGMzJCRSBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGNoYXJbJHtpIC8gNH1dOiAke2NoYXJ9YCk7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKGNoYXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVVRGMzJMRSBhbGdvcml0aG1zLlxuZXhwb3J0cy51dGYzMmxlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogNCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmICgoY2hhciA+PSAweGQ4MDAgJiYgY2hhciA8PSAweGRmZmYpIHx8IGNoYXIgPiAweDEwZmZmZikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdXRmMzJsZS5lbmNvZGU6IFVURjMyTEUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDR9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYsIGJvbSkge1xuICAgIC8qIGNhbGxlciB0byBpbnN1cmUgYnVmIGlzIGEgQnVmZmVyIG9mIGJ5dGVzICovXG4gICAgaWYgKGJ1Zi5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMyYmUuZGVjb2RlOiBVVEYzMkxFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiA0OiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBsZXQgaSA9IGJvbSA/IDQgOiAwO1xuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBjb25zdCBjaGFyID0gKGJ1ZltpICsgM10gPDwgMjQpICsgKGJ1ZltpICsgMl0gPDwgMTYpICsgKGJ1ZltpICsgMV0gPDwgOCkgKyBidWZbaV07XG4gICAgICBpZiAoKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB8fCBjaGFyID4gMHgxMGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHV0ZjMybGUuZW5jb2RlOiBVVEYzMkxFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyA0fV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goY2hhcik7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UNyBhbGdvcml0aG1zLiBBU0NJSSBvciA3LWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDcgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChjaGFyc1tpXSA+IDB4N2YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQ3LmVuY29kZTogVUlOVDcgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aX1dOiAke2NoYXJzW2ldfWApO1xuICAgICAgfVxuICAgICAgYnVmW2ldID0gY2hhcnNbaV07XG4gICAgfVxuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoYnVmW2ldID4gMHg3Zikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDcuZGVjb2RlOiBVSU5UNyBjaGFyYWN0ZXIgY29kZSBvdXQgb2YgcmFuZ2U6IGJ5dGVbJHtpfV06ICR7YnVmW2ldfWApO1xuICAgICAgfVxuICAgICAgY2hhcnNbaV0gPSBidWZbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UOCBhbGdvcml0aG1zLiBCSU5BUlksIExhdGluIDEgb3IgOC1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQ4ID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoY2hhcnNbaV0gPiAweGZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50OC5lbmNvZGU6IFVJTlQ4IGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2l9XTogJHtjaGFyc1tpXX1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpXSA9IGNoYXJzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2hhcnNbaV0gPSBidWZbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UMTZCRSBhbGdvcml0aG1zLiBCaWctZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDE2YmUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiAyKTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgaWYgKGNoYXIgPiAweGZmZmYpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQxNmJlLmVuY29kZTogVUlOVDE2QkUgY2hhcmFjdGVyIGNvZGUgb3V0IG9mIHJhbmdlOiBjaGFyWyR7aSAvIDJ9XTogJHtjaGFyfWApO1xuICAgICAgfVxuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IGNoYXIgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICBpZiAoYnVmLmxlbmd0aCAlIDIgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgdWludDE2YmUuZGVjb2RlOiBVSU5UMTZCRSBieXRlIGxlbmd0aCBtdXN0IGJlIGV2ZW4gbXVsdGlwbGUgb2YgMjogbGVuZ3RoOiAke2J1Zi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNoYXJzLnB1c2goKGJ1ZltpXSA8PCA4KSArIGJ1ZltpICsgMV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnM7XG4gIH0sXG59O1xuXG4vLyBUaGUgVUlOVDE2TEUgYWxnb3JpdGhtcy4gTGl0dGxlLWVuZGlhbiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcnMuXG5leHBvcnRzLnVpbnQxNmxlID0ge1xuICBlbmNvZGUoY2hhcnMpIHtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoY2hhcnMubGVuZ3RoICogMik7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNoYXJzLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIGlmIChjaGFyID4gMHhmZmZmKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MTZsZS5lbmNvZGU6IFVJTlQxNkxFIGNoYXJhY3RlciBjb2RlIG91dCBvZiByYW5nZTogY2hhclske2kgLyAyfV06ICR7Y2hhcn1gKTtcbiAgICAgIH1cbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmO1xuICB9LFxuICBkZWNvZGUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggJSAyID4gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVpbnQxNmxlLmRlY29kZTogVUlOVDE2TEUgYnl0ZSBsZW5ndGggbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDI6IGxlbmd0aDogJHtidWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjaGFycy5wdXNoKChidWZbaSArIDFdIDw8IDgpICsgYnVmW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIFVJTlQzMkJFIGFsZ29yaXRobXMuIEJpZy1lbmRpYW4gMzItYml0IHVuc2lnbmVkIGludGVnZXJzLlxuZXhwb3J0cy51aW50MzJiZSA9IHtcbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGNoYXJzLmxlbmd0aCAqIDQpO1xuICAgIGxldCBpID0gMDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyKSA9PiB7XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDI0KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbaSsrXSA9IChjaGFyID4+IDgpICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gY2hhciAmIG1hc2tbOF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgZGVjb2RlKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MzJiZS5kZWNvZGU6IFVJTlQzMkJFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiA0OiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgY2hhcnMucHVzaCgoYnVmW2ldIDw8IDI0KSArIChidWZbaSArIDFdIDw8IDE2KSArIChidWZbaSArIDJdIDw8IDgpICsgYnVmW2kgKyAzXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBVSU5UMzJMRSBhbGdvcml0aG1zLiBMaXR0bGUtZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cbmV4cG9ydHMudWludDMybGUgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYyhjaGFycy5sZW5ndGggKiA0KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgY2hhcnMuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgYnVmW2krK10gPSBjaGFyICYgbWFza1s4XTtcbiAgICAgIGJ1ZltpKytdID0gKGNoYXIgPj4gOCkgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2krK10gPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgIH0pO1xuICAgIHJldHVybiBidWY7XG4gIH0sXG4gIGRlY29kZShidWYpIHtcbiAgICAvKiBjYWxsZXIgdG8gaW5zdXJlIGJ1ZiBpcyBhIEJ1ZmZlciBvZiBieXRlcyAqL1xuICAgIGlmIChidWYubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGB1aW50MzJsZS5kZWNvZGU6IFVJTlQzMkxFIGJ5dGUgbGVuZ3RoIG11c3QgYmUgZXZlbiBtdWx0aXBsZSBvZiA0OiBsZW5ndGg6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgY2hhcnMucHVzaCgoYnVmW2kgKyAzXSA8PCAyNCkgKyAoYnVmW2kgKyAyXSA8PCAxNikgKyAoYnVmW2kgKyAxXSA8PCA4KSArIGJ1ZltpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBTVFJJTkcgYWxnb3JpdGhtcy4gQ29udmVydHMgSmF2YVNjcmlwdCBzdHJpbmdzIHRvIEFycmF5IG9mIDMyLWJpdCBpbnRlZ2VycyBhbmQgdmljZSB2ZXJzYS5cbi8vIFVzZXMgdGhlIG5vZGUuanMgQnVmZmVyJ3MgbmF0aXZlIFwidXRmMTZsZVwiIGNhcGFiaWxpdGVzLlxuZXhwb3J0cy5zdHJpbmcgPSB7XG4gIGVuY29kZShjaGFycykge1xuICAgIHJldHVybiBleHBvcnRzLnV0ZjE2bGUuZW5jb2RlKGNoYXJzKS50b1N0cmluZygndXRmMTZsZScpO1xuICB9LFxuICBkZWNvZGUoc3RyKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMudXRmMTZsZS5kZWNvZGUoQnVmZmVyLmZyb20oc3RyLCAndXRmMTZsZScpLCAwKTtcbiAgfSxcbn07XG5cbi8vIFRoZSBFU0NBUEVEIGFsZ29yaXRobXMuXG4vLyBOb3RlIHRoYXQgRVNDQVBFRCBmb3JtYXQgY29udGFpbnMgb25seSBBU0NJSSBjaGFyYWN0ZXJzLlxuLy8gVGhlIGNoYXJhY3RlcnMgYXJlIGFsd2F5cyBpbiB0aGUgZm9ybSBvZiBhIEJ1ZmZlciBvZiBieXRlcy5cbmV4cG9ydHMuZXNjYXBlZCA9IHtcbiAgLy8gRW5jb2RlcyBhbiBBcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMgaW50byBFU0NBUEVEIGZvcm1hdC5cbiAgZW5jb2RlKGNoYXJzKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjaGFyID0gY2hhcnNbaV07XG4gICAgICBpZiAoY2hhciA9PT0gOTYpIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gMTApIHtcbiAgICAgICAgYnl0ZXMucHVzaChjaGFyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAzMiAmJiBjaGFyIDw9IDEyNikge1xuICAgICAgICBieXRlcy5wdXNoKGNoYXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICBpZiAoY2hhciA+PSAwICYmIGNoYXIgPD0gMzEpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcYHgke2FzY2lpW2NoYXJdfWA7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAxMjcgJiYgY2hhciA8PSAyNTUpIHtcbiAgICAgICAgICBzdHIgKz0gYFxcYHgke2FzY2lpW2NoYXJdfWA7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciA+PSAweDEwMCAmJiBjaGFyIDw9IDB4ZmZmZikge1xuICAgICAgICAgIHN0ciArPSBgXFxgdSR7YXNjaWlbKGNoYXIgPj4gOCkgJiBtYXNrWzhdXX0ke2FzY2lpW2NoYXIgJiBtYXNrWzhdXX1gO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPj0gMHgxMDAwMCAmJiBjaGFyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICBzdHIgKz0gJ2B1eyc7XG4gICAgICAgICAgY29uc3QgZGlnaXQgPSAoY2hhciA+PiAyNCkgJiBtYXNrWzhdO1xuICAgICAgICAgIGlmIChkaWdpdCA+IDApIHtcbiAgICAgICAgICAgIHN0ciArPSBhc2NpaVtkaWdpdF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0ciArPSBgJHthc2NpaVsoY2hhciA+PiAxNikgJiBtYXNrWzhdXSArIGFzY2lpWyhjaGFyID4+IDgpICYgbWFza1s4XV0gKyBhc2NpaVtjaGFyICYgbWFza1s4XV19fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlc2NhcGUuZW5jb2RlKGNoYXIpOiBjaGFyID4gMHhmZmZmZmZmZiBub3QgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0cik7XG4gICAgICAgIGJ1Zi5mb3JFYWNoKChiKSA9PiB7XG4gICAgICAgICAgYnl0ZXMucHVzaChiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0sXG4gIC8vIERlY29kZXMgRVNDQVBFRCBmb3JtYXQgZnJvbSBhIEJ1ZmZlciBvZiBieXRlcyB0byBhbiBBcnJheSBvZiAzMi1iaXQgaW50ZWdlcnMuXG4gIGRlY29kZShidWYpIHtcbiAgICBmdW5jdGlvbiBpc0hleChoZXgpIHtcbiAgICAgIGlmICgoaGV4ID49IDQ4ICYmIGhleCA8PSA1NykgfHwgKGhleCA+PSA2NSAmJiBoZXggPD0gNzApIHx8IChoZXggPj0gOTcgJiYgaGV4IDw9IDEwMikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldHgoaSwgbGVuLCBidWZBcmcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgY2hhcjogbnVsbCwgbmV4dGk6IGkgKyAyLCBlcnJvcjogdHJ1ZSB9O1xuICAgICAgaWYgKGkgKyAxIDwgbGVuKSB7XG4gICAgICAgIGlmIChpc0hleChidWZBcmdbaV0pICYmIGlzSGV4KGJ1ZkFyZ1tpICsgMV0pKSB7XG4gICAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYnVmQXJnW2ldLCBidWZBcmdbaSArIDFdKTtcbiAgICAgICAgICByZXQuY2hhciA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJldC5jaGFyKSkge1xuICAgICAgICAgICAgcmV0LmVycm9yID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXR1KGksIGxlbiwgYnVmQXJnKSB7XG4gICAgICBjb25zdCByZXQgPSB7IGNoYXI6IG51bGwsIG5leHRpOiBpICsgNCwgZXJyb3I6IHRydWUgfTtcbiAgICAgIGlmIChpICsgMyA8IGxlbikge1xuICAgICAgICBpZiAoaXNIZXgoYnVmQXJnW2ldKSAmJiBpc0hleChidWZBcmdbaSArIDFdKSAmJiBpc0hleChidWZBcmdbaSArIDJdKSAmJiBpc0hleChidWZBcmdbaSArIDNdKSkge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGJ1ZkFyZ1tpXSwgYnVmQXJnW2kgKyAxXSwgYnVmQXJnW2kgKyAyXSwgYnVmQXJnW2kgKyAzXSk7XG4gICAgICAgICAgcmV0LmNoYXIgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXQuY2hhcikpIHtcbiAgICAgICAgICAgIHJldC5lcnJvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VShpLCBsZW4sIGJ1ZkFyZykge1xuICAgICAgY29uc3QgcmV0ID0geyBjaGFyOiBudWxsLCBuZXh0aTogaSArIDQsIGVycm9yOiB0cnVlIH07XG4gICAgICBsZXQgc3RyID0gJyc7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiBpc0hleChidWZBcmdbaV0pKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChidWZBcmdbaV0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0LmNoYXIgPSBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgIGlmIChidWZBcmdbaV0gPT09IDEyNSAmJiAhTnVtYmVyLmlzTmFOKHJldC5jaGFyKSkge1xuICAgICAgICByZXQuZXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldC5uZXh0aSA9IGkgKyAxO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICAgIGxldCBpMTtcbiAgICBsZXQgcmV0O1xuICAgIGxldCBlcnJvcjtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgZXJyb3IgPSB0cnVlO1xuICAgICAgICBpZiAoYnVmW2ldICE9PSA5Nikge1xuICAgICAgICAgIC8qIHVuZXNjYXBlZCBjaGFyYWN0ZXIgKi9cbiAgICAgICAgICBjaGFycy5wdXNoKGJ1ZltpXSk7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaTEgPSBpICsgMTtcbiAgICAgICAgaWYgKGkxID49IGxlbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbaTFdID09PSA5Nikge1xuICAgICAgICAgIC8qIGVzY2FwZWQgZ3JhdmUgYWNjZW50ICovXG4gICAgICAgICAgY2hhcnMucHVzaCg5Nik7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIGVycm9yID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZltpMV0gPT09IDEyMCkge1xuICAgICAgICAgIHJldCA9IGdldHgoaTEgKyAxLCBsZW4sIGJ1Zik7XG4gICAgICAgICAgaWYgKHJldC5lcnJvcikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzY2FwZWQgaGV4ICovXG4gICAgICAgICAgY2hhcnMucHVzaChyZXQuY2hhcik7XG4gICAgICAgICAgaSA9IHJldC5uZXh0aTtcbiAgICAgICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZbaTFdID09PSAxMTcpIHtcbiAgICAgICAgICBpZiAoYnVmW2kxICsgMV0gPT09IDEyMykge1xuICAgICAgICAgICAgcmV0ID0gZ2V0VShpMSArIDIsIGxlbiwgYnVmKTtcbiAgICAgICAgICAgIGlmIChyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2NhcGVkIHV0Zi0zMiAqL1xuICAgICAgICAgICAgY2hhcnMucHVzaChyZXQuY2hhcik7XG4gICAgICAgICAgICBpID0gcmV0Lm5leHRpO1xuICAgICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXQgPSBnZXR1KGkxICsgMSwgbGVuLCBidWYpO1xuICAgICAgICAgIGlmIChyZXQuZXJyb3IpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2NhcGVkIHV0Zi0xNiAqL1xuICAgICAgICAgIGNoYXJzLnB1c2gocmV0LmNoYXIpO1xuICAgICAgICAgIGkgPSByZXQubmV4dGk7XG4gICAgICAgICAgZXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVzY2FwZWQuZGVjb2RlOiBpbGwtZm9ybWVkIGVzY2FwZSBzZXF1ZW5jZSBhdCBidWZbJHtpfV1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9LFxufTtcblxuLy8gVGhlIGxpbmUgZW5kIGNvbnZlcnNpb24gYWxnb3JpZ3RobXMuXG5jb25zdCBDUiA9IDEzO1xuY29uc3QgTEYgPSAxMDtcbmV4cG9ydHMubGluZUVuZHMgPSB7XG4gIGNybGYoY2hhcnMpIHtcbiAgICBjb25zdCBsZmNoYXJzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY2hhcnMubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKGNoYXJzW2ldKSB7XG4gICAgICAgIGNhc2UgQ1I6XG4gICAgICAgICAgaWYgKGkgKyAxIDwgY2hhcnMubGVuZ3RoICYmIGNoYXJzW2kgKyAxXSA9PT0gTEYpIHtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZmNoYXJzLnB1c2goQ1IpO1xuICAgICAgICAgIGxmY2hhcnMucHVzaChMRik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEY6XG4gICAgICAgICAgbGZjaGFycy5wdXNoKENSKTtcbiAgICAgICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZmNoYXJzLnB1c2goY2hhcnNbaV0pO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxmY2hhcnMubGVuZ3RoID4gMCAmJiBsZmNoYXJzW2xmY2hhcnMubGVuZ3RoIC0gMV0gIT09IExGKSB7XG4gICAgICBsZmNoYXJzLnB1c2goQ1IpO1xuICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICB9XG4gICAgcmV0dXJuIGxmY2hhcnM7XG4gIH0sXG4gIGxmKGNoYXJzKSB7XG4gICAgY29uc3QgbGZjaGFycyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYXJzLmxlbmd0aCkge1xuICAgICAgc3dpdGNoIChjaGFyc1tpXSkge1xuICAgICAgICBjYXNlIENSOlxuICAgICAgICAgIGlmIChpICsgMSA8IGNoYXJzLmxlbmd0aCAmJiBjaGFyc1tpICsgMV0gPT09IExGKSB7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGZjaGFycy5wdXNoKExGKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMRjpcbiAgICAgICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZmNoYXJzLnB1c2goY2hhcnNbaV0pO1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxmY2hhcnMubGVuZ3RoID4gMCAmJiBsZmNoYXJzW2xmY2hhcnMubGVuZ3RoIC0gMV0gIT09IExGKSB7XG4gICAgICBsZmNoYXJzLnB1c2goTEYpO1xuICAgIH1cbiAgICByZXR1cm4gbGZjaGFycztcbiAgfSxcbn07XG5cbi8vIFRoZSBiYXNlIDY0IGFsZ29yaXRobXMuXG5leHBvcnRzLmJhc2U2NCA9IHtcbiAgZW5jb2RlKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgbjtcbiAgICBsZXQgdGFpbCA9IGJ1Zi5sZW5ndGggJSAzO1xuICAgIHRhaWwgPSB0YWlsID4gMCA/IDMgLSB0YWlsIDogMDtcbiAgICBsZXQgdW5pdHMgPSAoYnVmLmxlbmd0aCArIHRhaWwpIC8gMztcbiAgICBjb25zdCBiYXNlNjQgPSBCdWZmZXIuYWxsb2ModW5pdHMgKiA0KTtcbiAgICBpZiAodGFpbCA+IDApIHtcbiAgICAgIHVuaXRzIC09IDE7XG4gICAgfVxuICAgIGkgPSAwO1xuICAgIGogPSAwO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdW5pdHM7IHUgKz0gMSkge1xuICAgICAgbiA9IGJ1ZltpKytdIDw8IDE2O1xuICAgICAgbiArPSBidWZbaSsrXSA8PCA4O1xuICAgICAgbiArPSBidWZbaSsrXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTgpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDEyKSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiA2KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1tuICYgbWFza1s2XV07XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAwKSB7XG4gICAgICByZXR1cm4gYmFzZTY0O1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMSkge1xuICAgICAgbiA9IGJ1ZltpKytdIDw8IDE2O1xuICAgICAgbiArPSBidWZbaV0gPDwgODtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbKG4gPj4gMTgpICYgbWFza1s2XV07XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDEyKSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiA2KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2pdID0gYmFzZTY0Y29kZXNbNjRdO1xuICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9XG4gICAgaWYgKHRhaWwgPT09IDIpIHtcbiAgICAgIG4gPSBidWZbaV0gPDwgMTY7XG4gICAgICBiYXNlNjRbaisrXSA9IGJhc2U2NGNvZGVzWyhuID4+IDE4KSAmIG1hc2tbNl1dO1xuICAgICAgYmFzZTY0W2orK10gPSBiYXNlNjRjb2Rlc1sobiA+PiAxMikgJiBtYXNrWzZdXTtcbiAgICAgIGJhc2U2NFtqKytdID0gYmFzZTY0Y29kZXNbNjRdO1xuICAgICAgYmFzZTY0W2pdID0gYmFzZTY0Y29kZXNbNjRdO1xuICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgZGVjb2RlKGNvZGVzKSB7XG4gICAgLyogcmVtb3ZlIHdoaXRlIHNwYWNlIGFuZCBjdHJsIGNoYXJhY3RlcnMsIHZhbGlkYXRlICYgdHJhbnNsYXRlIGNoYXJhY3RlcnMgKi9cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShidWYpIHtcbiAgICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgICBsZXQgdGFpbCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGFyID0gYnVmW2ldO1xuICAgICAgICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgICAgICBpZiAoY2hhciA9PT0gMzIgfHwgY2hhciA9PT0gOSB8fCBjaGFyID09PSAxMCB8fCBjaGFyID09PSAxMykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID49IDY1ICYmIGNoYXIgPD0gOTApIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhciAtIDY1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA+PSA5NyAmJiBjaGFyIDw9IDEyMikge1xuICAgICAgICAgICAgY2hhcnMucHVzaChjaGFyIC0gNzEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID49IDQ4ICYmIGNoYXIgPD0gNTcpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goY2hhciArIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFyID09PSA0Mykge1xuICAgICAgICAgICAgY2hhcnMucHVzaCg2Mik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT09IDQ3KSB7XG4gICAgICAgICAgICBjaGFycy5wdXNoKDYzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhciA9PT0gNjEpIHtcbiAgICAgICAgICAgIGNoYXJzLnB1c2goNjQpO1xuICAgICAgICAgICAgdGFpbCArPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGludmFsaWQgY2hhcmFjdGVyICovXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC5kZWNvZGU6IGludmFsaWQgY2hhcmFjdGVyIGJ1Zlske2l9XTogJHtjaGFyfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiB2YWxpZGF0ZSBsZW5ndGggKi9cbiAgICAgIGlmIChjaGFycy5sZW5ndGggJSA0ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgYmFzZTY0LmRlY29kZTogc3RyaW5nIGxlbmd0aCBub3QgaW50ZWdyYWwgbXVsdGlwbGUgb2YgNDogJHtjaGFycy5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICAvKiB2YWxpZGF0ZSB0YWlsICovXG4gICAgICBzd2l0Y2ggKHRhaWwpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGNoYXJzW2NoYXJzLmxlbmd0aCAtIDFdICE9PSA2NCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2Jhc2U2NC5kZWNvZGU6IG9uZSB0YWlsIGNoYXJhY3RlciBmb3VuZDogbm90IGxhc3QgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKGNoYXJzW2NoYXJzLmxlbmd0aCAtIDFdICE9PSA2NCB8fCBjaGFyc1tjaGFycy5sZW5ndGggLSAyXSAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdiYXNlNjQuZGVjb2RlOiB0d28gdGFpbCBjaGFyYWN0ZXJzIGZvdW5kOiBub3QgbGFzdCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQuZGVjb2RlOiBtb3JlIHRoYW4gdHdvIHRhaWwgY2hhcmFjdGVycyBmb3VuZDogJHt0YWlsfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdGFpbCwgYnVmOiBCdWZmZXIuZnJvbShjaGFycykgfTtcbiAgICB9XG5cbiAgICBpZiAoY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbiAgICBjb25zdCB2YWwgPSB2YWxpZGF0ZShjb2Rlcyk7XG4gICAgY29uc3QgeyB0YWlsIH0gPSB2YWw7XG4gICAgY29uc3QgYmFzZTY0ID0gdmFsLmJ1ZjtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgbjtcbiAgICBsZXQgdW5pdHMgPSBiYXNlNjQubGVuZ3RoIC8gNDtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2ModW5pdHMgKiAzIC0gdGFpbCk7XG4gICAgaWYgKHRhaWwgPiAwKSB7XG4gICAgICB1bml0cyAtPSAxO1xuICAgIH1cbiAgICBqID0gMDtcbiAgICBpID0gMDtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHVuaXRzOyB1ICs9IDEpIHtcbiAgICAgIG4gPSBiYXNlNjRbaSsrXSA8PCAxODtcbiAgICAgIG4gKz0gYmFzZTY0W2krK10gPDwgMTI7XG4gICAgICBuICs9IGJhc2U2NFtpKytdIDw8IDY7XG4gICAgICBuICs9IGJhc2U2NFtpKytdO1xuICAgICAgYnVmW2orK10gPSAobiA+PiAxNikgJiBtYXNrWzhdO1xuICAgICAgYnVmW2orK10gPSAobiA+PiA4KSAmIG1hc2tbOF07XG4gICAgICBidWZbaisrXSA9IG4gJiBtYXNrWzhdO1xuICAgIH1cbiAgICBpZiAodGFpbCA9PT0gMSkge1xuICAgICAgbiA9IGJhc2U2NFtpKytdIDw8IDE4O1xuICAgICAgbiArPSBiYXNlNjRbaSsrXSA8PCAxMjtcbiAgICAgIG4gKz0gYmFzZTY0W2ldIDw8IDY7XG4gICAgICBidWZbaisrXSA9IChuID4+IDE2KSAmIG1hc2tbOF07XG4gICAgICBidWZbal0gPSAobiA+PiA4KSAmIG1hc2tbOF07XG4gICAgfVxuICAgIGlmICh0YWlsID09PSAyKSB7XG4gICAgICBuID0gYmFzZTY0W2krK10gPDwgMTg7XG4gICAgICBuICs9IGJhc2U2NFtpKytdIDw8IDEyO1xuICAgICAgYnVmW2pdID0gKG4gPj4gMTYpICYgbWFza1s4XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfSxcbiAgLy8gQ29udmVydHMgYSBiYXNlIDY0IEJ1ZmZlciBvZiBieXRlcyB0byBhIEphdmFTY3JpcHQgc3RyaW5nIHdpdGggbGluZSBicmVha3MuXG4gIHRvU3RyaW5nKGJ1Zikge1xuICAgIGlmIChidWYubGVuZ3RoICUgNCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBiYXNlNjQudG9TdHJpbmc6IGlucHV0IGJ1ZmZlciBsZW5ndGggbm90IG11bHRpcGxlIG9mIDQ6ICR7YnVmLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBsaW5lTGVuID0gMDtcbiAgICBmdW5jdGlvbiBidWlsZExpbmUoYzEsIGMyLCBjMywgYzQpIHtcbiAgICAgIHN3aXRjaCAobGluZUxlbikge1xuICAgICAgICBjYXNlIDc2OlxuICAgICAgICAgIHN0ciArPSBgXFxyXFxuJHtjMX0ke2MyfSR7YzN9JHtjNH1gO1xuICAgICAgICAgIGxpbmVMZW4gPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc1OlxuICAgICAgICAgIHN0ciArPSBgJHtjMX1cXHJcXG4ke2MyfSR7YzN9JHtjNH1gO1xuICAgICAgICAgIGxpbmVMZW4gPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc0OlxuICAgICAgICAgIHN0ciArPSBgJHtjMSArIGMyfVxcclxcbiR7YzN9JHtjNH1gO1xuICAgICAgICAgIGxpbmVMZW4gPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDczOlxuICAgICAgICAgIHN0ciArPSBgJHtjMSArIGMyICsgYzN9XFxyXFxuJHtjNH1gO1xuICAgICAgICAgIGxpbmVMZW4gPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0ciArPSBjMSArIGMyICsgYzMgKyBjNDtcbiAgICAgICAgICBsaW5lTGVuICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKGMpIHtcbiAgICAgIGlmIChjID49IDY1ICYmIGMgPD0gOTApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gNDMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gNDcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gNjEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGkgKyA0OyBqICs9IDEpIHtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZShidWZbal0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGJhc2U2NC50b1N0cmluZzogYnVmWyR7an1dOiAke2J1ZltqXX0gOiBub3QgdmFsaWQgYmFzZTY0IGNoYXJhY3RlciBjb2RlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1aWxkTGluZShcbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpICsgMV0pLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpICsgMl0pLFxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpICsgM10pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-conv-api/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/ast.js":
/*!************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/ast.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable guard-for-in */\n/* eslint-disable no-restricted-syntax */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\nmodule.exports = function exportsAst() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'ast.js: ';\n  const that = this;\n  let rules = null;\n  let udts = null;\n  let chars = null;\n  let nodeCount = 0;\n  const nodesDefined = [];\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  this.callbacks = [];\n  this.astObject = 'astObject';\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  this.init = function init(rulesIn, udtsIn, charsIn) {\n    stack.length = 0;\n    records.length = 0;\n    nodesDefined.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodesDefined[i] = false;\n      nodeCallbacks[i] = null;\n    }\n    for (const index in that.callbacks) {\n      const lower = index.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n      }\n      if (typeof that.callbacks[index] === 'function') {\n        nodesDefined[i] = true;\n        nodeCallbacks[i] = that.callbacks[index];\n      }\n      if (that.callbacks[index] === true) {\n        nodesDefined[i] = true;\n      }\n    }\n  };\n  /* AST node definitions - called by the parser's `RNM` operator */\n  this.ruleDefined = function ruleDefined(index) {\n    return nodesDefined[index] !== false;\n  };\n  /* AST node definitions - called by the parser's `UDT` operator */\n  this.udtDefined = function udtDefined(index) {\n    return nodesDefined[rules.length + index] !== false;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the downward traversal of the node */\n  this.down = function down(callbackIndex, name) {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: null,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: null,\n      phraseLength: null,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  this.translate = function translate(data) {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (record.state === id.SEM_PRE) {\n        if (callback !== null) {\n          ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n          if (ret === id.SEM_SKIP) {\n            i = record.thatIndex;\n          }\n        }\n      } else if (callback !== null) {\n        callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  this.setLength = function setLength(length) {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  this.getLength = function getLength() {\n    return records.length;\n  };\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    for (let i = 0; i < n; i += 1) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST.\n  // ```\n  // mode - the display mode of the captured phrases\n  //      - default mode is \"ascii\"\n  //      - can be: \"ascii\"\n  //                \"decimal\"\n  //                \"hexadecimal\"\n  //                \"unicode\"\n  // ```\n  this.toXml = function toSml(modeArg) {\n    let display = utils.charsToDec;\n    let caption = 'decimal integer character codes';\n    if (typeof modeArg === 'string' && modeArg.length >= 3) {\n      const mode = modeArg.slice(0, 3).toLowerCase();\n      if (mode === 'asc') {\n        display = utils.charsToAscii;\n        caption = 'ASCII for printing characters, hex for non-printing';\n      } else if (mode === 'hex') {\n        display = utils.charsToHex;\n        caption = 'hexadecimal integer character codes';\n      } else if (mode === 'uni') {\n        display = utils.charsToUnicode;\n        caption = 'Unicode UTF-32 integer character codes';\n      }\n    }\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string, ${caption} -->\\n`;\n    xml += indent(depth + 2);\n    xml += display(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n  /* generate a JavaScript object version of the AST */\n  /* for the phrase-matching engine apg-exp */\n  this.phrases = function phrases() {\n    const obj = {};\n    let i;\n    let record;\n    for (i = 0; i < records.length; i += 1) {\n      record = records[i];\n      if (record.state === id.SEM_PRE) {\n        if (!Array.isArray(obj[record.name])) {\n          obj[record.name] = [];\n        }\n        obj[record.name].push({\n          index: record.phraseIndex,\n          length: record.phraseLength,\n        });\n      }\n    }\n    return obj;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNkVBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsY0FBYyxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQixnQkFBZ0IsYUFBYTtBQUMzRSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTLFdBQVcsZ0JBQWdCLFlBQVksaUJBQWlCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2FzdC5qcz9kMGQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGlzIHVzZWQgYnkgdGhlIHBhcnNlciB0byBidWlsZCBhbiBbQWJzdHJhY3QgU3ludGF4IFRyZWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Fic3RyYWN0X3N5bnRheF90cmVlKSAoQVNUKS5cbi8vIFRoZSBBU1QgY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBzdWJzZXQgb2YgdGhlIGZ1bGwgcGFyc2UgdHJlZS5cbi8vIEVhY2ggbm9kZSBvZiB0aGUgQVNUIGhvbGRzIHRoZSBwaHJhc2UgdGhhdCB3YXMgbWF0Y2hlZCBhdCB0aGUgY29ycmVzcG9uZGluZywgbmFtZWQgcGFyc2UgdHJlZSBub2RlLlxuLy8gSXQgaXMgYnVpbHQgYXMgdGhlIHBhcnNlciBzdWNjZXNzZnVsbHkgbWF0Y2hlcyBwaHJhc2VzIHRvIHRoZSBydWxlIG5hbWVzXG4vLyAoYFJOTWAgb3BlcmF0b3JzKSBhbmQgYFVEVGBzIGFzIGl0IHBhcnNlcyBhbiBpbnB1dCBzdHJpbmcuXG4vLyBUaGUgdXNlciBjb250cm9scyB3aGljaCBgUk5NYCBvciBgVURUYCBuYW1lcyB0byBrZWVwIG9uIHRoZSBBU1QuXG4vLyBUaGUgdXNlciBjYW4gYWxzbyBhc3NvY2lhdGUgY2FsbGJhY2sgZnVuY3Rpb25zIHdpdGggc29tZSBvciBhbGwgb2YgdGhlIHJldGFpbmVkXG4vLyBBU1Qgbm9kZXMgdG8gYmUgdXNlZCB0byB0cmFuc2xhdGUgdGhlIG5vZGUgcGhyYXNlcy4gVGhhdCBpcywgYXNzb2NpYXRlIHNlbWFudGljXG4vLyBhY3Rpb25zIHRvIHRoZSBtYXRjaGVkIHBocmFzZXMuXG4vLyBUcmFuc2xhdGluZyB0aGUgQVNUIHJhdGhlciB0aGF0IGF0dGVtcHRpbmcgdG8gYXBwbHkgc2VtYW50aWMgYWN0aW9ucyBkdXJpbmdcbi8vIHRoZSBwYXJzaW5nIHByb2Nlc3MsIGhhcyB0aGUgYWR2YW50YWdlIHRoYXQgdGhlcmUgaXMgbm8gYmFja3RyYWNraW5nIGFuZCB0aGF0IHRoZSBwaHJhc2VzXG4vLyBhcmUga25vd24gd2hpbGUgdHJhdmVyc2luZyBkb3duIHRyZWUgYXMgd2lsbCBhcyB1cC5cbi8vXG4vLyBMZXQgYGFzdGAgYmUgYW4gYGFzdC5qc2Agb2JqZWN0LiBUbyBpZGVudGlmeSBhIG5vZGUgdG8gYmUga2VwdCBvbiB0aGUgQVNUOlxuLy8gYGBgXG4vLyBhc3QuY2FsbGJhY2tzW1wicnVsZW5hbWVcIl0gPSB0cnVlOyAoYWxsIG5vZGVzIGRlZmF1bHQgdG8gZmFsc2UpXG4vLyBgYGBcbi8vIFRvIGFzc29jaWF0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYSBub2RlOlxuLy8gYGBgXG4vLyBhc3QuY2FsbGJhY2tzW1wicnVsZW5hbWVcIl0gPSBmblxuLy8gYGBgXG4vLyBgcnVsZW5hbWVgIGlzIGFueSBgUk5NYCBvciBgVURUYCBuYW1lIGRlZmluZWQgYnkgdGhlIGFzc29jaWF0ZWQgZ3JhbW1hclxuLy8gYW5kIGBmbmAgaXMgYSB1c2VyLXdyaXR0ZW4gY2FsbGJhY2sgZnVuY3Rpb24uXG4vLyAoU2VlIFtgYXBnLWV4YW1wbGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qczItZXhhbXBsZXMvdHJlZS9tYXN0ZXIvYXN0KSBmb3IgZXhhbXBsZXMgb2YgaG93IHRvIGNyZWF0ZSBhbiBBU1QsXG4vLyBkZWZpbmUgdGhlIG5vZGVzIGFuZCBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIGF0dGFjaCBpdCB0byBhIHBhcnNlci4pXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cG9ydHNBc3QoKSB7XG4gIGNvbnN0IGlkID0gcmVxdWlyZSgnLi9pZGVudGlmaWVycycpO1xuICBjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG5cbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ2FzdC5qczogJztcbiAgY29uc3QgdGhhdCA9IHRoaXM7XG4gIGxldCBydWxlcyA9IG51bGw7XG4gIGxldCB1ZHRzID0gbnVsbDtcbiAgbGV0IGNoYXJzID0gbnVsbDtcbiAgbGV0IG5vZGVDb3VudCA9IDA7XG4gIGNvbnN0IG5vZGVzRGVmaW5lZCA9IFtdO1xuICBjb25zdCBub2RlQ2FsbGJhY2tzID0gW107XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IHJlY29yZHMgPSBbXTtcbiAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5hc3RPYmplY3QgPSAnYXN0T2JqZWN0JztcbiAgLyogY2FsbGVkIGJ5IHRoZSBwYXJzZXIgdG8gaW5pdGlhbGl6ZSB0aGUgQVNUIHdpdGggdGhlIHJ1bGVzLCBVRFRzIGFuZCB0aGUgaW5wdXQgY2hhcmFjdGVycyAqL1xuICB0aGlzLmluaXQgPSBmdW5jdGlvbiBpbml0KHJ1bGVzSW4sIHVkdHNJbiwgY2hhcnNJbikge1xuICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgcmVjb3Jkcy5sZW5ndGggPSAwO1xuICAgIG5vZGVzRGVmaW5lZC5sZW5ndGggPSAwO1xuICAgIG5vZGVDb3VudCA9IDA7XG4gICAgcnVsZXMgPSBydWxlc0luO1xuICAgIHVkdHMgPSB1ZHRzSW47XG4gICAgY2hhcnMgPSBjaGFyc0luO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaChydWxlc1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2godWR0c1tpXS5sb3dlcik7XG4gICAgfVxuICAgIG5vZGVDb3VudCA9IHJ1bGVzLmxlbmd0aCArIHVkdHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgbm9kZXNEZWZpbmVkW2ldID0gZmFsc2U7XG4gICAgICBub2RlQ2FsbGJhY2tzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBpbiB0aGF0LmNhbGxiYWNrcykge1xuICAgICAgY29uc3QgbG93ZXIgPSBpbmRleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaSA9IGxpc3QuaW5kZXhPZihsb3dlcik7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1pbml0OiBub2RlICcke2luZGV4fScgbm90IGEgcnVsZSBvciB1ZHQgbmFtZWApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGF0LmNhbGxiYWNrc1tpbmRleF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbm9kZXNEZWZpbmVkW2ldID0gdHJ1ZTtcbiAgICAgICAgbm9kZUNhbGxiYWNrc1tpXSA9IHRoYXQuY2FsbGJhY2tzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGF0LmNhbGxiYWNrc1tpbmRleF0gPT09IHRydWUpIHtcbiAgICAgICAgbm9kZXNEZWZpbmVkW2ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIEFTVCBub2RlIGRlZmluaXRpb25zIC0gY2FsbGVkIGJ5IHRoZSBwYXJzZXIncyBgUk5NYCBvcGVyYXRvciAqL1xuICB0aGlzLnJ1bGVEZWZpbmVkID0gZnVuY3Rpb24gcnVsZURlZmluZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gbm9kZXNEZWZpbmVkW2luZGV4XSAhPT0gZmFsc2U7XG4gIH07XG4gIC8qIEFTVCBub2RlIGRlZmluaXRpb25zIC0gY2FsbGVkIGJ5IHRoZSBwYXJzZXIncyBgVURUYCBvcGVyYXRvciAqL1xuICB0aGlzLnVkdERlZmluZWQgPSBmdW5jdGlvbiB1ZHREZWZpbmVkKGluZGV4KSB7XG4gICAgcmV0dXJuIG5vZGVzRGVmaW5lZFtydWxlcy5sZW5ndGggKyBpbmRleF0gIT09IGZhbHNlO1xuICB9O1xuICAvKiBjYWxsZWQgYnkgdGhlIHBhcnNlcidzIGBSTk1gICYgYFVEVGAgb3BlcmF0b3JzICovXG4gIC8qIGJ1aWxkcyBhIHJlY29yZCBmb3IgdGhlIGRvd253YXJkIHRyYXZlcnNhbCBvZiB0aGUgbm9kZSAqL1xuICB0aGlzLmRvd24gPSBmdW5jdGlvbiBkb3duKGNhbGxiYWNrSW5kZXgsIG5hbWUpIHtcbiAgICBjb25zdCB0aGlzSW5kZXggPSByZWNvcmRzLmxlbmd0aDtcbiAgICBzdGFjay5wdXNoKHRoaXNJbmRleCk7XG4gICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICB0aGlzSW5kZXgsXG4gICAgICB0aGF0SW5kZXg6IG51bGwsXG4gICAgICBzdGF0ZTogaWQuU0VNX1BSRSxcbiAgICAgIGNhbGxiYWNrSW5kZXgsXG4gICAgICBwaHJhc2VJbmRleDogbnVsbCxcbiAgICAgIHBocmFzZUxlbmd0aDogbnVsbCxcbiAgICAgIHN0YWNrOiBzdGFjay5sZW5ndGgsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXNJbmRleDtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHRoZSBwYXJzZXIncyBgUk5NYCAmIGBVRFRgIG9wZXJhdG9ycyAqL1xuICAvKiBidWlsZHMgYSByZWNvcmQgZm9yIHRoZSB1cHdhcmQgdHJhdmVyc2FsIG9mIHRoZSBub2RlICovXG4gIHRoaXMudXAgPSBmdW5jdGlvbiB1cChjYWxsYmFja0luZGV4LCBuYW1lLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoKSB7XG4gICAgY29uc3QgdGhpc0luZGV4ID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgY29uc3QgdGhhdEluZGV4ID0gc3RhY2sucG9wKCk7XG4gICAgcmVjb3Jkcy5wdXNoKHtcbiAgICAgIG5hbWUsXG4gICAgICB0aGlzSW5kZXgsXG4gICAgICB0aGF0SW5kZXgsXG4gICAgICBzdGF0ZTogaWQuU0VNX1BPU1QsXG4gICAgICBjYWxsYmFja0luZGV4LFxuICAgICAgcGhyYXNlSW5kZXgsXG4gICAgICBwaHJhc2VMZW5ndGgsXG4gICAgICBzdGFjazogc3RhY2subGVuZ3RoLFxuICAgIH0pO1xuICAgIHJlY29yZHNbdGhhdEluZGV4XS50aGF0SW5kZXggPSB0aGlzSW5kZXg7XG4gICAgcmVjb3Jkc1t0aGF0SW5kZXhdLnBocmFzZUluZGV4ID0gcGhyYXNlSW5kZXg7XG4gICAgcmVjb3Jkc1t0aGF0SW5kZXhdLnBocmFzZUxlbmd0aCA9IHBocmFzZUxlbmd0aDtcbiAgICByZXR1cm4gdGhpc0luZGV4O1xuICB9O1xuICAvLyBDYWxsZWQgYnkgdGhlIHVzZXIgdG8gdHJhbnNsYXRlIHRoZSBBU1QuXG4gIC8vIFRyYW5zbGF0ZSBtZWFucyB0byBhc3NvY2lhdGUgb3IgYXBwbHkgc29tZSBzZW1hbnRpYyBhY3Rpb24gdG8gdGhlXG4gIC8vIHBocmFzZXMgdGhhdCB3ZXJlIHN5bnRhY3RpY2FsbHkgbWF0Y2hlZCB0byB0aGUgQVNUIG5vZGVzIGFjY29yZGluZ1xuICAvLyB0byB0aGUgZGVmaW5pbmcgZ3JhbW1hci5cbiAgLy8gYGBgXG4gIC8vIGRhdGEgLSBvcHRpb25hbCB1c2VyLWRlZmluZWQgZGF0YVxuICAvLyAgICAgICAgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMgYnkgdGhlIHRyYW5zbGF0b3JcbiAgLy8gYGBgXG4gIHRoaXMudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKGRhdGEpIHtcbiAgICBsZXQgcmV0O1xuICAgIGxldCBjYWxsYmFjaztcbiAgICBsZXQgcmVjb3JkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgIGNhbGxiYWNrID0gbm9kZUNhbGxiYWNrc1tyZWNvcmQuY2FsbGJhY2tJbmRleF07XG4gICAgICBpZiAocmVjb3JkLnN0YXRlID09PSBpZC5TRU1fUFJFKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldCA9IGNhbGxiYWNrKGlkLlNFTV9QUkUsIGNoYXJzLCByZWNvcmQucGhyYXNlSW5kZXgsIHJlY29yZC5waHJhc2VMZW5ndGgsIGRhdGEpO1xuICAgICAgICAgIGlmIChyZXQgPT09IGlkLlNFTV9TS0lQKSB7XG4gICAgICAgICAgICBpID0gcmVjb3JkLnRoYXRJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgY2FsbGJhY2soaWQuU0VNX1BPU1QsIGNoYXJzLCByZWNvcmQucGhyYXNlSW5kZXgsIHJlY29yZC5waHJhc2VMZW5ndGgsIGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHRoZSBwYXJzZXIgdG8gcmVzZXQgdGhlIGxlbmd0aCBvZiB0aGUgcmVjb3JkcyBhcnJheSAqL1xuICAvKiBuZWNlc3Nhcnkgb24gYmFja3RyYWNraW5nICovXG4gIHRoaXMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gc2V0TGVuZ3RoKGxlbmd0aCkge1xuICAgIHJlY29yZHMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBzdGFjay5sZW5ndGggPSByZWNvcmRzW2xlbmd0aCAtIDFdLnN0YWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgIH1cbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHRoZSBwYXJzZXIgdG8gZ2V0IHRoZSBsZW5ndGggb2YgdGhlIHJlY29yZHMgYXJyYXkgKi9cbiAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHJlY29yZHMubGVuZ3RoO1xuICB9O1xuICAvKiBoZWxwZXIgZm9yIFhNTCBkaXNwbGF5ICovXG4gIGZ1bmN0aW9uIGluZGVudChuKSB7XG4gICAgbGV0IHJldCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG4gICAgICByZXQgKz0gJyAnO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8vIEdlbmVyYXRlIGFuIGBYTUxgIHZlcnNpb24gb2YgdGhlIEFTVC5cbiAgLy8gVXNlZnVsIGlmIHlvdSB3YW50IHRvIHVzZSBhIHNwZWNpYWwgb3IgZmF2b3JpdGUgWE1MIHBhcnNlciB0byB0cmFuc2xhdGUgdGhlXG4gIC8vIEFTVC5cbiAgLy8gYGBgXG4gIC8vIG1vZGUgLSB0aGUgZGlzcGxheSBtb2RlIG9mIHRoZSBjYXB0dXJlZCBwaHJhc2VzXG4gIC8vICAgICAgLSBkZWZhdWx0IG1vZGUgaXMgXCJhc2NpaVwiXG4gIC8vICAgICAgLSBjYW4gYmU6IFwiYXNjaWlcIlxuICAvLyAgICAgICAgICAgICAgICBcImRlY2ltYWxcIlxuICAvLyAgICAgICAgICAgICAgICBcImhleGFkZWNpbWFsXCJcbiAgLy8gICAgICAgICAgICAgICAgXCJ1bmljb2RlXCJcbiAgLy8gYGBgXG4gIHRoaXMudG9YbWwgPSBmdW5jdGlvbiB0b1NtbChtb2RlQXJnKSB7XG4gICAgbGV0IGRpc3BsYXkgPSB1dGlscy5jaGFyc1RvRGVjO1xuICAgIGxldCBjYXB0aW9uID0gJ2RlY2ltYWwgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMnO1xuICAgIGlmICh0eXBlb2YgbW9kZUFyZyA9PT0gJ3N0cmluZycgJiYgbW9kZUFyZy5sZW5ndGggPj0gMykge1xuICAgICAgY29uc3QgbW9kZSA9IG1vZGVBcmcuc2xpY2UoMCwgMykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChtb2RlID09PSAnYXNjJykge1xuICAgICAgICBkaXNwbGF5ID0gdXRpbHMuY2hhcnNUb0FzY2lpO1xuICAgICAgICBjYXB0aW9uID0gJ0FTQ0lJIGZvciBwcmludGluZyBjaGFyYWN0ZXJzLCBoZXggZm9yIG5vbi1wcmludGluZyc7XG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdoZXgnKSB7XG4gICAgICAgIGRpc3BsYXkgPSB1dGlscy5jaGFyc1RvSGV4O1xuICAgICAgICBjYXB0aW9uID0gJ2hleGFkZWNpbWFsIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzJztcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ3VuaScpIHtcbiAgICAgICAgZGlzcGxheSA9IHV0aWxzLmNoYXJzVG9Vbmljb2RlO1xuICAgICAgICBjYXB0aW9uID0gJ1VuaWNvZGUgVVRGLTMyIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzJztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHhtbCA9ICcnO1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgeG1sICs9ICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCJ1dGYtOFwiPz5cXG4nO1xuICAgIHhtbCArPSBgPHJvb3Qgbm9kZXM9XCIke3JlY29yZHMubGVuZ3RoIC8gMn1cIiBjaGFyYWN0ZXJzPVwiJHtjaGFycy5sZW5ndGh9XCI+XFxuYDtcbiAgICB4bWwgKz0gYDwhLS0gaW5wdXQgc3RyaW5nLCAke2NhcHRpb259IC0tPlxcbmA7XG4gICAgeG1sICs9IGluZGVudChkZXB0aCArIDIpO1xuICAgIHhtbCArPSBkaXNwbGF5KGNoYXJzKTtcbiAgICB4bWwgKz0gJ1xcbic7XG4gICAgcmVjb3Jkcy5mb3JFYWNoKChyZWMpID0+IHtcbiAgICAgIGlmIChyZWMuc3RhdGUgPT09IGlkLlNFTV9QUkUpIHtcbiAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgeG1sICs9IGluZGVudChkZXB0aCk7XG4gICAgICAgIHhtbCArPSBgPG5vZGUgbmFtZT1cIiR7cmVjLm5hbWV9XCIgaW5kZXg9XCIke3JlYy5waHJhc2VJbmRleH1cIiBsZW5ndGg9XCIke3JlYy5waHJhc2VMZW5ndGh9XCI+XFxuYDtcbiAgICAgICAgeG1sICs9IGluZGVudChkZXB0aCArIDIpO1xuICAgICAgICB4bWwgKz0gZGlzcGxheShjaGFycywgcmVjLnBocmFzZUluZGV4LCByZWMucGhyYXNlTGVuZ3RoKTtcbiAgICAgICAgeG1sICs9ICdcXG4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeG1sICs9IGluZGVudChkZXB0aCk7XG4gICAgICAgIHhtbCArPSBgPC9ub2RlPjwhLS0gbmFtZT1cIiR7cmVjLm5hbWV9XCIgLS0+XFxuYDtcbiAgICAgICAgZGVwdGggLT0gMTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHhtbCArPSAnPC9yb290Plxcbic7XG4gICAgcmV0dXJuIHhtbDtcbiAgfTtcbiAgLyogZ2VuZXJhdGUgYSBKYXZhU2NyaXB0IG9iamVjdCB2ZXJzaW9uIG9mIHRoZSBBU1QgKi9cbiAgLyogZm9yIHRoZSBwaHJhc2UtbWF0Y2hpbmcgZW5naW5lIGFwZy1leHAgKi9cbiAgdGhpcy5waHJhc2VzID0gZnVuY3Rpb24gcGhyYXNlcygpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBsZXQgaTtcbiAgICBsZXQgcmVjb3JkO1xuICAgIGZvciAoaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgaWYgKHJlY29yZC5zdGF0ZSA9PT0gaWQuU0VNX1BSRSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW3JlY29yZC5uYW1lXSkpIHtcbiAgICAgICAgICBvYmpbcmVjb3JkLm5hbWVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgb2JqW3JlY29yZC5uYW1lXS5wdXNoKHtcbiAgICAgICAgICBpbmRleDogcmVjb3JkLnBocmFzZUluZGV4LFxuICAgICAgICAgIGxlbmd0aDogcmVjb3JkLnBocmFzZUxlbmd0aCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/ast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js":
/*!************************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/circular-buffer.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\nmodule.exports = function exportsCircularBuffer() {\n  'use strict;';\n\n  const thisFileName = 'circular-buffer.js: ';\n  let itemIndex = -1;\n  let maxListSize = 0;\n  // Initialize buffer.<br>\n  // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n  this.init = function init(size) {\n    if (typeof size !== 'number' || size <= 0) {\n      throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n    }\n    maxListSize = Math.ceil(size);\n    itemIndex = -1;\n  };\n  // Call this to increment the number of records collected.<br>\n  // Returns the array index number to store the next record in.\n  this.increment = function increment() {\n    itemIndex += 1;\n    return (itemIndex + maxListSize) % maxListSize;\n  };\n  // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n  this.maxSize = function maxSize() {\n    return maxListSize;\n  };\n  // Returns the highest number of items saved.<br>\n  // (The number of items is the actual number of records processed\n  // even though only `maxListSize` records are actually retained.)\n  this.items = function items() {\n    return itemIndex + 1;\n  };\n  // Returns the record number associated with this item index.\n  this.getListIndex = function getListIndex(item) {\n    if (itemIndex === -1) {\n      return -1;\n    }\n    if (item < 0 || item > itemIndex) {\n      return -1;\n    }\n    if (itemIndex - item >= maxListSize) {\n      return -1;\n    }\n    return (item + maxListSize) % maxListSize;\n  };\n  // The iterator over the circular buffer.\n  // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n  // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n  this.forEach = function forEach(fn) {\n    if (itemIndex === -1) {\n      /* no records have been collected */\n      return;\n    }\n    if (itemIndex < maxListSize) {\n      /* fewer than maxListSize records have been collected - number of items = number of records */\n      for (let i = 0; i <= itemIndex; i += 1) {\n        fn(i, i);\n      }\n      return;\n    }\n    /* start with the oldest record saved and finish with the most recent record saved */\n    for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {\n      const listIndex = (i + maxListSize) % maxListSize;\n      fn(listIndex, i);\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2NpcmN1bGFyLWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2NpcmN1bGFyLWJ1ZmZlci5qcz9lYzE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIGFjdHMgYXMgYSBcImNpcmN1bGFyIGJ1ZmZlclwiLiBJdCBpcyB1c2VkIHRvIGtlZXAgdHJhY2tcbi8vIG9ubHkgdGhlIGxhc3QgTiByZWNvcmRzIGluIGFuIGFycmF5IG9mIHJlY29yZHMuIElmIG1vcmUgdGhhbiBOIHJlY29yZHNcbi8vIGFyZSBzYXZlZCwgZWFjaCBhZGRpdGlvbmFsIHJlY29yZCBvdmVyd3JpdGVzIHRoZSBwcmV2aW91c2x5IG9sZGVzdCByZWNvcmQuXG4vLyBUaGlzIG1vZHVsZSBkZWFscyBvbmx5IHdpdGggdGhlIHJlY29yZCBpbmRleGVzIGFuZCBkb2VzIG5vdCBzYXZlXG4vLyBhbnkgYWN0dWFsIHJlY29yZHMuIEl0IGlzIHVzZWQgYnkgW2B0cmFjZS5qc2BdKC4vdHJhY2UuaHRtbCkgZm9yIGxpbWl0aW5nIHRoZSBudW1iZXIgb2Zcbi8vIHRyYWNlIHJlY29yZHMgc2F2ZWQuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cG9ydHNDaXJjdWxhckJ1ZmZlcigpIHtcbiAgJ3VzZSBzdHJpY3Q7JztcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnY2lyY3VsYXItYnVmZmVyLmpzOiAnO1xuICBsZXQgaXRlbUluZGV4ID0gLTE7XG4gIGxldCBtYXhMaXN0U2l6ZSA9IDA7XG4gIC8vIEluaXRpYWxpemUgYnVmZmVyLjxicj5cbiAgLy8gKnNpemUqIGlzIGBtYXhMaXN0U2l6ZWAsIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHNhdmVkIGJlZm9yZSBvdmVyd3JpdGluZyBiZWdpbnMuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIGluaXQoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicgfHwgc2l6ZSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWluaXQ6IGNpcmN1bGFyIGJ1ZmZlciBzaXplIG11c3QgYW4gaW50ZWdlciA+IDBgKTtcbiAgICB9XG4gICAgbWF4TGlzdFNpemUgPSBNYXRoLmNlaWwoc2l6ZSk7XG4gICAgaXRlbUluZGV4ID0gLTE7XG4gIH07XG4gIC8vIENhbGwgdGhpcyB0byBpbmNyZW1lbnQgdGhlIG51bWJlciBvZiByZWNvcmRzIGNvbGxlY3RlZC48YnI+XG4gIC8vIFJldHVybnMgdGhlIGFycmF5IGluZGV4IG51bWJlciB0byBzdG9yZSB0aGUgbmV4dCByZWNvcmQgaW4uXG4gIHRoaXMuaW5jcmVtZW50ID0gZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICAgIGl0ZW1JbmRleCArPSAxO1xuICAgIHJldHVybiAoaXRlbUluZGV4ICsgbWF4TGlzdFNpemUpICUgbWF4TGlzdFNpemU7XG4gIH07XG4gIC8vIFJldHVybnMgYG1heExpc3RTaXplYCAtIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvcmRzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlci5cbiAgdGhpcy5tYXhTaXplID0gZnVuY3Rpb24gbWF4U2l6ZSgpIHtcbiAgICByZXR1cm4gbWF4TGlzdFNpemU7XG4gIH07XG4gIC8vIFJldHVybnMgdGhlIGhpZ2hlc3QgbnVtYmVyIG9mIGl0ZW1zIHNhdmVkLjxicj5cbiAgLy8gKFRoZSBudW1iZXIgb2YgaXRlbXMgaXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgcmVjb3JkcyBwcm9jZXNzZWRcbiAgLy8gZXZlbiB0aG91Z2ggb25seSBgbWF4TGlzdFNpemVgIHJlY29yZHMgYXJlIGFjdHVhbGx5IHJldGFpbmVkLilcbiAgdGhpcy5pdGVtcyA9IGZ1bmN0aW9uIGl0ZW1zKCkge1xuICAgIHJldHVybiBpdGVtSW5kZXggKyAxO1xuICB9O1xuICAvLyBSZXR1cm5zIHRoZSByZWNvcmQgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGl0ZW0gaW5kZXguXG4gIHRoaXMuZ2V0TGlzdEluZGV4ID0gZnVuY3Rpb24gZ2V0TGlzdEluZGV4KGl0ZW0pIHtcbiAgICBpZiAoaXRlbUluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoaXRlbSA8IDAgfHwgaXRlbSA+IGl0ZW1JbmRleCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoaXRlbUluZGV4IC0gaXRlbSA+PSBtYXhMaXN0U2l6ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gKGl0ZW0gKyBtYXhMaXN0U2l6ZSkgJSBtYXhMaXN0U2l6ZTtcbiAgfTtcbiAgLy8gVGhlIGl0ZXJhdG9yIG92ZXIgdGhlIGNpcmN1bGFyIGJ1ZmZlci5cbiAgLy8gVGhlIHVzZXIncyBmdW5jdGlvbiwgYGZuYCwgd2lsbCBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgYGZuKGxpc3RJbmRleCwgaXRlbUluZGV4KWBcbiAgLy8gd2hlcmUgYGxpc3RJbmRleGAgaXMgdGhlIHNhdmVkIHJlY29yZCBpbmRleCBhbmQgYGl0ZW1JbmRleGAgaXMgdGhlIGFjdHVhbCBpdGVtIGluZGV4LlxuICB0aGlzLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gICAgaWYgKGl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgIC8qIG5vIHJlY29yZHMgaGF2ZSBiZWVuIGNvbGxlY3RlZCAqL1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXRlbUluZGV4IDwgbWF4TGlzdFNpemUpIHtcbiAgICAgIC8qIGZld2VyIHRoYW4gbWF4TGlzdFNpemUgcmVjb3JkcyBoYXZlIGJlZW4gY29sbGVjdGVkIC0gbnVtYmVyIG9mIGl0ZW1zID0gbnVtYmVyIG9mIHJlY29yZHMgKi9cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGl0ZW1JbmRleDsgaSArPSAxKSB7XG4gICAgICAgIGZuKGksIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBzdGFydCB3aXRoIHRoZSBvbGRlc3QgcmVjb3JkIHNhdmVkIGFuZCBmaW5pc2ggd2l0aCB0aGUgbW9zdCByZWNlbnQgcmVjb3JkIHNhdmVkICovXG4gICAgZm9yIChsZXQgaSA9IGl0ZW1JbmRleCAtIG1heExpc3RTaXplICsgMTsgaSA8PSBpdGVtSW5kZXg7IGkgKz0gMSkge1xuICAgICAgY29uc3QgbGlzdEluZGV4ID0gKGkgKyBtYXhMaXN0U2l6ZSkgJSBtYXhMaXN0U2l6ZTtcbiAgICAgIGZuKGxpc3RJbmRleCwgaSk7XG4gICAgfVxuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js":
/*!****************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/emitcss.js ***!
  \****************************************************/
/***/ ((module) => {

eval("// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss(){\nreturn '/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2VtaXRjc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRiwyQkFBMkIsR0FBRyxlQUFlLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxjQUFjLHNCQUFzQixtQkFBbUIsR0FBRyxnQkFBZ0Isc0JBQXNCLG1CQUFtQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsaUJBQWlCLHNCQUFzQixtQkFBbUIsR0FBRyxrQkFBa0Isc0JBQXNCLG1CQUFtQixHQUFHLGtCQUFrQix3QkFBd0IsdUJBQXVCLHFCQUFxQixHQUFHLGlCQUFpQixzQkFBc0IsbUJBQW1CLEdBQUcsY0FBYyxzQkFBc0IsbUJBQW1CLEdBQUcsZUFBZSxtQkFBbUIsOEJBQThCLEdBQUcscUJBQXFCLG1CQUFtQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMscUJBQXFCLDRCQUE0Qiw4QkFBOEIsR0FBRywrRUFBK0Usc0JBQXNCLEdBQUcsMkJBQTJCLG9CQUFvQixzQkFBc0Isc0JBQXNCLHFCQUFxQixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0Isc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRywrSUFBK0kscUJBQXFCLEdBQUcscUJBQXFCLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDZCQUE2QixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywrQ0FBK0Msc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxRUFBcUUscUJBQXFCLEdBQUcsbUJBQW1CLDJCQUEyQixvQkFBb0Isb0JBQW9CLHNCQUFzQixzQkFBc0IsNEJBQTRCLDhCQUE4QixHQUFHLDJCQUEyQixvQkFBb0Isc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRywyQ0FBMkMsc0JBQXNCLDRCQUE0Qiw4QkFBOEIsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHLG1CQUFtQiwyQkFBMkIsb0JBQW9CLG9CQUFvQixzQkFBc0IsdUJBQXVCLDRCQUE0Qiw4QkFBOEIsR0FBRywyQkFBMkIsb0JBQW9CLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUcsMkNBQTJDLHVCQUF1Qiw0QkFBNEIsOEJBQThCLEdBQUcsdUdBQXVHLHNCQUFzQixHQUFHLHVHQUF1RyxzQkFBc0IsR0FBRyxxQkFBcUIsOEJBQThCLEdBQUcsMkJBQTJCLDhCQUE4QixHQUFHO0FBQzdzSSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL2FwZy1qcy9zcmMvYXBnLWxpYi9lbWl0Y3NzLmpzPzZkNTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBtb2R1bGUgaGFzIGJlZW4gZGV2ZWxvcGVkIHByb2dyYW1tYXRpY2FsbHkgaW4gdGhlIGBhcGctbGliYCBidWlsZCBwcm9jZXNzLlxuLy8gSXQgaXMgdXNlZCB0byBidWlsZCB3ZWIgcGFnZXMgcHJvZ3JhbWF0aWNhbGx5IG9uIHRoZSBmbHkgd2l0aG91dCB0aGUgbmVlZCBmb3IgPHNjcmlwdD4gb3IgPHN0eWxlPiB0YWdzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVtaXR0Y3NzKCl7XG5yZXR1cm4gJy8qIFRoaXMgZmlsZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSBqc29uVG9sZXNzKCkgYW5kIExFU1MuICovXFxuLmFwZy1tb25vIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcbi5hcGctYWN0aXZlIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMwMDAwMDA7XFxufVxcbi5hcGctbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogIzI2NEJGRjtcXG59XFxuLmFwZy1lbXB0eSB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMGZiZDBmO1xcbn1cXG4uYXBnLW5vbWF0Y2gge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogI0ZGNDAwMDtcXG59XFxuLmFwZy1saC1tYXRjaCB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiAjMUE5N0JBO1xcbn1cXG4uYXBnLWxiLW1hdGNoIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICM1RjE2ODc7XFxufVxcbi5hcGctcmVtYWluZGVyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICM5OTk5OTk7XFxufVxcbi5hcGctY3RybC1jaGFyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICBmb250LXN0eWxlOiBpdGFsaWM7XFxuICBmb250LXNpemU6IDAuNmVtO1xcbn1cXG4uYXBnLWxpbmUtZW5kIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6ICMwMDAwMDA7XFxufVxcbi5hcGctZXJyb3Ige1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogI0ZGNDAwMDtcXG59XFxuLmFwZy1waHJhc2Uge1xcbiAgY29sb3I6ICMwMDAwMDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOGNhYWU2O1xcbn1cXG4uYXBnLWVtcHR5LXBocmFzZSB7XFxuICBjb2xvcjogIzBmYmQwZjtcXG59XFxudGFibGUuYXBnLXN0YXRlIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1zdGF0ZSB0aCxcXG50YWJsZS5hcGctc3RhdGUgdGQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRlIHRoOm50aC1sYXN0LWNoaWxkKDIpLFxcbnRhYmxlLmFwZy1zdGF0ZSB0ZDpudGgtbGFzdC1jaGlsZCgyKSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxudGFibGUuYXBnLXN0YXRlIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1zdGF0cyB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRzIHRoLFxcbnRhYmxlLmFwZy1zdGF0cyB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXN0YXRzIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy10cmFjZSB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgbWFyZ2luLXRvcDogNXB4O1xcbiAgZm9udC1zaXplOiAxMXB4O1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXRyYWNlIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy10cmFjZSB0aCxcXG50YWJsZS5hcGctdHJhY2UgdGQge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy10cmFjZSB0aDpsYXN0LWNoaWxkLFxcbnRhYmxlLmFwZy10cmFjZSB0aDpudGgtbGFzdC1jaGlsZCgyKSxcXG50YWJsZS5hcGctdHJhY2UgdGQ6bGFzdC1jaGlsZCxcXG50YWJsZS5hcGctdHJhY2UgdGQ6bnRoLWxhc3QtY2hpbGQoMikge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLWdyYW1tYXIge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gIG1hcmdpbi10b3A6IDVweDtcXG4gIGZvbnQtc2l6ZTogMTFweDtcXG4gIGxpbmUtaGVpZ2h0OiAxMzAlO1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxuICBib3JkZXI6IDFweCBzb2xpZCBibGFjaztcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1ncmFtbWFyIHRoLFxcbnRhYmxlLmFwZy1ncmFtbWFyIHRkIHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctZ3JhbW1hciB0aDpsYXN0LWNoaWxkLFxcbnRhYmxlLmFwZy1ncmFtbWFyIHRkOmxhc3QtY2hpbGQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXJ1bGVzIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctcnVsZXMgY2FwdGlvbiB7XFxuICBmb250LXNpemU6IDEyNSU7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxudGFibGUuYXBnLXJ1bGVzIHRoLFxcbnRhYmxlLmFwZy1ydWxlcyB0ZCB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLXJ1bGVzIGEge1xcbiAgY29sb3I6ICMwMDMzOTkgIWltcG9ydGFudDtcXG59XFxudGFibGUuYXBnLXJ1bGVzIGE6aG92ZXIge1xcbiAgY29sb3I6ICM4Y2FhZTYgIWltcG9ydGFudDtcXG59XFxudGFibGUuYXBnLWF0dHJzIHtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxuICBtYXJnaW4tdG9wOiA1cHg7XFxuICBmb250LXNpemU6IDExcHg7XFxuICBsaW5lLWhlaWdodDogMTMwJTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrO1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG59XFxudGFibGUuYXBnLWF0dHJzIGNhcHRpb24ge1xcbiAgZm9udC1zaXplOiAxMjUlO1xcbiAgbGluZS1oZWlnaHQ6IDEzMCU7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyB0aCxcXG50YWJsZS5hcGctYXR0cnMgdGQge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgYm9yZGVyOiAxcHggc29saWQgYmxhY2s7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG50YWJsZS5hcGctYXR0cnMgdGg6bnRoLWNoaWxkKDEpLFxcbnRhYmxlLmFwZy1hdHRycyB0aDpudGgtY2hpbGQoMiksXFxudGFibGUuYXBnLWF0dHJzIHRoOm50aC1jaGlsZCgzKSB7XFxuICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxudGFibGUuYXBnLWF0dHJzIHRkOm50aC1jaGlsZCgxKSxcXG50YWJsZS5hcGctYXR0cnMgdGQ6bnRoLWNoaWxkKDIpLFxcbnRhYmxlLmFwZy1hdHRycyB0ZDpudGgtY2hpbGQoMykge1xcbiAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyBhIHtcXG4gIGNvbG9yOiAjMDAzMzk5ICFpbXBvcnRhbnQ7XFxufVxcbnRhYmxlLmFwZy1hdHRycyBhOmhvdmVyIHtcXG4gIGNvbG9yOiAjOGNhYWU2ICFpbXBvcnRhbnQ7XFxufVxcbic7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js":
/*!********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/identifiers.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n  // Identifies the operator type. Used by the generator\n  // to indicate operator types in the grammar object.\n  // Used by the [parser](./parser.html) when interpreting the grammar object.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  BKR: 14 /* back reference to a previously matched rule name */,\n  BKA: 15 /* positive look behind */,\n  BKN: 16 /* negative look behind */,\n  ABG: 17 /* anchor - begin of string */,\n  AEN: 18 /* anchor - end of string */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n  // - *SEM_OK* - normal return value\n  // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n  // the translator will skip processing all `AST` nodes in the branch below the current node.\n  // Ignored if returned from the SEM_POST state.\n  SEM_OK: 300,\n  SEM_SKIP: 301,\n  // Used in attribute generation to distinguish the necessary attribute categories.\n  // - *ATTR_N* - non-recursive\n  // - *ATTR_R* - recursive\n  // - *ATTR_MR* - belongs to a mutually-recursive set\n  ATTR_N: 400,\n  ATTR_R: 401,\n  ATTR_MR: 402,\n  // Look around values indicate whether the parser is in look ahead or look behind mode.\n  // Used by the tracing facility to indicate the look around mode in the trace records display.\n  // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n  // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n  // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n  LOOKAROUND_NONE: 500,\n  LOOKAROUND_AHEAD: 501,\n  LOOKAROUND_BEHIND: 502,\n  // Back reference rule mode indicators\n  // - *BKR_MODE_UM* - the back reference is using universal mode\n  // - *BKR_MODE_PM* - the back reference is using parent frame mode\n  // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n  // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n  BKR_MODE_UM: 601,\n  BKR_MODE_PM: 602,\n  BKR_MODE_CS: 603,\n  BKR_MODE_CI: 604,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL2lkZW50aWZpZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvaWRlbnRpZmllcnMuanM/YmY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBjb3B5cmlnaHQ6IENvcHlyaWdodCAoYykgMjAyMSBMb3dlbGwgRC4gVGhvbWFzLCBhbGwgcmlnaHRzIHJlc2VydmVkXG4gKiAgICAgbGljZW5zZTogQlNELTItQ2xhdXNlIChodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0yLUNsYXVzZSlcbiAqICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vLyBUaGlzIG1vZHVsZSBleHBvc2VzIGEgbGlzdCBvZiBuYW1lZCBpZGVudGlmaWVycywgc2hhcmVkIGFjcm9zcyB0aGUgcGFyc2VyIGdlbmVyYXRvclxuLy8gYW5kIHRoZSBwYXJzZXJzIHRoYXQgYXJlIGdlbmVyYXRlZC5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIElkZW50aWZpZXMgdGhlIG9wZXJhdG9yIHR5cGUuIFVzZWQgYnkgdGhlIGdlbmVyYXRvclxuICAvLyB0byBpbmRpY2F0ZSBvcGVyYXRvciB0eXBlcyBpbiB0aGUgZ3JhbW1hciBvYmplY3QuXG4gIC8vIFVzZWQgYnkgdGhlIFtwYXJzZXJdKC4vcGFyc2VyLmh0bWwpIHdoZW4gaW50ZXJwcmV0aW5nIHRoZSBncmFtbWFyIG9iamVjdC5cbiAgLyogdGhlIG9yaWdpbmFsIEFCTkYgb3BlcmF0b3JzICovXG4gIEFMVDogMSAvKiBhbHRlcm5hdGlvbiAqLyxcbiAgQ0FUOiAyIC8qIGNvbmNhdGVuYXRpb24gKi8sXG4gIFJFUDogMyAvKiByZXBldGl0aW9uICovLFxuICBSTk06IDQgLyogcnVsZSBuYW1lICovLFxuICBUUkc6IDUgLyogdGVybWluYWwgcmFuZ2UgKi8sXG4gIFRCUzogNiAvKiB0ZXJtaW5hbCBiaW5hcnkgc3RyaW5nLCBjYXNlIHNlbnNpdGl2ZSAqLyxcbiAgVExTOiA3IC8qIHRlcm1pbmFsIGxpdGVyYWwgc3RyaW5nLCBjYXNlIGluc2Vuc2l0aXZlICovLFxuICAvKiB0aGUgc3VwZXIgc2V0LCBTQUJORiBvcGVyYXRvcnMgKi9cbiAgVURUOiAxMSAvKiB1c2VyLWRlZmluZWQgdGVybWluYWwgKi8sXG4gIEFORDogMTIgLyogcG9zaXRpdmUgbG9vayBhaGVhZCAqLyxcbiAgTk9UOiAxMyAvKiBuZWdhdGl2ZSBsb29rIGFoZWFkICovLFxuICBCS1I6IDE0IC8qIGJhY2sgcmVmZXJlbmNlIHRvIGEgcHJldmlvdXNseSBtYXRjaGVkIHJ1bGUgbmFtZSAqLyxcbiAgQktBOiAxNSAvKiBwb3NpdGl2ZSBsb29rIGJlaGluZCAqLyxcbiAgQktOOiAxNiAvKiBuZWdhdGl2ZSBsb29rIGJlaGluZCAqLyxcbiAgQUJHOiAxNyAvKiBhbmNob3IgLSBiZWdpbiBvZiBzdHJpbmcgKi8sXG4gIEFFTjogMTggLyogYW5jaG9yIC0gZW5kIG9mIHN0cmluZyAqLyxcbiAgLy8gVXNlZCBieSB0aGUgcGFyc2VyIGFuZCB0aGUgdXNlcidzIGBSTk1gIGFuZCBgVURUYCBjYWxsYmFjayBmdW5jdGlvbnMuXG4gIC8vIElkZW50aWZpZXMgdGhlIHBhcnNlciBzdGF0ZSBhcyBpdCB0cmF2ZXJzZXMgdGhlIHBhcnNlIHRyZWUgbm9kZXMuXG4gIC8vIC0gKkFDVElWRSogLSBpbmRpY2F0ZXMgdGhlIGRvd253YXJkIGRpcmVjdGlvbiB0aHJvdWdoIHRoZSBwYXJzZSB0cmVlIG5vZGUuXG4gIC8vIC0gKk1BVENIKiAtIGluZGljYXRlcyB0aGUgdXB3YXJkIGRpcmVjdGlvbiBhbmQgYSBwaHJhc2UsIG9mIGxlbmd0aCBcXD4gMCwgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG1hdGNoZWRcbiAgLy8gLSAqRU1QVFkqIC0gaW5kaWNhdGVzIHRoZSB1cHdhcmQgZGlyZWN0aW9uIGFuZCBhIHBocmFzZSwgb2YgbGVuZ3RoID0gMCwgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IG1hdGNoZWRcbiAgLy8gLSAqTk9NQVRDSCogLSBpbmRpY2F0ZXMgdGhlIHVwd2FyZCBkaXJlY3Rpb24gYW5kIHRoZSBwYXJzZXIgZmFpbGVkIHRvIG1hdGNoIGFueSBwaHJhc2UgYXQgYWxsXG4gIEFDVElWRTogMTAwLFxuICBNQVRDSDogMTAxLFxuICBFTVBUWTogMTAyLFxuICBOT01BVENIOiAxMDMsXG4gIC8vIFVzZWQgYnkgW2BBU1RgIHRyYW5zbGF0b3JdKC4vYXN0Lmh0bWwpIChzZW1hbnRpYyBhbmFseXNpcykgYW5kIHRoZSB1c2VyJ3MgY2FsbGJhY2sgZnVuY3Rpb25zXG4gIC8vIHRvIGluZGljYXRlIHRoZSBkaXJlY3Rpb24gb2YgZmxvdyB0aHJvdWdoIHRoZSBgQVNUYCBub2Rlcy5cbiAgLy8gLSAqU0VNX1BSRSogLSBpbmRpY2F0ZXMgdGhlIGRvd253YXJkIChwcmUtYnJhbmNoKSBkaXJlY3Rpb24gdGhyb3VnaCB0aGUgYEFTVGAgbm9kZS5cbiAgLy8gLSAqU0VNX1BPU1QqIC0gaW5kaWNhdGVzIHRoZSB1cHdhcmQgKHBvc3QtYnJhbmNoKSBkaXJlY3Rpb24gdGhyb3VnaCB0aGUgYEFTVGAgbm9kZS5cbiAgU0VNX1BSRTogMjAwLFxuICBTRU1fUE9TVDogMjAxLFxuICAvLyBVc2VkIGJ5IHRoZSB1c2VyJ3MgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIGluZGljYXRlIHRvIHRoZSBgQVNUYCB0cmFuc2xhdG9yIChzZW1hbnRpYyBhbmFseXNpcykgaG93IHRvIHByb2NlZWQuXG4gIC8vIC0gKlNFTV9PSyogLSBub3JtYWwgcmV0dXJuIHZhbHVlXG4gIC8vIC0gKlNFTV9TS0lQKiAtIGlmIGEgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyB0aGlzIHZhbHVlIGZyb20gdGhlIFNFTV9QUkUgc3RhdGUsXG4gIC8vIHRoZSB0cmFuc2xhdG9yIHdpbGwgc2tpcCBwcm9jZXNzaW5nIGFsbCBgQVNUYCBub2RlcyBpbiB0aGUgYnJhbmNoIGJlbG93IHRoZSBjdXJyZW50IG5vZGUuXG4gIC8vIElnbm9yZWQgaWYgcmV0dXJuZWQgZnJvbSB0aGUgU0VNX1BPU1Qgc3RhdGUuXG4gIFNFTV9PSzogMzAwLFxuICBTRU1fU0tJUDogMzAxLFxuICAvLyBVc2VkIGluIGF0dHJpYnV0ZSBnZW5lcmF0aW9uIHRvIGRpc3Rpbmd1aXNoIHRoZSBuZWNlc3NhcnkgYXR0cmlidXRlIGNhdGVnb3JpZXMuXG4gIC8vIC0gKkFUVFJfTiogLSBub24tcmVjdXJzaXZlXG4gIC8vIC0gKkFUVFJfUiogLSByZWN1cnNpdmVcbiAgLy8gLSAqQVRUUl9NUiogLSBiZWxvbmdzIHRvIGEgbXV0dWFsbHktcmVjdXJzaXZlIHNldFxuICBBVFRSX046IDQwMCxcbiAgQVRUUl9SOiA0MDEsXG4gIEFUVFJfTVI6IDQwMixcbiAgLy8gTG9vayBhcm91bmQgdmFsdWVzIGluZGljYXRlIHdoZXRoZXIgdGhlIHBhcnNlciBpcyBpbiBsb29rIGFoZWFkIG9yIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIFVzZWQgYnkgdGhlIHRyYWNpbmcgZmFjaWxpdHkgdG8gaW5kaWNhdGUgdGhlIGxvb2sgYXJvdW5kIG1vZGUgaW4gdGhlIHRyYWNlIHJlY29yZHMgZGlzcGxheS5cbiAgLy8gLSAqTE9PS0FST1VORF9OT05FKiAtIHRoZSBwYXJzZXIgaXMgaW4gbm9ybWFsIHBhcnNpbmcgbW9kZVxuICAvLyAtICpMT09LQVJPVU5EX0FIRUFEKiAtIHRoZSBwYXJzZSBpcyBpbiBsb29rLWFoZWFkIG1vZGUsIHBocmFzZSBtYXRjaGluZyBmb3Igb3BlcmF0b3IgYEFORCgmKWAgb3IgYE5PVCghKWBcbiAgLy8gLSAqTE9PS0FST1VORF9CRUhJTkQqIC0gdGhlIHBhcnNlIGlzIGluIGxvb2stYmVoaW5kIG1vZGUsIHBocmFzZSBtYXRjaGluZyBmb3Igb3BlcmF0b3IgYEJLQSgmJilgIG9yIGBCS04oISEpYFxuICBMT09LQVJPVU5EX05PTkU6IDUwMCxcbiAgTE9PS0FST1VORF9BSEVBRDogNTAxLFxuICBMT09LQVJPVU5EX0JFSElORDogNTAyLFxuICAvLyBCYWNrIHJlZmVyZW5jZSBydWxlIG1vZGUgaW5kaWNhdG9yc1xuICAvLyAtICpCS1JfTU9ERV9VTSogLSB0aGUgYmFjayByZWZlcmVuY2UgaXMgdXNpbmcgdW5pdmVyc2FsIG1vZGVcbiAgLy8gLSAqQktSX01PREVfUE0qIC0gdGhlIGJhY2sgcmVmZXJlbmNlIGlzIHVzaW5nIHBhcmVudCBmcmFtZSBtb2RlXG4gIC8vIC0gKkJLUl9NT0RFX0NTKiAtIHRoZSBiYWNrIHJlZmVyZW5jZSBpcyB1c2luZyBjYXNlLXNlbnNpdGl2ZSBwaHJhc2UgbWF0Y2hpbmdcbiAgLy8gLSAqQktSX01PREVfQ0kqIC0gdGhlIGJhY2sgcmVmZXJlbmNlIGlzIHVzaW5nIGNhc2UtaW5zZW5zaXRpdmUgcGhyYXNlIG1hdGNoaW5nXG4gIEJLUl9NT0RFX1VNOiA2MDEsXG4gIEJLUl9NT0RFX1BNOiA2MDIsXG4gIEJLUl9NT0RFX0NTOiA2MDMsXG4gIEJLUl9NT0RFX0NJOiA2MDQsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js":
/*!*********************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/node-exports.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\nmodule.exports = {\n  ast: __webpack_require__(/*! ./ast */ \"(ssr)/./node_modules/apg-js/src/apg-lib/ast.js\"),\n  circular: __webpack_require__(/*! ./circular-buffer */ \"(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js\"),\n  ids: __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\"),\n  parser: __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/apg-js/src/apg-lib/parser.js\"),\n  stats: __webpack_require__(/*! ./stats */ \"(ssr)/./node_modules/apg-js/src/apg-lib/stats.js\"),\n  trace: __webpack_require__(/*! ./trace */ \"(ssr)/./node_modules/apg-js/src/apg-lib/trace.js\"),\n  utils: __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\"),\n  emitcss: __webpack_require__(/*! ./emitcss */ \"(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js\"),\n  style: __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\"),\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLDZEQUFPO0FBQ3RCLFlBQVksbUJBQU8sQ0FBQyxxRkFBbUI7QUFDdkMsT0FBTyxtQkFBTyxDQUFDLDZFQUFlO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxtRUFBVTtBQUM1QixTQUFTLG1CQUFPLENBQUMsaUVBQVM7QUFDMUIsU0FBUyxtQkFBTyxDQUFDLGlFQUFTO0FBQzFCLFNBQVMsbUJBQU8sQ0FBQyx5RUFBYTtBQUM5QixXQUFXLG1CQUFPLENBQUMscUVBQVc7QUFDOUIsU0FBUyxtQkFBTyxDQUFDLGlFQUFTO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL25vZGUtZXhwb3J0cy5qcz8zZDFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIHNlcnZlcyB0byBleHBvcnQgYWxsIGxpYnJhcnkgb2JqZWN0cyBhbmQgb2JqZWN0IGNvbnN0cnVjdG9ycyB3aXRoIHRoZSBgcmVxdWlyZShcImFwZy1saWJcIilgIHN0YXRlbWVudC5cbi8vIEZvciBleGFtcGxlLCB0byBjcmVhdGUgYSBuZXcgcGFyc2VyIGluIHlvdXIgcHJvZ3JhbSxcbi8vIGBgYGBcbi8vIGxldCBhcGdsaWIgPSByZXF1aXJlKFwiLi4vYXBnLWxpYi9ub2RlLWV4cG9ydHNcIik7XG4vLyBsZXQgbXktcGFyc2VyID0gbmV3IGFwZ2xpYi5wYXJzZXIoKTtcbi8vIGBgYGBcbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3Q6IHJlcXVpcmUoJy4vYXN0JyksXG4gIGNpcmN1bGFyOiByZXF1aXJlKCcuL2NpcmN1bGFyLWJ1ZmZlcicpLFxuICBpZHM6IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKSxcbiAgcGFyc2VyOiByZXF1aXJlKCcuL3BhcnNlcicpLFxuICBzdGF0czogcmVxdWlyZSgnLi9zdGF0cycpLFxuICB0cmFjZTogcmVxdWlyZSgnLi90cmFjZScpLFxuICB1dGlsczogcmVxdWlyZSgnLi91dGlsaXRpZXMnKSxcbiAgZW1pdGNzczogcmVxdWlyZSgnLi9lbWl0Y3NzJyksXG4gIHN0eWxlOiByZXF1aXJlKCcuL3N0eWxlJyksXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/node-exports.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable new-cap */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\nmodule.exports = function parser() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n\n  const thisFileName = 'parser.js: ';\n  const thisThis = this;\n  let opExecute;\n  this.ast = null;\n  this.stats = null;\n  this.trace = null;\n  this.callbacks = [];\n  let opcodes = null;\n  let chars = null;\n  let charsBegin;\n  let charsLength;\n  let charsEnd;\n  let lookAround;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let ruleCallbacks = null;\n  let udtCallbacks = null;\n  let rules = null;\n  let udts = null;\n  let syntaxData = null;\n  let maxMatched = 0;\n  let limitTreeDepth = Infinity;\n  let limitNodeHits = Infinity;\n  // Evaluates any given rule. This can be called from the syntax callback\n  // functions to evaluate any rule in the grammar's rule list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateRule(): `;\n    if (ruleIndex >= rules.length) {\n      throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.RNM,\n      index: ruleIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  // Evaluates any given UDT. This can be called from the syntax callback\n  // functions to evaluate any UDT in the grammar's UDT list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateUdt = function (udtIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateUdt(): `;\n    if (udtIndex >= udts.length) {\n      throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.UDT,\n      empty: udts[udtIndex].empty,\n      index: udtIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  /* Clears this object of any/all data that has been initialized or added to it. */\n  /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */\n  const clear = function () {\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    lookAround = [\n      {\n        lookAround: id.LOOKAROUND_NONE,\n        anchor: 0,\n        charsEnd: 0,\n        charsLength: 0,\n      },\n    ];\n    rules = null;\n    udts = null;\n    chars = null;\n    charsBegin = 0;\n    charsLength = 0;\n    charsEnd = 0;\n    ruleCallbacks = null;\n    udtCallbacks = null;\n    syntaxData = null;\n    opcodes = null;\n  };\n  /* object for maintaining a stack of back reference frames */\n  const backRef = function () {\n    const stack = [];\n    const init = function () {\n      const obj = {};\n      rules.forEach((rule) => {\n        if (rule.isBkr) {\n          obj[rule.lower] = null;\n        }\n      });\n      if (udts.length > 0) {\n        udts.forEach((udt) => {\n          if (udt.isBkr) {\n            obj[udt.lower] = null;\n          }\n        });\n      }\n      stack.push(obj);\n    };\n    const copy = function () {\n      const top = stack[stack.length - 1];\n      const obj = {};\n      /* // eslint-disable-next-line no-restricted-syntax */\n      for (const name in top) {\n        obj[name] = top[name];\n      }\n      return obj;\n    };\n    this.push = function push() {\n      stack.push(copy());\n    };\n    this.pop = function pop(lengthArg) {\n      let length = lengthArg;\n      if (!length) {\n        length = stack.length - 1;\n      }\n      if (length < 1 || length > stack.length) {\n        throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n      }\n      stack.length = length;\n      return stack[stack.length - 1];\n    };\n    this.length = function length() {\n      return stack.length;\n    };\n    this.savePhrase = function savePhrase(name, index, length) {\n      stack[stack.length - 1][name] = {\n        phraseIndex: index,\n        phraseLength: length,\n      };\n    };\n    this.getPhrase = function (name) {\n      return stack[stack.length - 1][name];\n    };\n    /* constructor */\n    init();\n  };\n  // The system data structure that relays system information to and from the rule and UDT callback functions.\n  // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n  // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n  // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n  // - *lookaround* - the top of the stack holds the current look around state,\n  // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n  // - *uFrame* - the \"universal\" back reference frame.\n  // Holds the last matched phrase for each of the back referenced rules and UDTs.\n  // - *pFrame* - the stack of \"parent\" back reference frames.\n  // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n  // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  const systemData = function systemData() {\n    const thisData = this;\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.ruleIndex = 0;\n    this.udtIndex = 0;\n    this.lookAround = lookAround[lookAround.length - 1];\n    this.uFrame = new backRef();\n    this.pFrame = new backRef();\n    this.evaluateRule = evaluateRule;\n    this.evaluateUdt = evaluateUdt;\n    /* refresh the parser state for the next operation */\n    this.refresh = function refresh() {\n      thisData.state = id.ACTIVE;\n      thisData.phraseLength = 0;\n      thisData.lookAround = lookAround[lookAround.length - 1];\n    };\n  };\n  /* some look around helper functions */\n  const lookAroundValue = function lookAroundValue() {\n    return lookAround[lookAround.length - 1];\n  };\n  /* return true if parser is in look around (ahead or behind) state */\n  const inLookAround = function inLookAround() {\n    return lookAround.length > 1;\n  };\n  /* return true if parser is in look behind state */\n  const inLookBehind = function () {\n    return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n  };\n  /* called by parse() to initialize the AST object, if one has been defined */\n  const initializeAst = function () {\n    const functionName = `${thisFileName}initializeAst(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.ast === undefined) {\n        thisThis.ast = null;\n        break;\n      }\n      if (thisThis.ast === null) {\n        break;\n      }\n      if (thisThis.ast.astObject !== 'astObject') {\n        throw new Error(`${functionName}ast object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.ast !== null) {\n      thisThis.ast.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the trace object, if one has been defined */\n  const initializeTrace = function () {\n    const functionName = `${thisFileName}initializeTrace(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.trace === undefined) {\n        thisThis.trace = null;\n        break;\n      }\n      if (thisThis.trace === null) {\n        break;\n      }\n      if (thisThis.trace.traceObject !== 'traceObject') {\n        throw new Error(`${functionName}trace object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.trace !== null) {\n      thisThis.trace.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the statistics object, if one has been defined */\n  const initializeStats = function () {\n    const functionName = `${thisFileName}initializeStats(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.stats === undefined) {\n        thisThis.stats = null;\n        break;\n      }\n      if (thisThis.stats === null) {\n        break;\n      }\n      if (thisThis.stats.statsObject !== 'statsObject') {\n        throw new Error(`${functionName}stats object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.stats !== null) {\n      thisThis.stats.init(rules, udts);\n    }\n  };\n  /* called by parse() to initialize the rules & udts from the grammar object */\n  /* (the grammar object generated previously by apg) */\n  const initializeGrammar = function (grammar) {\n    const functionName = `${thisFileName}initializeGrammar(): `;\n    if (!grammar) {\n      throw new Error(`${functionName}grammar object undefined`);\n    }\n    if (grammar.grammarObject !== 'grammarObject') {\n      throw new Error(`${functionName}bad grammar object`);\n    }\n    rules = grammar.rules;\n    udts = grammar.udts;\n  };\n  /* called by parse() to initialize the start rule */\n  const initializeStartRule = function (startRule) {\n    const functionName = `${thisFileName}initializeStartRule(): `;\n    let start = null;\n    if (typeof startRule === 'number') {\n      if (startRule >= rules.length) {\n        throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n      }\n      start = startRule;\n    } else if (typeof startRule === 'string') {\n      const lower = startRule.toLowerCase();\n      for (let i = 0; i < rules.length; i += 1) {\n        if (lower === rules[i].lower) {\n          start = rules[i].index;\n          break;\n        }\n      }\n      if (start === null) {\n        throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n      }\n    } else {\n      throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n    }\n    return start;\n  };\n  /* called by parse() to initialize the array of characters codes representing the input string */\n  const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n    const functionName = `${thisFileName}initializeInputChars(): `;\n    /* varify and normalize input */\n    let input = inputArg;\n    let beg = begArg;\n    let len = lenArg;\n    if (input === undefined) {\n      throw new Error(`${functionName}input string is undefined`);\n    }\n    if (input === null) {\n      throw new Error(`${functionName}input string is null`);\n    }\n    if (typeof input === 'string') {\n      input = utils.stringToChars(input);\n    } else if (!Array.isArray(input)) {\n      throw new Error(`${functionName}input string is not a string or array`);\n    }\n    if (input.length > 0) {\n      if (typeof input[0] !== 'number') {\n        throw new Error(`${functionName}input string not an array of integers`);\n      }\n    }\n    /* verify and normalize beginning index */\n    if (typeof beg !== 'number') {\n      beg = 0;\n    } else {\n      beg = Math.floor(beg);\n      if (beg < 0 || beg > input.length) {\n        throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n      }\n    }\n    /* verify and normalize input length */\n    if (typeof len !== 'number') {\n      len = input.length - beg;\n    } else {\n      len = Math.floor(len);\n      if (len < 0 || len > input.length - beg) {\n        throw new Error(`${functionName}input length out of range: ${len}`);\n      }\n    }\n    chars = input;\n    charsBegin = beg;\n    charsLength = len;\n    charsEnd = charsBegin + charsLength;\n  };\n  /* called by parse() to initialize the user-written, syntax callback functions, if any */\n  const initializeCallbacks = function () {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = null;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = null;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in thisThis.callbacks) {\n      i = list.indexOf(index.toLowerCase());\n      if (i < 0) {\n        throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n      }\n      func = thisThis.callbacks[index];\n      if (!func) {\n        func = null;\n      }\n      if (typeof func === 'function' || func === null) {\n        if (i < rules.length) {\n          ruleCallbacks[i] = func;\n        } else {\n          udtCallbacks[i - rules.length] = func;\n        }\n      } else {\n        throw new Error(\n          `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`\n        );\n      }\n    }\n    /* make sure all udts have been defined - the parser can't work without them */\n    for (i = 0; i < udts.length; i += 1) {\n      if (udtCallbacks[i] === null) {\n        throw new Error(\n          `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`\n        );\n      }\n    }\n  };\n  // Set the maximum parse tree depth allowed. The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxTreeDepth = function (depth) {\n    if (typeof depth !== 'number') {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n    limitTreeDepth = Math.floor(depth);\n    if (limitTreeDepth <= 0) {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n  };\n  // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n  // The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // hits - maximum number of node hits or parser unit steps allowed.\n  // An exception thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxNodeHits = function (hits) {\n    if (typeof hits !== 'number') {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n    limitNodeHits = Math.floor(hits);\n    if (limitNodeHits <= 0) {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n  };\n  /* the main parser function */\n  const privateParse = function (grammar, startRuleArg, callbackData) {\n    let success;\n    const functionName = `${thisFileName}parse(): `;\n    initializeGrammar(grammar);\n    const startRule = initializeStartRule(startRuleArg);\n    initializeCallbacks();\n    initializeTrace();\n    initializeStats();\n    initializeAst();\n    const sysData = new systemData();\n    if (!(callbackData === undefined || callbackData === null)) {\n      syntaxData = callbackData;\n    }\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startRule,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, charsBegin, sysData);\n    opcodes = null;\n    /* test and return the sysData */\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === charsLength) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      length: charsLength,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n      inputLength: chars.length,\n      subBegin: charsBegin,\n      subEnd: charsEnd,\n      subLength: charsLength,\n    };\n  };\n\n  // This form allows parsing of a sub-string of the full input string.\n  // <ul>\n  // <li>*inputIndex* - index of the first character in the sub-string</li>\n  // <li>*inputLength* - length of the sub-string</li>\n  // </ul>\n  // All other parameters as for the above function `parse()`.\n  this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n    clear();\n    initializeInputChars(inputChars, inputIndex, inputLength);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // This is the main function, called to parse an input string.\n  // <ul>\n  // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n  // specific SABNF grammar</li>\n  // <li>*startRule* - the rule name or rule index to be used as the root of the\n  // parse tree. This is usually the first rule, index = 0, of the grammar\n  // but can be any rule defined in the above grammar object.</li>\n  // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n  // string.</li>\n  // <li>*callbackData* - user-defined data object to be passed to the user's\n  // callback functions.\n  // This is not used by the parser in any way, merely passed on to the user.\n  // May be `null` or omitted.</li>\n  // </ul>\n  this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n    clear();\n    initializeInputChars(inputChars, 0, inputChars.length);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex, sysData);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex >= charsEnd) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = function (rule, sysData, charsLeft, down) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (down !== true) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  // See [`ast.js`](./ast.html) for usage.\n  const opRNM = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back references */\n      astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(op.index, rules[op.index].name);\n      }\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    if (callback === null) {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    } else {\n      /* call user's callback */\n      const charsLeft = charsEnd - phraseIndex;\n      sysData.ruleIndex = rule.index;\n      callback(sysData, chars, phraseIndex, syntaxData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex, sysData);\n        opcodes = savedOpcodes;\n        sysData.ruleIndex = rule.index;\n        callback(sysData, chars, phraseIndex, syntaxData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    }\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (rule.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = function (udt, sysData, charsLeft) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n      case id.EMPTY:\n        if (udt.empty === false) {\n          throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n        } else {\n          sysData.phraseLength = 0;\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty === false) {\n            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n          } else {\n            sysData.state = id.EMPTY;\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back reference */\n      astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(astIndex, udt.name);\n      }\n      /* NOTE: push and pop of the back reference frame is normally not necessary */\n      /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    /* call the UDT */\n    const charsLeft = charsEnd - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (udt.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < charsEnd) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `ABG` operator.<br>\n  // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n  const opABG = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n  };\n  // The `AEN` operator.<br>\n  // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n  const opAEN = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n  };\n  // The `BKR` operator.<br>\n  // The back reference operator.\n  // Matches the last matched phrase of the named rule or UDT against the input string.\n  // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n  // depending on the back reference definition.\n  // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n  // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n  const opBKR = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The `BKA` operator.<br>\n  // This is the positive `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKA = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opBKA: invalid state ${sysData.state}`);\n    }\n  };\n  // The `BKN` operator.<br>\n  // This is the negative `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKN = function (opIndex, phraseIndex, sysData) {\n    // let op;\n    // op = opcodes[opIndex];\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opBKN: invalid state ${sysData.state}`);\n    }\n  };\n  // The right-to-left `CAT` operator.<br>\n  // Called for `CAT` operators when in look behind mode.\n  // Calls its child nodes from right to left concatenating matched phrases right to left.\n  const opCATBehind = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catMatched;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catMatched = 0;\n    // catPhrase = 0;\n    for (let i = op.children.length - 1; i >= 0; i -= 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      catCharIndex -= sysData.phraseLength;\n      catMatched += sysData.phraseLength;\n      // catPhrase += sysData.phraseLength;\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      }\n    }\n    if (success) {\n      sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catMatched;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `REP` operator.<br>\n  // Called for `REP` operators in look behind mode.\n  // Makes repeated calls to its child node, concatenating matched phrases right to left.\n  const opREPBehind = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex <= 0) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex -= sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `TRG` operator.<br>\n  // Called for `TRG` operators in look behind mode.\n  // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n  const opTRGBehind = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (phraseIndex > 0) {\n      const char = chars[phraseIndex - 1];\n      if (op.min <= char && char <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The right-to-left `TBS` operator.<br>\n  // Called for `TBS` operators in look behind mode.\n  // Matches the `TBS` phrase to the left of `phraseIndex`.\n  const opTBSBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[beg + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left `TLS` operator.<br>\n  // Called for `TLS` operators in look behind mode.\n  // Matches the `TLS` phrase to the left of `phraseIndex`.\n  const opTLSBehind = function (opIndex, phraseIndex, sysData) {\n    let char;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (let i = 0; i < len; i += 1) {\n        char = chars[beg + i];\n        if (char >= 65 && char <= 90) {\n          char += 32;\n        }\n        if (char !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left back reference operator.<br>\n  // Matches the back referenced phrase to the left of `phraseIndex`.\n  const opBKRBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    /* NOMATCH default */\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // Generalized execution function.<br>\n  // Having a single, generalized function, allows a single location\n  // for tracing and statistics gathering functions to be called.\n  // Tracing and statistics are handled in separate objects.\n  // However, the parser calls their API to build the object data records.\n  // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n  // usage.\n  opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n    let ret = true;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (nodeHits > limitNodeHits) {\n      throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n    }\n    treeDepth += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n      if (maxTreeDepth > limitTreeDepth) {\n        throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n      }\n    }\n    sysData.refresh();\n    if (thisThis.trace !== null) {\n      /* collect the trace record for down the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    if (inLookBehind()) {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCATBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREPBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRGBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKRBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    } else {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCAT(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREP(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRG(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBS(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLS(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKR(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    }\n    if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n      maxMatched = phraseIndex + sysData.phraseLength;\n    }\n    if (thisThis.stats !== null) {\n      /* collect the statistics */\n      thisThis.stats.collect(op, sysData);\n    }\n    if (thisThis.trace !== null) {\n      /* collect the trace record for up the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    treeDepth -= 1;\n    return ret;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsNkVBQWU7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWE7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGNBQWMsV0FBVztBQUMvRDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBLHlCQUF5QixhQUFhLGFBQWEsVUFBVTtBQUM3RDtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsZ0JBQWdCLGFBQWE7QUFDbkU7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZUFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3BhcnNlci5qcz9hYTZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGZ1bmMtbmFtZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgaXMgdGhlIHByaW1hcnkgb2JqZWN0IG9mIGBhcGctbGliYC4gQ2FsbGluZyBpdHMgYHBhcnNlKClgIG1lbWJlciBmdW5jdGlvblxuLy8gd2Fsa3MgdGhlIHBhcnNlIHRyZWUgb2Ygb3Bjb2RlcywgbWF0Y2hpbmcgcGhyYXNlcyBmcm9tIHRoZSBpbnB1dCBzdHJpbmcgYXMgaXQgZ29lcy5cbi8vIFRoZSB3b3JraW5nIGNvZGUgZm9yIGFsbCBvZiB0aGUgb3BlcmF0b3JzLCBgQUxUYCwgYENBVGAsIGV0Yy4gaXMgaW4gdGhpcyBtb2R1bGUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlcigpIHtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG4gIGNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAncGFyc2VyLmpzOiAnO1xuICBjb25zdCB0aGlzVGhpcyA9IHRoaXM7XG4gIGxldCBvcEV4ZWN1dGU7XG4gIHRoaXMuYXN0ID0gbnVsbDtcbiAgdGhpcy5zdGF0cyA9IG51bGw7XG4gIHRoaXMudHJhY2UgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICBsZXQgb3Bjb2RlcyA9IG51bGw7XG4gIGxldCBjaGFycyA9IG51bGw7XG4gIGxldCBjaGFyc0JlZ2luO1xuICBsZXQgY2hhcnNMZW5ndGg7XG4gIGxldCBjaGFyc0VuZDtcbiAgbGV0IGxvb2tBcm91bmQ7XG4gIGxldCB0cmVlRGVwdGggPSAwO1xuICBsZXQgbWF4VHJlZURlcHRoID0gMDtcbiAgbGV0IG5vZGVIaXRzID0gMDtcbiAgbGV0IHJ1bGVDYWxsYmFja3MgPSBudWxsO1xuICBsZXQgdWR0Q2FsbGJhY2tzID0gbnVsbDtcbiAgbGV0IHJ1bGVzID0gbnVsbDtcbiAgbGV0IHVkdHMgPSBudWxsO1xuICBsZXQgc3ludGF4RGF0YSA9IG51bGw7XG4gIGxldCBtYXhNYXRjaGVkID0gMDtcbiAgbGV0IGxpbWl0VHJlZURlcHRoID0gSW5maW5pdHk7XG4gIGxldCBsaW1pdE5vZGVIaXRzID0gSW5maW5pdHk7XG4gIC8vIEV2YWx1YXRlcyBhbnkgZ2l2ZW4gcnVsZS4gVGhpcyBjYW4gYmUgY2FsbGVkIGZyb20gdGhlIHN5bnRheCBjYWxsYmFja1xuICAvLyBmdW5jdGlvbnMgdG8gZXZhbHVhdGUgYW55IHJ1bGUgaW4gdGhlIGdyYW1tYXIncyBydWxlIGxpc3QuIEdyZWF0IGNhdXRpb25cbiAgLy8gc2hvdWxkIGJlIHVzZWQuIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIHdpbGwgYWx0ZXIgdGhlIGxhbmd1YWdlIHRoYXQgdGhlXG4gIC8vIHBhcnNlciBhY2NlcHRzLlxuICBjb25zdCBldmFsdWF0ZVJ1bGUgPSBmdW5jdGlvbiBldmFsdWF0ZVJ1bGUocnVsZUluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1ldmFsdWF0ZVJ1bGUoKTogYDtcbiAgICBpZiAocnVsZUluZGV4ID49IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1ydWxlIGluZGV4OiAke3J1bGVJbmRleH0gb3V0IG9mIHJhbmdlYCk7XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCA+PSBjaGFyc0VuZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1waHJhc2UgaW5kZXg6ICR7cGhyYXNlSW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gb3Bjb2RlcztcbiAgICBvcGNvZGVzLnB1c2goe1xuICAgICAgdHlwZTogaWQuUk5NLFxuICAgICAgaW5kZXg6IHJ1bGVJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUobGVuZ3RoLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgb3Bjb2Rlcy5wb3AoKTtcbiAgfTtcbiAgLy8gRXZhbHVhdGVzIGFueSBnaXZlbiBVRFQuIFRoaXMgY2FuIGJlIGNhbGxlZCBmcm9tIHRoZSBzeW50YXggY2FsbGJhY2tcbiAgLy8gZnVuY3Rpb25zIHRvIGV2YWx1YXRlIGFueSBVRFQgaW4gdGhlIGdyYW1tYXIncyBVRFQgbGlzdC4gR3JlYXQgY2F1dGlvblxuICAvLyBzaG91bGQgYmUgdXNlZC4gVXNlIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBhbHRlciB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGVcbiAgLy8gcGFyc2VyIGFjY2VwdHMuXG4gIGNvbnN0IGV2YWx1YXRlVWR0ID0gZnVuY3Rpb24gKHVkdEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1ldmFsdWF0ZVVkdCgpOiBgO1xuICAgIGlmICh1ZHRJbmRleCA+PSB1ZHRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX11ZHQgaW5kZXg6ICR7dWR0SW5kZXh9IG91dCBvZiByYW5nZWApO1xuICAgIH1cbiAgICBpZiAocGhyYXNlSW5kZXggPj0gY2hhcnNFbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9cGhyYXNlIGluZGV4OiAke3BocmFzZUluZGV4fSBvdXQgb2YgcmFuZ2VgKTtcbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG9wY29kZXM7XG4gICAgb3Bjb2Rlcy5wdXNoKHtcbiAgICAgIHR5cGU6IGlkLlVEVCxcbiAgICAgIGVtcHR5OiB1ZHRzW3VkdEluZGV4XS5lbXB0eSxcbiAgICAgIGluZGV4OiB1ZHRJbmRleCxcbiAgICB9KTtcbiAgICBvcEV4ZWN1dGUobGVuZ3RoLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgb3Bjb2Rlcy5wb3AoKTtcbiAgfTtcbiAgLyogQ2xlYXJzIHRoaXMgb2JqZWN0IG9mIGFueS9hbGwgZGF0YSB0aGF0IGhhcyBiZWVuIGluaXRpYWxpemVkIG9yIGFkZGVkIHRvIGl0LiAqL1xuICAvKiBDYWxsZWQgYnkgcGFyc2UoKSBvbiBpbml0aWFsaXphdGlvbiwgYWxsb3dpbmcgdGhpcyBvYmplY3QgdG8gYmUgcmUtdXNlZCBmb3IgbXVsdGlwbGUgcGFyc2luZyBjYWxscy4gKi9cbiAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJlZURlcHRoID0gMDtcbiAgICBtYXhUcmVlRGVwdGggPSAwO1xuICAgIG5vZGVIaXRzID0gMDtcbiAgICBtYXhNYXRjaGVkID0gMDtcbiAgICBsb29rQXJvdW5kID0gW1xuICAgICAge1xuICAgICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX05PTkUsXG4gICAgICAgIGFuY2hvcjogMCxcbiAgICAgICAgY2hhcnNFbmQ6IDAsXG4gICAgICAgIGNoYXJzTGVuZ3RoOiAwLFxuICAgICAgfSxcbiAgICBdO1xuICAgIHJ1bGVzID0gbnVsbDtcbiAgICB1ZHRzID0gbnVsbDtcbiAgICBjaGFycyA9IG51bGw7XG4gICAgY2hhcnNCZWdpbiA9IDA7XG4gICAgY2hhcnNMZW5ndGggPSAwO1xuICAgIGNoYXJzRW5kID0gMDtcbiAgICBydWxlQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB1ZHRDYWxsYmFja3MgPSBudWxsO1xuICAgIHN5bnRheERhdGEgPSBudWxsO1xuICAgIG9wY29kZXMgPSBudWxsO1xuICB9O1xuICAvKiBvYmplY3QgZm9yIG1haW50YWluaW5nIGEgc3RhY2sgb2YgYmFjayByZWZlcmVuY2UgZnJhbWVzICovXG4gIGNvbnN0IGJhY2tSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBjb25zdCBpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICBydWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gICAgICAgIGlmIChydWxlLmlzQmtyKSB7XG4gICAgICAgICAgb2JqW3J1bGUubG93ZXJdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVkdHMuZm9yRWFjaCgodWR0KSA9PiB7XG4gICAgICAgICAgaWYgKHVkdC5pc0Jrcikge1xuICAgICAgICAgICAgb2JqW3VkdC5sb3dlcl0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgfTtcbiAgICBjb25zdCBjb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgdG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRvcCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB0b3BbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgIHN0YWNrLnB1c2goY29weSgpKTtcbiAgICB9O1xuICAgIHRoaXMucG9wID0gZnVuY3Rpb24gcG9wKGxlbmd0aEFyZykge1xuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aEFyZztcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoIDwgMSB8fCBsZW5ndGggPiBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1iYWNrUmVmLnBvcCgpOiBiYWQgbGVuZ3RoOiAke2xlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIHRoaXMubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcbiAgICB9O1xuICAgIHRoaXMuc2F2ZVBocmFzZSA9IGZ1bmN0aW9uIHNhdmVQaHJhc2UobmFtZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1bbmFtZV0gPSB7XG4gICAgICAgIHBocmFzZUluZGV4OiBpbmRleCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhpcy5nZXRQaHJhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdW25hbWVdO1xuICAgIH07XG4gICAgLyogY29uc3RydWN0b3IgKi9cbiAgICBpbml0KCk7XG4gIH07XG4gIC8vIFRoZSBzeXN0ZW0gZGF0YSBzdHJ1Y3R1cmUgdGhhdCByZWxheXMgc3lzdGVtIGluZm9ybWF0aW9uIHRvIGFuZCBmcm9tIHRoZSBydWxlIGFuZCBVRFQgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICAvLyAtICpzdGF0ZSogLSB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlciwgQUNUSVZFLCBNQVRDSCwgRU1QVFkgb3IgTk9NQVRDSCAoc2VlIHRoZSBgaWRlbnRpZmllcnNgIG9iamVjdCBpblxuICAvLyBbYGFwZy1saWJgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzMi1saWIpKVxuICAvLyAtICpwaHJhc2VMZW5ndGgqIC0gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1hdGNoZWQgaWYgdGhlIHN0YXRlIGlzIE1BVENIRUQgb3IgRU1QVFlcbiAgLy8gLSAqbG9va2Fyb3VuZCogLSB0aGUgdG9wIG9mIHRoZSBzdGFjayBob2xkcyB0aGUgY3VycmVudCBsb29rIGFyb3VuZCBzdGF0ZSxcbiAgLy8gTE9PS0FST1VORF9OT05FLCBMT09LQVJPVU5EX0FIRUFEIG9yIExPT0tBUk9VTkRfQkVISU5ELFxuICAvLyAtICp1RnJhbWUqIC0gdGhlIFwidW5pdmVyc2FsXCIgYmFjayByZWZlcmVuY2UgZnJhbWUuXG4gIC8vIEhvbGRzIHRoZSBsYXN0IG1hdGNoZWQgcGhyYXNlIGZvciBlYWNoIG9mIHRoZSBiYWNrIHJlZmVyZW5jZWQgcnVsZXMgYW5kIFVEVHMuXG4gIC8vIC0gKnBGcmFtZSogLSB0aGUgc3RhY2sgb2YgXCJwYXJlbnRcIiBiYWNrIHJlZmVyZW5jZSBmcmFtZXMuXG4gIC8vIEhvbGRzIHRoZSBtYXRjaGVkIHBocmFzZSBmcm9tIHRoZSBwYXJlbnQgZnJhbWUgb2YgZWFjaCBiYWNrIHJlZmVyZW5jZWQgcnVsZXMgYW5kIFVEVHMuXG4gIC8vIC0gKmV2YWx1YXRlUnVsZSogLSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCdzIGBldmFsdWF0ZVJ1bGUoKWAgZnVuY3Rpb24uXG4gIC8vIENhbiBiZSBjYWxsZWQgZnJvbSBhIGNhbGxiYWNrIGZ1bmN0aW9uICh1c2Ugd2l0aCBleHRyZW1lIGNhdXRpb24hKVxuICAvLyAtICpldmFsdWF0ZVVkdCogLSBhIHJlZmVyZW5jZSB0byB0aGlzIG9iamVjdCdzIGBldmFsdWF0ZVVkdCgpYCBmdW5jdGlvbi5cbiAgLy8gQ2FuIGJlIGNhbGxlZCBmcm9tIGEgY2FsbGJhY2sgZnVuY3Rpb24gKHVzZSB3aXRoIGV4dHJlbWUgY2F1dGlvbiEpXG4gIGNvbnN0IHN5c3RlbURhdGEgPSBmdW5jdGlvbiBzeXN0ZW1EYXRhKCkge1xuICAgIGNvbnN0IHRoaXNEYXRhID0gdGhpcztcbiAgICB0aGlzLnN0YXRlID0gaWQuQUNUSVZFO1xuICAgIHRoaXMucGhyYXNlTGVuZ3RoID0gMDtcbiAgICB0aGlzLnJ1bGVJbmRleCA9IDA7XG4gICAgdGhpcy51ZHRJbmRleCA9IDA7XG4gICAgdGhpcy5sb29rQXJvdW5kID0gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMudUZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB0aGlzLnBGcmFtZSA9IG5ldyBiYWNrUmVmKCk7XG4gICAgdGhpcy5ldmFsdWF0ZVJ1bGUgPSBldmFsdWF0ZVJ1bGU7XG4gICAgdGhpcy5ldmFsdWF0ZVVkdCA9IGV2YWx1YXRlVWR0O1xuICAgIC8qIHJlZnJlc2ggdGhlIHBhcnNlciBzdGF0ZSBmb3IgdGhlIG5leHQgb3BlcmF0aW9uICovXG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHRoaXNEYXRhLnN0YXRlID0gaWQuQUNUSVZFO1xuICAgICAgdGhpc0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHRoaXNEYXRhLmxvb2tBcm91bmQgPSBsb29rQXJvdW5kW2xvb2tBcm91bmQubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgfTtcbiAgLyogc29tZSBsb29rIGFyb3VuZCBoZWxwZXIgZnVuY3Rpb25zICovXG4gIGNvbnN0IGxvb2tBcm91bmRWYWx1ZSA9IGZ1bmN0aW9uIGxvb2tBcm91bmRWYWx1ZSgpIHtcbiAgICByZXR1cm4gbG9va0Fyb3VuZFtsb29rQXJvdW5kLmxlbmd0aCAtIDFdO1xuICB9O1xuICAvKiByZXR1cm4gdHJ1ZSBpZiBwYXJzZXIgaXMgaW4gbG9vayBhcm91bmQgKGFoZWFkIG9yIGJlaGluZCkgc3RhdGUgKi9cbiAgY29uc3QgaW5Mb29rQXJvdW5kID0gZnVuY3Rpb24gaW5Mb29rQXJvdW5kKCkge1xuICAgIHJldHVybiBsb29rQXJvdW5kLmxlbmd0aCA+IDE7XG4gIH07XG4gIC8qIHJldHVybiB0cnVlIGlmIHBhcnNlciBpcyBpbiBsb29rIGJlaGluZCBzdGF0ZSAqL1xuICBjb25zdCBpbkxvb2tCZWhpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvb2tBcm91bmRbbG9va0Fyb3VuZC5sZW5ndGggLSAxXS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0JFSElORDtcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgQVNUIG9iamVjdCwgaWYgb25lIGhhcyBiZWVuIGRlZmluZWQgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUFzdCgpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0ID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMuYXN0ID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLmFzdC5hc3RPYmplY3QgIT09ICdhc3RPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9YXN0IG9iamVjdCBub3QgcmVjb2duaXplZGApO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzVGhpcy5hc3QgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLmFzdC5pbml0KHJ1bGVzLCB1ZHRzLCBjaGFycyk7XG4gICAgfVxuICB9O1xuICAvKiBjYWxsZWQgYnkgcGFyc2UoKSB0byBpbml0aWFsaXplIHRoZSB0cmFjZSBvYmplY3QsIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkICovXG4gIGNvbnN0IGluaXRpYWxpemVUcmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZVRyYWNlKCk6IGA7XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmICh0aGlzVGhpcy50cmFjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNUaGlzLnRyYWNlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpc1RoaXMudHJhY2UudHJhY2VPYmplY3QgIT09ICd0cmFjZU9iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX10cmFjZSBvYmplY3Qgbm90IHJlY29nbml6ZWRgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIHRoaXNUaGlzLnRyYWNlLmluaXQocnVsZXMsIHVkdHMsIGNoYXJzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHN0YXRpc3RpY3Mgb2JqZWN0LCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZCAqL1xuICBjb25zdCBpbml0aWFsaXplU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVTdGF0cygpOiBgO1xuICAgIGNvbnN0IFRSVUUgPSB0cnVlO1xuICAgIHdoaWxlIChUUlVFKSB7XG4gICAgICBpZiAodGhpc1RoaXMuc3RhdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzVGhpcy5zdGF0cyA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNUaGlzLnN0YXRzLnN0YXRzT2JqZWN0ICE9PSAnc3RhdHNPYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhdHMgb2JqZWN0IG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXNUaGlzLnN0YXRzICE9PSBudWxsKSB7XG4gICAgICB0aGlzVGhpcy5zdGF0cy5pbml0KHJ1bGVzLCB1ZHRzKTtcbiAgICB9XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHJ1bGVzICYgdWR0cyBmcm9tIHRoZSBncmFtbWFyIG9iamVjdCAqL1xuICAvKiAodGhlIGdyYW1tYXIgb2JqZWN0IGdlbmVyYXRlZCBwcmV2aW91c2x5IGJ5IGFwZykgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUdyYW1tYXIgPSBmdW5jdGlvbiAoZ3JhbW1hcikge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplR3JhbW1hcigpOiBgO1xuICAgIGlmICghZ3JhbW1hcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1ncmFtbWFyIG9iamVjdCB1bmRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKGdyYW1tYXIuZ3JhbW1hck9iamVjdCAhPT0gJ2dyYW1tYXJPYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWJhZCBncmFtbWFyIG9iamVjdGApO1xuICAgIH1cbiAgICBydWxlcyA9IGdyYW1tYXIucnVsZXM7XG4gICAgdWR0cyA9IGdyYW1tYXIudWR0cztcbiAgfTtcbiAgLyogY2FsbGVkIGJ5IHBhcnNlKCkgdG8gaW5pdGlhbGl6ZSB0aGUgc3RhcnQgcnVsZSAqL1xuICBjb25zdCBpbml0aWFsaXplU3RhcnRSdWxlID0gZnVuY3Rpb24gKHN0YXJ0UnVsZSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1pbml0aWFsaXplU3RhcnRSdWxlKCk6IGA7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHN0YXJ0UnVsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChzdGFydFJ1bGUgPj0gcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhcnQgcnVsZSBpbmRleCB0b28gbGFyZ2U6IG1heDogJHtydWxlcy5sZW5ndGh9OiBpbmRleDogJHtzdGFydFJ1bGV9YCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0UnVsZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFydFJ1bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb3dlciA9IHN0YXJ0UnVsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAobG93ZXIgPT09IHJ1bGVzW2ldLmxvd2VyKSB7XG4gICAgICAgICAgc3RhcnQgPSBydWxlc1tpXS5pbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3RhcnQgcnVsZSBuYW1lICcke3N0YXJ0UnVsZX0nIG5vdCByZWNvZ25pemVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9dHlwZSBvZiBzdGFydCBydWxlICcke3R5cGVvZiBzdGFydFJ1bGV9JyBub3QgcmVjb2duaXplZGApO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnQ7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIGFycmF5IG9mIGNoYXJhY3RlcnMgY29kZXMgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBzdHJpbmcgKi9cbiAgY29uc3QgaW5pdGlhbGl6ZUlucHV0Q2hhcnMgPSBmdW5jdGlvbiBpbml0aWFsaXplSW5wdXRDaGFycyhpbnB1dEFyZywgYmVnQXJnLCBsZW5BcmcpIHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBgJHt0aGlzRmlsZU5hbWV9aW5pdGlhbGl6ZUlucHV0Q2hhcnMoKTogYDtcbiAgICAvKiB2YXJpZnkgYW5kIG5vcm1hbGl6ZSBpbnB1dCAqL1xuICAgIGxldCBpbnB1dCA9IGlucHV0QXJnO1xuICAgIGxldCBiZWcgPSBiZWdBcmc7XG4gICAgbGV0IGxlbiA9IGxlbkFyZztcbiAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgbnVsbGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQgPSB1dGlscy5zdHJpbmdUb0NoYXJzKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBzdHJpbmcgaXMgbm90IGEgc3RyaW5nIG9yIGFycmF5YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0WzBdICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IHN0cmluZyBub3QgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogdmVyaWZ5IGFuZCBub3JtYWxpemUgYmVnaW5uaW5nIGluZGV4ICovXG4gICAgaWYgKHR5cGVvZiBiZWcgIT09ICdudW1iZXInKSB7XG4gICAgICBiZWcgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBiZWcgPSBNYXRoLmZsb29yKGJlZyk7XG4gICAgICBpZiAoYmVnIDwgMCB8fCBiZWcgPiBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Z1bmN0aW9uTmFtZX1pbnB1dCBiZWdpbm5pbmcgaW5kZXggb3V0IG9mIHJhbmdlOiAke2JlZ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogdmVyaWZ5IGFuZCBub3JtYWxpemUgaW5wdXQgbGVuZ3RoICovXG4gICAgaWYgKHR5cGVvZiBsZW4gIT09ICdudW1iZXInKSB7XG4gICAgICBsZW4gPSBpbnB1dC5sZW5ndGggLSBiZWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbiA9IE1hdGguZmxvb3IobGVuKTtcbiAgICAgIGlmIChsZW4gPCAwIHx8IGxlbiA+IGlucHV0Lmxlbmd0aCAtIGJlZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWlucHV0IGxlbmd0aCBvdXQgb2YgcmFuZ2U6ICR7bGVufWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGFycyA9IGlucHV0O1xuICAgIGNoYXJzQmVnaW4gPSBiZWc7XG4gICAgY2hhcnNMZW5ndGggPSBsZW47XG4gICAgY2hhcnNFbmQgPSBjaGFyc0JlZ2luICsgY2hhcnNMZW5ndGg7XG4gIH07XG4gIC8qIGNhbGxlZCBieSBwYXJzZSgpIHRvIGluaXRpYWxpemUgdGhlIHVzZXItd3JpdHRlbiwgc3ludGF4IGNhbGxiYWNrIGZ1bmN0aW9ucywgaWYgYW55ICovXG4gIGNvbnN0IGluaXRpYWxpemVDYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gYCR7dGhpc0ZpbGVOYW1lfWluaXRpYWxpemVDYWxsYmFja3MoKTogYDtcbiAgICBsZXQgaTtcbiAgICBydWxlQ2FsbGJhY2tzID0gW107XG4gICAgdWR0Q2FsbGJhY2tzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBydWxlQ2FsbGJhY2tzW2ldID0gbnVsbDtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHVkdENhbGxiYWNrc1tpXSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBmdW5jO1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaChydWxlc1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2godWR0c1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpc1RoaXMuY2FsbGJhY2tzKSB7XG4gICAgICBpID0gbGlzdC5pbmRleE9mKGluZGV4LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtmdW5jdGlvbk5hbWV9c3ludGF4IGNhbGxiYWNrICcke2luZGV4fScgbm90IGEgcnVsZSBvciB1ZHQgbmFtZWApO1xuICAgICAgfVxuICAgICAgZnVuYyA9IHRoaXNUaGlzLmNhbGxiYWNrc1tpbmRleF07XG4gICAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgfHwgZnVuYyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoaSA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJ1bGVDYWxsYmFja3NbaV0gPSBmdW5jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVkdENhbGxiYWNrc1tpIC0gcnVsZXMubGVuZ3RoXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtmdW5jdGlvbk5hbWV9c3ludGF4IGNhbGxiYWNrWyR7aW5kZXh9XSBtdXN0IGJlIGZ1bmN0aW9uIHJlZmVyZW5jZSBvciAnZmFsc2UnIChmYWxzZS9udWxsL3VuZGVmaW5lZC9ldGMuKWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogbWFrZSBzdXJlIGFsbCB1ZHRzIGhhdmUgYmVlbiBkZWZpbmVkIC0gdGhlIHBhcnNlciBjYW4ndCB3b3JrIHdpdGhvdXQgdGhlbSAqL1xuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodWR0Q2FsbGJhY2tzW2ldID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgJHtmdW5jdGlvbk5hbWV9YWxsIFVEVCBjYWxsYmFja3MgbXVzdCBiZSBkZWZpbmVkLiBVRFQgY2FsbGJhY2tbJHt1ZHRzW2ldLmxvd2VyfV0gbm90IGEgZnVuY3Rpb24gcmVmZXJlbmNlYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gU2V0IHRoZSBtYXhpbXVtIHBhcnNlIHRyZWUgZGVwdGggYWxsb3dlZC4gVGhlIGRlZmF1bHQgaXMgYEluZmluaXR5YC5cbiAgLy8gQSBsaW1pdCBpcyBub3Qgbm9ybWFsbHkgbmVlZGVkLCBidXQgY2FuIGJlIHVzZWQgdG8gcHJvdGVjdCBhZ2FpbnN0IGFuXG4gIC8vIGV4cG9uZW50dWFsIG9yIFwiY2F0YXN0cm9waGljYWxseSBiYWNrdHJhY2tpbmdcIiBncmFtbWFyLlxuICAvLyA8dWw+XG4gIC8vIDxsaT5cbiAgLy8gZGVwdGggLSBtYXggYWxsb3dlZCBwYXJzZSB0cmVlIGRlcHRoLiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGV4Y2VlZGVkLlxuICAvLyA8L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnNldE1heFRyZWVEZXB0aCA9IGZ1bmN0aW9uIChkZXB0aCkge1xuICAgIGlmICh0eXBlb2YgZGVwdGggIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4IHRyZWUgZGVwdGggbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtkZXB0aH1gKTtcbiAgICB9XG4gICAgbGltaXRUcmVlRGVwdGggPSBNYXRoLmZsb29yKGRlcHRoKTtcbiAgICBpZiAobGltaXRUcmVlRGVwdGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCB0cmVlIGRlcHRoIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7ZGVwdGh9YCk7XG4gICAgfVxuICB9O1xuICAvLyBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGUgaGl0cyAocGFyc2VyIHVuaXQgc3RlcHMgb3Igb3Bjb2RlIGZ1bmN0aW9uIGNhbGxzKSBhbGxvd2VkLlxuICAvLyBUaGUgZGVmYXVsdCBpcyBgSW5maW5pdHlgLlxuICAvLyBBIGxpbWl0IGlzIG5vdCBub3JtYWxseSBuZWVkZWQsIGJ1dCBjYW4gYmUgdXNlZCB0byBwcm90ZWN0IGFnYWluc3QgYW5cbiAgLy8gZXhwb25lbnR1YWwgb3IgXCJjYXRhc3Ryb3BoaWNhbGx5IGJhY2t0cmFja2luZ1wiIGdyYW1tYXIuXG4gIC8vIDx1bD5cbiAgLy8gPGxpPlxuICAvLyBoaXRzIC0gbWF4aW11bSBudW1iZXIgb2Ygbm9kZSBoaXRzIG9yIHBhcnNlciB1bml0IHN0ZXBzIGFsbG93ZWQuXG4gIC8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gaWYgZXhjZWVkZWQuXG4gIC8vIDwvbGk+XG4gIC8vIDwvdWw+XG4gIHRoaXMuc2V0TWF4Tm9kZUhpdHMgPSBmdW5jdGlvbiAoaGl0cykge1xuICAgIGlmICh0eXBlb2YgaGl0cyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VyOiBtYXggbm9kZSBoaXRzIG11c3QgYmUgaW50ZWdlciA+IDA6ICR7aGl0c31gKTtcbiAgICB9XG4gICAgbGltaXROb2RlSGl0cyA9IE1hdGguZmxvb3IoaGl0cyk7XG4gICAgaWYgKGxpbWl0Tm9kZUhpdHMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZXI6IG1heCBub2RlIGhpdHMgbXVzdCBiZSBpbnRlZ2VyID4gMDogJHtoaXRzfWApO1xuICAgIH1cbiAgfTtcbiAgLyogdGhlIG1haW4gcGFyc2VyIGZ1bmN0aW9uICovXG4gIGNvbnN0IHByaXZhdGVQYXJzZSA9IGZ1bmN0aW9uIChncmFtbWFyLCBzdGFydFJ1bGVBcmcsIGNhbGxiYWNrRGF0YSkge1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IGAke3RoaXNGaWxlTmFtZX1wYXJzZSgpOiBgO1xuICAgIGluaXRpYWxpemVHcmFtbWFyKGdyYW1tYXIpO1xuICAgIGNvbnN0IHN0YXJ0UnVsZSA9IGluaXRpYWxpemVTdGFydFJ1bGUoc3RhcnRSdWxlQXJnKTtcbiAgICBpbml0aWFsaXplQ2FsbGJhY2tzKCk7XG4gICAgaW5pdGlhbGl6ZVRyYWNlKCk7XG4gICAgaW5pdGlhbGl6ZVN0YXRzKCk7XG4gICAgaW5pdGlhbGl6ZUFzdCgpO1xuICAgIGNvbnN0IHN5c0RhdGEgPSBuZXcgc3lzdGVtRGF0YSgpO1xuICAgIGlmICghKGNhbGxiYWNrRGF0YSA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrRGF0YSA9PT0gbnVsbCkpIHtcbiAgICAgIHN5bnRheERhdGEgPSBjYWxsYmFja0RhdGE7XG4gICAgfVxuICAgIC8qIGNyZWF0ZSBhIGR1bW15IG9wY29kZSBmb3IgdGhlIHN0YXJ0IHJ1bGUgKi9cbiAgICBvcGNvZGVzID0gW1xuICAgICAge1xuICAgICAgICB0eXBlOiBpZC5STk0sXG4gICAgICAgIGluZGV4OiBzdGFydFJ1bGUsXG4gICAgICB9LFxuICAgIF07XG4gICAgLyogZXhlY3V0ZSB0aGUgc3RhcnQgcnVsZSAqL1xuICAgIG9wRXhlY3V0ZSgwLCBjaGFyc0JlZ2luLCBzeXNEYXRhKTtcbiAgICBvcGNvZGVzID0gbnVsbDtcbiAgICAvKiB0ZXN0IGFuZCByZXR1cm4gdGhlIHN5c0RhdGEgKi9cbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuQUNUSVZFOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZnVuY3Rpb25OYW1lfWZpbmFsIHN0YXRlIHNob3VsZCBuZXZlciBiZSAnQUNUSVZFJ2ApO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICAgIGlmIChzeXNEYXRhLnBocmFzZUxlbmd0aCA9PT0gY2hhcnNMZW5ndGgpIHtcbiAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzcyxcbiAgICAgIHN0YXRlOiBzeXNEYXRhLnN0YXRlLFxuICAgICAgbGVuZ3RoOiBjaGFyc0xlbmd0aCxcbiAgICAgIG1hdGNoZWQ6IHN5c0RhdGEucGhyYXNlTGVuZ3RoLFxuICAgICAgbWF4TWF0Y2hlZCxcbiAgICAgIG1heFRyZWVEZXB0aCxcbiAgICAgIG5vZGVIaXRzLFxuICAgICAgaW5wdXRMZW5ndGg6IGNoYXJzLmxlbmd0aCxcbiAgICAgIHN1YkJlZ2luOiBjaGFyc0JlZ2luLFxuICAgICAgc3ViRW5kOiBjaGFyc0VuZCxcbiAgICAgIHN1Ykxlbmd0aDogY2hhcnNMZW5ndGgsXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGZvcm0gYWxsb3dzIHBhcnNpbmcgb2YgYSBzdWItc3RyaW5nIG9mIHRoZSBmdWxsIGlucHV0IHN0cmluZy5cbiAgLy8gPHVsPlxuICAvLyA8bGk+KmlucHV0SW5kZXgqIC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3ViLXN0cmluZzwvbGk+XG4gIC8vIDxsaT4qaW5wdXRMZW5ndGgqIC0gbGVuZ3RoIG9mIHRoZSBzdWItc3RyaW5nPC9saT5cbiAgLy8gPC91bD5cbiAgLy8gQWxsIG90aGVyIHBhcmFtZXRlcnMgYXMgZm9yIHRoZSBhYm92ZSBmdW5jdGlvbiBgcGFyc2UoKWAuXG4gIHRoaXMucGFyc2VTdWJzdHJpbmcgPSBmdW5jdGlvbiBwYXJzZVN1YnN0cmluZyhncmFtbWFyLCBzdGFydFJ1bGUsIGlucHV0Q2hhcnMsIGlucHV0SW5kZXgsIGlucHV0TGVuZ3RoLCBjYWxsYmFja0RhdGEpIHtcbiAgICBjbGVhcigpO1xuICAgIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0Q2hhcnMsIGlucHV0SW5kZXgsIGlucHV0TGVuZ3RoKTtcbiAgICByZXR1cm4gcHJpdmF0ZVBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgY2FsbGJhY2tEYXRhKTtcbiAgfTtcbiAgLy8gVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiwgY2FsbGVkIHRvIHBhcnNlIGFuIGlucHV0IHN0cmluZy5cbiAgLy8gPHVsPlxuICAvLyA8bGk+KmdyYW1tYXIqIC0gYW4gaW5zdGFudGlhdGVkIGdyYW1tYXIgb2JqZWN0IC0gdGhlIG91dHB1dCBvZiBgYXBnYCBmb3IgYVxuICAvLyBzcGVjaWZpYyBTQUJORiBncmFtbWFyPC9saT5cbiAgLy8gPGxpPipzdGFydFJ1bGUqIC0gdGhlIHJ1bGUgbmFtZSBvciBydWxlIGluZGV4IHRvIGJlIHVzZWQgYXMgdGhlIHJvb3Qgb2YgdGhlXG4gIC8vIHBhcnNlIHRyZWUuIFRoaXMgaXMgdXN1YWxseSB0aGUgZmlyc3QgcnVsZSwgaW5kZXggPSAwLCBvZiB0aGUgZ3JhbW1hclxuICAvLyBidXQgY2FuIGJlIGFueSBydWxlIGRlZmluZWQgaW4gdGhlIGFib3ZlIGdyYW1tYXIgb2JqZWN0LjwvbGk+XG4gIC8vIDxsaT4qaW5wdXRDaGFycyogLSB0aGUgaW5wdXQgc3RyaW5nLiBDYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgaW50ZWdlciBjaGFyYWN0ZXIgY29kZXMgcmVwcmVzZW50aW5nIHRoZVxuICAvLyBzdHJpbmcuPC9saT5cbiAgLy8gPGxpPipjYWxsYmFja0RhdGEqIC0gdXNlci1kZWZpbmVkIGRhdGEgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byB0aGUgdXNlcidzXG4gIC8vIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgLy8gVGhpcyBpcyBub3QgdXNlZCBieSB0aGUgcGFyc2VyIGluIGFueSB3YXksIG1lcmVseSBwYXNzZWQgb24gdG8gdGhlIHVzZXIuXG4gIC8vIE1heSBiZSBgbnVsbGAgb3Igb21pdHRlZC48L2xpPlxuICAvLyA8L3VsPlxuICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZ3JhbW1hciwgc3RhcnRSdWxlLCBpbnB1dENoYXJzLCBjYWxsYmFja0RhdGEpIHtcbiAgICBjbGVhcigpO1xuICAgIGluaXRpYWxpemVJbnB1dENoYXJzKGlucHV0Q2hhcnMsIDAsIGlucHV0Q2hhcnMubGVuZ3RoKTtcbiAgICByZXR1cm4gcHJpdmF0ZVBhcnNlKGdyYW1tYXIsIHN0YXJ0UnVsZSwgY2FsbGJhY2tEYXRhKTtcbiAgfTtcbiAgLy8gVGhlIGBBTFRgIG9wZXJhdG9yLjxicj5cbiAgLy8gRXhlY3V0ZXMgaXRzIGNoaWxkIG5vZGVzLCBmcm9tIGxlZnQgdG8gcmlnaHQsIHVudGlsIGl0IGZpbmRzIGEgbWF0Y2guXG4gIC8vIEZhaWxzIGlmICphbGwqIG9mIGl0cyBjaGlsZCBub2RlcyBmYWlsLlxuICBjb25zdCBvcEFMVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvcEV4ZWN1dGUob3AuY2hpbGRyZW5baV0sIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlICE9PSBpZC5OT01BVENIKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBDQVRgIG9wZXJhdG9yLjxicj5cbiAgLy8gRXhlY3V0ZXMgYWxsIG9mIGl0cyBjaGlsZCBub2RlcywgZnJvbSBsZWZ0IHRvIHJpZ2h0LFxuICAvLyBjb25jYXRlbmF0aW5nIHRoZSBtYXRjaGVkIHBocmFzZXMuXG4gIC8vIEZhaWxzIGlmICphbnkqIGNoaWxkIG5vZGVzIGZhaWwuXG4gIGNvbnN0IG9wQ0FUID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IHN1Y2Nlc3M7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgY2F0Q2hhckluZGV4O1xuICAgIGxldCBjYXRQaHJhc2U7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICBjb25zdCBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgIH1cbiAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICBjYXRDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICBjYXRQaHJhc2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3AuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9wRXhlY3V0ZShvcC5jaGlsZHJlbltpXSwgY2F0Q2hhckluZGV4LCBzeXNEYXRhKTtcbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXRDaGFySW5kZXggKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICAgIGNhdFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBjYXRQaHJhc2UgPT09IDAgPyBpZC5FTVBUWSA6IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBjYXRQaHJhc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgLyogcmVzZXQgdGhlIGJhY2sgcmVmZXJlbmNpbmcgZnJhbWVzIG9uIGZhaWx1cmUgKi9cbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIGBSRVBgIG9wZXJhdG9yLjxicj5cbiAgLy8gUmVwZWF0ZWRseSBleGVjdXRlcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUsXG4gIC8vIGNvbmNhdGVuYXRpbmcgZWFjaCBvZiB0aGUgbWF0Y2hlZCBwaHJhc2VzIGZvdW5kLlxuICAvLyBUaGUgbnVtYmVyIG9mIHJlcGV0aXRpb25zIGV4ZWN1dGVkIGFuZCBpdHMgZmluYWwgc3lzRGF0YSBkZXBlbmRzXG4gIC8vIG9uIGl0cyBgbWluYCAmIGBtYXhgIHJlcGV0aXRpb24gdmFsdWVzLlxuICBjb25zdCBvcFJFUCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IHJlcENoYXJJbmRleDtcbiAgICBsZXQgcmVwUGhyYXNlO1xuICAgIGxldCByZXBDb3VudDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgaWYgKG9wLm1heCA9PT0gMCkge1xuICAgICAgLy8gdGhpcyBpcyBhbiBlbXB0eS1zdHJpbmcgYWNjZXB0b3JcbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHVzZSB0aGUgVExTIGVtcHR5IHN0cmluZyBvcGVyYXRvciwgXCJcIiwgaW5zdGVhZFxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXBDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZXBQaHJhc2UgPSAwO1xuICAgIHJlcENvdW50ID0gMDtcbiAgICBjb25zdCB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgY29uc3QgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmIChyZXBDaGFySW5kZXggPj0gY2hhcnNFbmQpIHtcbiAgICAgICAgLyogZXhpdCBvbiBlbmQgb2YgaW5wdXQgc3RyaW5nICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCByZXBDaGFySW5kZXgsIHN5c0RhdGEpO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgLyogYWx3YXlzIGVuZCBpZiB0aGUgY2hpbGQgbm9kZSBmYWlscyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgICAvKiBSRVAgYWx3YXlzIHN1Y2NlZWRzIHdoZW4gdGhlIGNoaWxkIG5vZGUgcmV0dXJucyBhbiBlbXB0eSBwaHJhc2UgKi9cbiAgICAgICAgLyogdGhpcyBtYXkgbm90IHNlZW0gb2J2aW91cywgYnV0IHRoYXQncyB0aGUgd2F5IGl0IHdvcmtzIG91dCAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlcENvdW50ICs9IDE7XG4gICAgICByZXBQaHJhc2UgKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICByZXBDaGFySW5kZXggKz0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBpZiAocmVwQ291bnQgPT09IG9wLm1heCkge1xuICAgICAgICAvKiBlbmQgb24gbWF4ZWQgb3V0IHJlcHMgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGV2YWx1YXRlIHRoZSBtYXRjaCBjb3VudCBhY2NvcmRpbmcgdG8gdGhlIG1pbiwgbWF4IHZhbHVlcyAqL1xuICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2UgaWYgKHJlcENvdW50ID49IG9wLm1pbikge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IHJlcFBocmFzZSA9PT0gMCA/IGlkLkVNUFRZIDogaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IHJlcFBocmFzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAvKiByZXNldCB0aGUgYmFjayByZWZlcmVuY2luZyBmcmFtZXMgb24gZmFpbHVyZSAqL1xuICAgICAgc3lzRGF0YS51RnJhbWUucG9wKHVsZW4pO1xuICAgICAgc3lzRGF0YS5wRnJhbWUucG9wKHBsZW4pO1xuICAgICAgaWYgKHRoaXNUaGlzLmFzdCkge1xuICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBWYWxpZGF0ZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24ncyByZXR1cm5lZCBzeXNEYXRhIHZhbHVlcy5cbiAgLy8gSXQncyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGdldCB0aGVtIHJpZ2h0XG4gIC8vIGJ1dCBgUk5NYCBmYWlscyBpZiBub3QuXG4gIGNvbnN0IHZhbGlkYXRlUm5tQ2FsbGJhY2tSZXN1bHQgPSBmdW5jdGlvbiAocnVsZSwgc3lzRGF0YSwgY2hhcnNMZWZ0LCBkb3duKSB7XG4gICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID4gY2hhcnNMZWZ0KSB7XG4gICAgICBsZXQgc3RyID0gYCR7dGhpc0ZpbGVOYW1lfW9wUk5NKCR7cnVsZS5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIGVycm9yOiBgO1xuICAgICAgc3RyICs9IGBzeXNEYXRhLnBocmFzZUxlbmd0aDogJHtzeXNEYXRhLnBocmFzZUxlbmd0aH1gO1xuICAgICAgc3RyICs9IGAgbXVzdCBiZSA8PSByZW1haW5pbmcgY2hhcnM6ICR7Y2hhcnNMZWZ0fWA7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICB9XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgaWYgKGRvd24gIT09IHRydWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzRmlsZU5hbWV9b3BSTk0oJHtydWxlLm5hbWV9KTogY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJuIGVycm9yLiBBQ1RJVkUgc3RhdGUgbm90IGFsbG93ZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3RoaXNGaWxlTmFtZX1vcFJOTSgke3J1bGUubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIFVucmVjb2duaXplZCByZXR1cm4gc3RhdGU6ICR7c3lzRGF0YS5zdGF0ZX1gXG4gICAgICAgICk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFJOTWAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIG9wZXJhdG9yIHdpbGwgYWN0cyBhcyBhIHJvb3Qgbm9kZSBmb3IgYSBwYXJzZSB0cmVlIGJyYW5jaCBiZWxvdyBhbmRcbiAgLy8gcmV0dXJucyB0aGUgbWF0Y2hlZCBwaHJhc2UgdG8gaXRzIHBhcmVudC5cbiAgLy8gSG93ZXZlciwgaXRzIGxhcmdlciByZXNwb25zaWJpbGl0eSBpcyBoYW5kbGluZyB1c2VyLWRlZmluZWQgY2FsbGJhY2sgZnVuY3Rpb25zLCBiYWNrIHJlZmVyZW5jZXMgYW5kIGBBU1RgIG5vZGVzLlxuICAvLyBOb3RlIHRoYXQgdGhlIGBBU1RgIGlzIGEgc2VwYXJhdGUgb2JqZWN0LCBidXQgYFJOTWAgY2FsbHMgaXRzIGZ1bmN0aW9ucyB0byBjcmVhdGUgaXRzIG5vZGVzLlxuICAvLyBTZWUgW2Bhc3QuanNgXSguL2FzdC5odG1sKSBmb3IgdXNhZ2UuXG4gIGNvbnN0IG9wUk5NID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgYXN0RGVmaW5lZDtcbiAgICBsZXQgc2F2ZWRPcGNvZGVzO1xuICAgIGxldCB1bGVuO1xuICAgIGxldCBwbGVuO1xuICAgIGxldCBzYXZlRnJhbWU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tvcC5pbmRleF07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBydWxlQ2FsbGJhY2tzW3J1bGUuaW5kZXhdO1xuICAgIGNvbnN0IG5vdExvb2tBcm91bmQgPSAhaW5Mb29rQXJvdW5kKCk7XG4gICAgLyogaWdub3JlIEFTVCBhbmQgYmFjayByZWZlcmVuY2VzIGluIGxvb2thcm91bmQgKi9cbiAgICBpZiAobm90TG9va0Fyb3VuZCkge1xuICAgICAgLyogYmVnaW4gQVNUIGFuZCBiYWNrIHJlZmVyZW5jZXMgKi9cbiAgICAgIGFzdERlZmluZWQgPSB0aGlzVGhpcy5hc3QgJiYgdGhpc1RoaXMuYXN0LnJ1bGVEZWZpbmVkKG9wLmluZGV4KTtcbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICAgICAgdGhpc1RoaXMuYXN0LmRvd24ob3AuaW5kZXgsIHJ1bGVzW29wLmluZGV4XS5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHVsZW4gPSBzeXNEYXRhLnVGcmFtZS5sZW5ndGgoKTtcbiAgICAgIHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICAgIHN5c0RhdGEudUZyYW1lLnB1c2goKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnB1c2goKTtcbiAgICAgIHNhdmVGcmFtZSA9IHN5c0RhdGEucEZyYW1lO1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBuZXcgYmFja1JlZigpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8qIG5vIGNhbGxiYWNrIC0ganVzdCBleGVjdXRlIHRoZSBydWxlICovXG4gICAgICBzYXZlZE9wY29kZXMgPSBvcGNvZGVzO1xuICAgICAgb3Bjb2RlcyA9IHJ1bGUub3Bjb2RlcztcbiAgICAgIG9wRXhlY3V0ZSgwLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICBvcGNvZGVzID0gc2F2ZWRPcGNvZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBjYWxsIHVzZXIncyBjYWxsYmFjayAqL1xuICAgICAgY29uc3QgY2hhcnNMZWZ0ID0gY2hhcnNFbmQgLSBwaHJhc2VJbmRleDtcbiAgICAgIHN5c0RhdGEucnVsZUluZGV4ID0gcnVsZS5pbmRleDtcbiAgICAgIGNhbGxiYWNrKHN5c0RhdGEsIGNoYXJzLCBwaHJhc2VJbmRleCwgc3ludGF4RGF0YSk7XG4gICAgICB2YWxpZGF0ZVJubUNhbGxiYWNrUmVzdWx0KHJ1bGUsIHN5c0RhdGEsIGNoYXJzTGVmdCwgdHJ1ZSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuQUNUSVZFKSB7XG4gICAgICAgIHNhdmVkT3Bjb2RlcyA9IG9wY29kZXM7XG4gICAgICAgIG9wY29kZXMgPSBydWxlLm9wY29kZXM7XG4gICAgICAgIG9wRXhlY3V0ZSgwLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgIG9wY29kZXMgPSBzYXZlZE9wY29kZXM7XG4gICAgICAgIHN5c0RhdGEucnVsZUluZGV4ID0gcnVsZS5pbmRleDtcbiAgICAgICAgY2FsbGJhY2soc3lzRGF0YSwgY2hhcnMsIHBocmFzZUluZGV4LCBzeW50YXhEYXRhKTtcbiAgICAgICAgdmFsaWRhdGVSbm1DYWxsYmFja1Jlc3VsdChydWxlLCBzeXNEYXRhLCBjaGFyc0xlZnQsIGZhbHNlKTtcbiAgICAgIH0gLyogaW1wbGllZCBlbHNlIGNsYXVzZToganVzdCBhY2NlcHQgdGhlIGNhbGxiYWNrIHN5c0RhdGEgLSBSTk0gYWN0aW5nIGFzIFVEVCAqL1xuICAgIH1cbiAgICBpZiAobm90TG9va0Fyb3VuZCkge1xuICAgICAgLyogZW5kIEFTVCAqL1xuICAgICAgaWYgKGFzdERlZmluZWQpIHtcbiAgICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgICB0aGlzVGhpcy5hc3Quc2V0TGVuZ3RoKGFzdExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnVwKG9wLmluZGV4LCBydWxlLm5hbWUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGVuZCBiYWNrIHJlZmVyZW5jZSAqL1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBzYXZlRnJhbWU7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIH0gZWxzZSBpZiAocnVsZS5pc0Jrcikge1xuICAgICAgICAvKiBzYXZlIHBocmFzZSBvbiBib3RoIHRoZSBwYXJlbnQgYW5kIHVuaXZlcnNhbCBmcmFtZXMgKi9cbiAgICAgICAgLyogQktSIG9wZXJhdG9yIHdpbGwgZGVjaWRlIHdoaWNoIHRvIHVzZSBsYXRlciAqL1xuICAgICAgICBzeXNEYXRhLnBGcmFtZS5zYXZlUGhyYXNlKHJ1bGUubG93ZXIsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIHN5c0RhdGEudUZyYW1lLnNhdmVQaHJhc2UocnVsZS5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFZhbGlkYXRlIHRoZSBjYWxsYmFjayBmdW5jdGlvbidzIHJldHVybmVkIHN5c0RhdGEgdmFsdWVzLlxuICAvLyBJdCdzIHRoZSB1c2VyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZ2V0IGl0IHJpZ2h0IGJ1dCBgVURUYCBmYWlscyBpZiBub3QuXG4gIGNvbnN0IHZhbGlkYXRlVWR0Q2FsbGJhY2tSZXN1bHQgPSBmdW5jdGlvbiAodWR0LCBzeXNEYXRhLCBjaGFyc0xlZnQpIHtcbiAgICBpZiAoc3lzRGF0YS5waHJhc2VMZW5ndGggPiBjaGFyc0xlZnQpIHtcbiAgICAgIGxldCBzdHIgPSBgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiBlcnJvcjogYDtcbiAgICAgIHN0ciArPSBgc3lzRGF0YS5waHJhc2VMZW5ndGg6ICR7c3lzRGF0YS5waHJhc2VMZW5ndGh9YDtcbiAgICAgIHN0ciArPSBgIG11c3QgYmUgPD0gcmVtYWluaW5nIGNoYXJzOiAke2NoYXJzTGVmdH1gO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgfVxuICAgIHN3aXRjaCAoc3lzRGF0YS5zdGF0ZSkge1xuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIEFDVElWRSBzdGF0ZSBub3QgYWxsb3dlZC5gKTtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIGlmICh1ZHQuZW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gTWF5IG5vdCByZXR1cm4gRU1QVFkuYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgaWYgKHN5c0RhdGEucGhyYXNlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHVkdC5lbXB0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9b3BVRFQoJHt1ZHQubmFtZX0pOiBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm4gZXJyb3IuIE1heSBub3QgcmV0dXJuIEVNUFRZLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3RoaXNGaWxlTmFtZX1vcFVEVCgke3VkdC5uYW1lfSk6IGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybiBlcnJvci4gVW5yZWNvZ25pemVkIHJldHVybiBzdGF0ZTogJHtzeXNEYXRhLnN0YXRlfWBcbiAgICAgICAgKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgVURUYCBvcGVyYXRvci48YnI+XG4gIC8vIFNpbXBseSBjYWxscyB0aGUgdXNlcidzIGNhbGxiYWNrIGZ1bmN0aW9uLCBidXQgb3BlcmF0ZXMgbGlrZSBgUk5NYCB3aXRoIHJlZ2FyZCB0byB0aGUgYEFTVGBcbiAgLy8gYW5kIGJhY2sgcmVmZXJlbmNpbmcuXG4gIC8vIFRoZXJlIGlzIHNvbWUgYW1iaWd1aXR5IGhlcmUuIGBVRFRgcyBhY3QgYXMgdGVybWluYWxzIGZvciBwaHJhc2UgcmVjb2duaXRpb24gYnV0IGFzIG5hbWVkIHJ1bGVzXG4gIC8vIGZvciBgQVNUYCBub2RlcyBhbmQgYmFjayByZWZlcmVuY2luZy5cbiAgLy8gU2VlIFtgYXN0LmpzYF0oLi9hc3QuaHRtbCkgZm9yIHVzYWdlLlxuICBjb25zdCBvcFVEVCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGFzdEluZGV4O1xuICAgIGxldCBhc3REZWZpbmVkO1xuICAgIGxldCB1bGVuO1xuICAgIGxldCBwbGVuO1xuICAgIGxldCBzYXZlRnJhbWU7XG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGNvbnN0IHVkdCA9IHVkdHNbb3AuaW5kZXhdO1xuICAgIHN5c0RhdGEuVWR0SW5kZXggPSB1ZHQuaW5kZXg7XG5cbiAgICBjb25zdCBub3RMb29rQXJvdW5kID0gIWluTG9va0Fyb3VuZCgpO1xuICAgIC8qIGlnbm9yZSBBU1QgYW5kIGJhY2sgcmVmZXJlbmNlcyBpbiBsb29rYXJvdW5kICovXG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGJlZ2luIEFTVCBhbmQgYmFjayByZWZlcmVuY2UgKi9cbiAgICAgIGFzdERlZmluZWQgPSB0aGlzVGhpcy5hc3QgJiYgdGhpc1RoaXMuYXN0LnVkdERlZmluZWQob3AuaW5kZXgpO1xuICAgICAgaWYgKGFzdERlZmluZWQpIHtcbiAgICAgICAgYXN0SW5kZXggPSBydWxlcy5sZW5ndGggKyBvcC5pbmRleDtcbiAgICAgICAgYXN0TGVuZ3RoID0gdGhpc1RoaXMuYXN0LmdldExlbmd0aCgpO1xuICAgICAgICB0aGlzVGhpcy5hc3QuZG93bihhc3RJbmRleCwgdWR0Lm5hbWUpO1xuICAgICAgfVxuICAgICAgLyogTk9URTogcHVzaCBhbmQgcG9wIG9mIHRoZSBiYWNrIHJlZmVyZW5jZSBmcmFtZSBpcyBub3JtYWxseSBub3QgbmVjZXNzYXJ5ICovXG4gICAgICAvKiBvbmx5IGluIHRoZSBjYXNlIHRoYXQgdGhlIFVEVCBjYWxscyBldmFsdWF0ZVJ1bGUoKSBvciBldmFsdWF0ZVVkdCgpICovXG4gICAgICB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgICBwbGVuID0gc3lzRGF0YS5wRnJhbWUubGVuZ3RoKCk7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wdXNoKCk7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wdXNoKCk7XG4gICAgICBzYXZlRnJhbWUgPSBzeXNEYXRhLnBGcmFtZTtcbiAgICAgIHN5c0RhdGEucEZyYW1lID0gbmV3IGJhY2tSZWYoKTtcbiAgICB9XG4gICAgLyogY2FsbCB0aGUgVURUICovXG4gICAgY29uc3QgY2hhcnNMZWZ0ID0gY2hhcnNFbmQgLSBwaHJhc2VJbmRleDtcbiAgICB1ZHRDYWxsYmFja3Nbb3AuaW5kZXhdKHN5c0RhdGEsIGNoYXJzLCBwaHJhc2VJbmRleCwgc3ludGF4RGF0YSk7XG4gICAgdmFsaWRhdGVVZHRDYWxsYmFja1Jlc3VsdCh1ZHQsIHN5c0RhdGEsIGNoYXJzTGVmdCk7XG4gICAgaWYgKG5vdExvb2tBcm91bmQpIHtcbiAgICAgIC8qIGVuZCBBU1QgKi9cbiAgICAgIGlmIChhc3REZWZpbmVkKSB7XG4gICAgICAgIGlmIChzeXNEYXRhLnN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNUaGlzLmFzdC51cChhc3RJbmRleCwgdWR0Lm5hbWUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIGVuZCBiYWNrIHJlZmVyZW5jZSAqL1xuICAgICAgc3lzRGF0YS5wRnJhbWUgPSBzYXZlRnJhbWU7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIH0gZWxzZSBpZiAodWR0LmlzQmtyKSB7XG4gICAgICAgIC8qIHNhdmUgcGhyYXNlIG9uIGJvdGggdGhlIHBhcmVudCBhbmQgdW5pdmVyc2FsIGZyYW1lcyAqL1xuICAgICAgICAvKiBCS1Igb3BlcmF0b3Igd2lsbCBkZWNpZGUgd2hpY2ggdG8gdXNlIGxhdGVyICovXG4gICAgICAgIHN5c0RhdGEucEZyYW1lLnNhdmVQaHJhc2UodWR0Lmxvd2VyLCBwaHJhc2VJbmRleCwgc3lzRGF0YS5waHJhc2VMZW5ndGgpO1xuICAgICAgICBzeXNEYXRhLnVGcmFtZS5zYXZlUGhyYXNlKHVkdC5sb3dlciwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgQU5EYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgdGhlIHBvc2l0aXZlIGBsb29rIGFoZWFkYCBvcGVyYXRvci5cbiAgLy8gRXhlY3V0ZXMgaXRzIHNpbmdsZSBjaGlsZCBub2RlLCByZXR1cm5pbmcgdGhlIEVNUFRZIHN0YXRlXG4gIC8vIGlmIGl0IHN1Y2NlZWRzYW5kIE5PTUFUQ0ggaWYgaXQgZmFpbHMuXG4gIC8vICpBbHdheXMqIGJhY2t0cmFja3Mgb24gYW55IG1hdGNoZWQgcGhyYXNlIGFuZCByZXR1cm5zIEVNUFRZIG9uIHN1Y2Nlc3MuXG4gIGNvbnN0IG9wQU5EID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbG9va0Fyb3VuZC5wdXNoKHtcbiAgICAgIGxvb2tBcm91bmQ6IGlkLkxPT0tBUk9VTkRfQUhFQUQsXG4gICAgICBhbmNob3I6IHBocmFzZUluZGV4LFxuICAgICAgY2hhcnNFbmQsXG4gICAgICBjaGFyc0xlbmd0aCxcbiAgICB9KTtcbiAgICBjaGFyc0VuZCA9IGNoYXJzLmxlbmd0aDtcbiAgICBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aCAtIGNoYXJzQmVnaW47XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgY29uc3QgcG9wID0gbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBjaGFyc0VuZCA9IHBvcC5jaGFyc0VuZDtcbiAgICBjaGFyc0xlbmd0aCA9IHBvcC5jaGFyc0xlbmd0aDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcEFORDogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYE5PVGAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBuZWdhdGl2ZSBgbG9vayBhaGVhZGAgb3BlcmF0b3IuXG4gIC8vIEV4ZWN1dGVzIGl0cyBzaW5nbGUgY2hpbGQgbm9kZSwgcmV0dXJuaW5nIHRoZSBFTVBUWSBzdGF0ZVxuICAvLyBpZiBpdCAqZmFpbHMqIGFuZCBOT01BVENIIGlmIGl0IHN1Y2NlZWRzLlxuICAvLyAqQWx3YXlzKiBiYWNrdHJhY2tzIG9uIGFueSBtYXRjaGVkIHBocmFzZSBhbmQgcmV0dXJucyBFTVBUWVxuICAvLyBvbiBzdWNjZXNzIChmYWlsdXJlIG9mIGl0cyBjaGlsZCBub2RlKS5cbiAgY29uc3Qgb3BOT1QgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsb29rQXJvdW5kLnB1c2goe1xuICAgICAgbG9va0Fyb3VuZDogaWQuTE9PS0FST1VORF9BSEVBRCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgICBjaGFyc0VuZCxcbiAgICAgIGNoYXJzTGVuZ3RoLFxuICAgIH0pO1xuICAgIGNoYXJzRW5kID0gY2hhcnMubGVuZ3RoO1xuICAgIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoIC0gY2hhcnNCZWdpbjtcbiAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICBjb25zdCBwb3AgPSBsb29rQXJvdW5kLnBvcCgpO1xuICAgIGNoYXJzRW5kID0gcG9wLmNoYXJzRW5kO1xuICAgIGNoYXJzTGVuZ3RoID0gcG9wLmNoYXJzTGVuZ3RoO1xuICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICBzd2l0Y2ggKHN5c0RhdGEuc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG9wTk9UOiBpbnZhbGlkIHN0YXRlICR7c3lzRGF0YS5zdGF0ZX1gKTtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgVFJHYCBvcGVyYXRvci48YnI+XG4gIC8vIFN1Y2NlZWRzIGlmIHRoZSBzaW5nbGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBwaHJhc2UgaXNcbiAgLy8gd2l0aGluIHRoZSBgbWluIC0gbWF4YCByYW5nZS5cbiAgY29uc3Qgb3BUUkcgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgaWYgKHBocmFzZUluZGV4IDwgY2hhcnNFbmQpIHtcbiAgICAgIGlmIChvcC5taW4gPD0gY2hhcnNbcGhyYXNlSW5kZXhdICYmIGNoYXJzW3BocmFzZUluZGV4XSA8PSBvcC5tYXgpIHtcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYFRCU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBNYXRjaGVzIGl0cyBwcmUtZGVmaW5lZCBwaHJhc2UgYWdhaW5zdCB0aGUgaW5wdXQgc3RyaW5nLlxuICAvLyBBbGwgY2hhcmFjdGVycyBtdXN0IG1hdGNoIGV4YWN0bHkuXG4gIC8vIENhc2Utc2Vuc2l0aXZlIGxpdGVyYWwgc3RyaW5ncyAoYCdzdHJpbmcnYCAmIGAlc1wic3RyaW5nXCJgKSBhcmUgdHJhbnNsYXRlZCB0byBgVEJTYFxuICAvLyBvcGVyYXRvcnMgYnkgYGFwZ2AuXG4gIC8vIFBocmFzZSBsZW5ndGggb2YgemVybyBpcyBub3QgYWxsb3dlZC5cbiAgLy8gRW1wdHkgcGhyYXNlcyBjYW4gb25seSBiZSBkZWZpbmVkIHdpdGggYFRMU2Agb3BlcmF0b3JzLlxuICBjb25zdCBvcFRCUyA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBjb25zdCBsZW4gPSBvcC5zdHJpbmcubGVuZ3RoO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5OT01BVENIO1xuICAgIGlmIChwaHJhc2VJbmRleCArIGxlbiA8PSBjaGFyc0VuZCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChjaGFyc1twaHJhc2VJbmRleCArIGldICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH0gLyogaW1wbGllZCBlbHNlIE5PTUFUQ0ggKi9cbiAgfTtcbiAgLy8gVGhlIGBUTFNgIG9wZXJhdG9yLjxicj5cbiAgLy8gTWF0Y2hlcyBpdHMgcHJlLWRlZmluZWQgcGhyYXNlIGFnYWluc3QgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gQSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGlzIGF0dGVtcHRlZCBmb3IgQVNDSUkgYWxwaGJldGljYWwgY2hhcmFjdGVycy5cbiAgLy8gYFRMU2AgaXMgdGhlIG9ubHkgb3BlcmF0b3IgdGhhdCBleHBsaWNpdGx5IGFsbG93cyBlbXB0eSBwaHJhc2VzLlxuICAvLyBgYXBnYCB3aWxsIGZhaWwgZm9yIGVtcHR5IGBUQlNgLCBjYXNlLXNlbnNpdGl2ZSBzdHJpbmdzIChgJydgKSBvclxuICAvLyB6ZXJvIHJlcGV0aXRpb25zIChgMCowUnVsZU5hbWVgIG9yIGAwUnVsZU5hbWVgKS5cbiAgY29uc3Qgb3BUTFMgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgY29kZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAvKiBFTVBUWSBtYXRjaCBhbGxvd2VkIGZvciBUTFMgKi9cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBocmFzZUluZGV4ICsgbGVuIDw9IGNoYXJzRW5kKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29kZSA9IGNoYXJzW3BocmFzZUluZGV4ICsgaV07XG4gICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICBjb2RlICs9IDMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlICE9PSBvcC5zdHJpbmdbaV0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgIH0gLyogaW1wbGllZCBlbHNlIE5PTUFUQ0ggKi9cbiAgfTtcbiAgLy8gVGhlIGBBQkdgIG9wZXJhdG9yLjxicj5cbiAgLy8gVGhpcyBpcyBhbiBcImFuY2hvclwiIGZvciB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcsIHNpbWlsYXIgdG8gdGhlIGZhbWlsaWFyIHJlZ2V4IGBeYCBhbmNob3IuXG4gIC8vIEFuIGFuY2hvciBtYXRjaGVzIGEgcG9zaXRpb24gcmF0aGVyIHRoYW4gYSBwaHJhc2UuXG4gIC8vIFJldHVybnMgRU1QVFkgaWYgYHBocmFzZUluZGV4YCBpcyAwLCBOT01BVENIIG90aGVyd2lzZS5cbiAgY29uc3Qgb3BBQkcgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IHBocmFzZUluZGV4ID09PSAwID8gaWQuRU1QVFkgOiBpZC5OT01BVENIO1xuICB9O1xuICAvLyBUaGUgYEFFTmAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIGFuIFwiYW5jaG9yXCIgZm9yIHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc2ltaWxhciB0byB0aGUgZmFtaWxpYXIgcmVnZXggYCRgIGFuY2hvci5cbiAgLy8gQW4gYW5jaG9yIG1hdGNoZXMgYSBwb3NpdGlvbiByYXRoZXIgdGhhbiBhIHBocmFzZS5cbiAgLy8gUmV0dXJucyBFTVBUWSBpZiBgcGhyYXNlSW5kZXhgIGVxdWFscyB0aGUgaW5wdXQgc3RyaW5nIGxlbmd0aCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIGNvbnN0IG9wQUVOID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIHN5c0RhdGEuc3RhdGUgPSBwaHJhc2VJbmRleCA9PT0gY2hhcnMubGVuZ3RoID8gaWQuRU1QVFkgOiBpZC5OT01BVENIO1xuICB9O1xuICAvLyBUaGUgYEJLUmAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGUgYmFjayByZWZlcmVuY2Ugb3BlcmF0b3IuXG4gIC8vIE1hdGNoZXMgdGhlIGxhc3QgbWF0Y2hlZCBwaHJhc2Ugb2YgdGhlIG5hbWVkIHJ1bGUgb3IgVURUIGFnYWluc3QgdGhlIGlucHV0IHN0cmluZy5cbiAgLy8gRm9yIEFTQ0lJIGFscGhiZXRpY2FsIGNoYXJhY3RlcnMgdGhlIG1hdGNoIG1heSBiZSBjYXNlIHNlbnNpdGl2ZSAoYCVzYCkgb3IgaW5zZW5zaXRpdmUgKGAlaWApLFxuICAvLyBkZXBlbmRpbmcgb24gdGhlIGJhY2sgcmVmZXJlbmNlIGRlZmluaXRpb24uXG4gIC8vIEZvciBgdW5pdmVyc2FsYCBtb2RlIChgJXVgKSBtYXRjaGVzIHRoZSBsYXN0IHBocmFzZSBmb3VuZCBhbnl3aGVyZSBpbiB0aGUgZ3JhbW1hci5cbiAgLy8gRm9yIGBwYXJlbnQgZnJhbWVgIG1vZGUgKGAlcGApIG1hdGNoZXMgdGhlIGxhc3QgcGhyYXNlIGZvdW5kIGluIHRoZSBwYXJlbnQgcnVsZSBvbmx5LlxuICBjb25zdCBvcEJLUiA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGxldCBjb2RlO1xuICAgIGxldCBsbWNvZGU7XG4gICAgbGV0IGxvd2VyO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBpZiAob3AuaW5kZXggPCBydWxlcy5sZW5ndGgpIHtcbiAgICAgIGxvd2VyID0gcnVsZXNbb3AuaW5kZXhdLmxvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb3dlciA9IHVkdHNbb3AuaW5kZXggLSBydWxlcy5sZW5ndGhdLmxvd2VyO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZSA9IG9wLmJrck1vZGUgPT09IGlkLkJLUl9NT0RFX1BNID8gc3lzRGF0YS5wRnJhbWUuZ2V0UGhyYXNlKGxvd2VyKSA6IHN5c0RhdGEudUZyYW1lLmdldFBocmFzZShsb3dlcik7XG4gICAgY29uc3QgaW5zZW5zaXRpdmUgPSBvcC5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSTtcbiAgICBpZiAoZnJhbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG1JbmRleCA9IGZyYW1lLnBocmFzZUluZGV4O1xuICAgIGNvbnN0IGxlbiA9IGZyYW1lLnBocmFzZUxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwaHJhc2VJbmRleCArIGxlbiA8PSBjaGFyc0VuZCkge1xuICAgICAgaWYgKGluc2Vuc2l0aXZlKSB7XG4gICAgICAgIC8qIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29kZSA9IGNoYXJzW3BocmFzZUluZGV4ICsgaV07XG4gICAgICAgICAgbG1jb2RlID0gY2hhcnNbbG1JbmRleCArIGldO1xuICAgICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsbWNvZGUgPj0gNjUgJiYgbG1jb2RlIDw9IDkwKSB7XG4gICAgICAgICAgICBsbWNvZGUgKz0gMzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlICE9PSBsbWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGNhc2Utc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1twaHJhc2VJbmRleCArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSBgQktBYCBvcGVyYXRvci48YnI+XG4gIC8vIFRoaXMgaXMgdGhlIHBvc2l0aXZlIGBsb29rIGJlaGluZGAgb3BlcmF0b3IuXG4gIC8vIEl0J3MgY2hpbGQgbm9kZSBpcyBwYXJzZWQgcmlnaHQtdG8tbGVmdC5cbiAgLy8gUmV0dXJucyB0aGUgRU1QVFkgc3RhdGUgaWYgYSBtYXRjaCBpcyBmb3VuZCwgTk9NQVRDSCBvdGhlcndpc2UuXG4gIC8vIExpa2UgdGhlIGxvb2sgYWhlYWQgb3BlcmF0b3JzLCBpdCBhbHdheXMgYmFja3RyYWNrcyB0byBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcEJLQSA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0JFSElORCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgfSk7XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcEJLQTogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgYEJLTmAgb3BlcmF0b3IuPGJyPlxuICAvLyBUaGlzIGlzIHRoZSBuZWdhdGl2ZSBgbG9vayBiZWhpbmRgIG9wZXJhdG9yLlxuICAvLyBJdCdzIGNoaWxkIG5vZGUgaXMgcGFyc2VkIHJpZ2h0LXRvLWxlZnQuXG4gIC8vIFJldHVybnMgdGhlIEVNUFRZIHN0YXRlIGlmIGEgbWF0Y2ggaXMgKm5vdCogZm91bmQsIE5PTUFUQ0ggb3RoZXJ3aXNlLlxuICAvLyBMaWtlIHRoZSBsb29rIGFoZWFkIG9wZXJhdG9ycywgaXQgYWx3YXlzIGJhY2t0cmFja3MgdG8gYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BCS04gPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICAvLyBsZXQgb3A7XG4gICAgLy8gb3AgPSBvcGNvZGVzW29wSW5kZXhdO1xuICAgIGxvb2tBcm91bmQucHVzaCh7XG4gICAgICBsb29rQXJvdW5kOiBpZC5MT09LQVJPVU5EX0JFSElORCxcbiAgICAgIGFuY2hvcjogcGhyYXNlSW5kZXgsXG4gICAgfSk7XG4gICAgb3BFeGVjdXRlKG9wSW5kZXggKyAxLCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgbG9va0Fyb3VuZC5wb3AoKTtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgc3dpdGNoIChzeXNEYXRhLnN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuRU1QVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvcEJLTjogaW52YWxpZCBzdGF0ZSAke3N5c0RhdGEuc3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgQ0FUYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYENBVGAgb3BlcmF0b3JzIHdoZW4gaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gQ2FsbHMgaXRzIGNoaWxkIG5vZGVzIGZyb20gcmlnaHQgdG8gbGVmdCBjb25jYXRlbmF0aW5nIG1hdGNoZWQgcGhyYXNlcyByaWdodCB0byBsZWZ0LlxuICBjb25zdCBvcENBVEJlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBzdWNjZXNzO1xuICAgIGxldCBhc3RMZW5ndGg7XG4gICAgbGV0IGNhdENoYXJJbmRleDtcbiAgICBsZXQgY2F0TWF0Y2hlZDtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgY29uc3QgdWxlbiA9IHN5c0RhdGEudUZyYW1lLmxlbmd0aCgpO1xuICAgIGNvbnN0IHBsZW4gPSBzeXNEYXRhLnBGcmFtZS5sZW5ndGgoKTtcbiAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICBhc3RMZW5ndGggPSB0aGlzVGhpcy5hc3QuZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgIGNhdENoYXJJbmRleCA9IHBocmFzZUluZGV4O1xuICAgIGNhdE1hdGNoZWQgPSAwO1xuICAgIC8vIGNhdFBocmFzZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IG9wLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBvcEV4ZWN1dGUob3AuY2hpbGRyZW5baV0sIGNhdENoYXJJbmRleCwgc3lzRGF0YSk7XG4gICAgICBjYXRDaGFySW5kZXggLT0gc3lzRGF0YS5waHJhc2VMZW5ndGg7XG4gICAgICBjYXRNYXRjaGVkICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgLy8gY2F0UGhyYXNlICs9IHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLk5PTUFUQ0gpIHtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHN5c0RhdGEuc3RhdGUgPSBjYXRNYXRjaGVkID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gY2F0TWF0Y2hlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgICBzeXNEYXRhLnVGcmFtZS5wb3AodWxlbik7XG4gICAgICBzeXNEYXRhLnBGcmFtZS5wb3AocGxlbik7XG4gICAgICBpZiAodGhpc1RoaXMuYXN0KSB7XG4gICAgICAgIHRoaXNUaGlzLmFzdC5zZXRMZW5ndGgoYXN0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGBSRVBgIG9wZXJhdG9yLjxicj5cbiAgLy8gQ2FsbGVkIGZvciBgUkVQYCBvcGVyYXRvcnMgaW4gbG9vayBiZWhpbmQgbW9kZS5cbiAgLy8gTWFrZXMgcmVwZWF0ZWQgY2FsbHMgdG8gaXRzIGNoaWxkIG5vZGUsIGNvbmNhdGVuYXRpbmcgbWF0Y2hlZCBwaHJhc2VzIHJpZ2h0IHRvIGxlZnQuXG4gIGNvbnN0IG9wUkVQQmVoaW5kID0gZnVuY3Rpb24gKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKSB7XG4gICAgbGV0IGFzdExlbmd0aDtcbiAgICBsZXQgcmVwQ2hhckluZGV4O1xuICAgIGxldCByZXBQaHJhc2U7XG4gICAgbGV0IHJlcENvdW50O1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICByZXBDaGFySW5kZXggPSBwaHJhc2VJbmRleDtcbiAgICByZXBQaHJhc2UgPSAwO1xuICAgIHJlcENvdW50ID0gMDtcbiAgICBjb25zdCB1bGVuID0gc3lzRGF0YS51RnJhbWUubGVuZ3RoKCk7XG4gICAgY29uc3QgcGxlbiA9IHN5c0RhdGEucEZyYW1lLmxlbmd0aCgpO1xuICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgIGFzdExlbmd0aCA9IHRoaXNUaGlzLmFzdC5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgY29uc3QgVFJVRSA9IHRydWU7XG4gICAgd2hpbGUgKFRSVUUpIHtcbiAgICAgIGlmIChyZXBDaGFySW5kZXggPD0gMCkge1xuICAgICAgICAvKiBleGl0IG9uIGVuZCBvZiBpbnB1dCBzdHJpbmcgKi9cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvcEV4ZWN1dGUob3BJbmRleCArIDEsIHJlcENoYXJJbmRleCwgc3lzRGF0YSk7XG4gICAgICBpZiAoc3lzRGF0YS5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgICAgICAvKiBhbHdheXMgZW5kIGlmIHRoZSBjaGlsZCBub2RlIGZhaWxzICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICAgIC8qIFJFUCBhbHdheXMgc3VjY2VlZHMgd2hlbiB0aGUgY2hpbGQgbm9kZSByZXR1cm5zIGFuIGVtcHR5IHBocmFzZSAqL1xuICAgICAgICAvKiB0aGlzIG1heSBub3Qgc2VlbSBvYnZpb3VzLCBidXQgdGhhdCdzIHRoZSB3YXkgaXQgd29ya3Mgb3V0ICovXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVwQ291bnQgKz0gMTtcbiAgICAgIHJlcFBocmFzZSArPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIHJlcENoYXJJbmRleCAtPSBzeXNEYXRhLnBocmFzZUxlbmd0aDtcbiAgICAgIGlmIChyZXBDb3VudCA9PT0gb3AubWF4KSB7XG4gICAgICAgIC8qIGVuZCBvbiBtYXhlZCBvdXQgcmVwcyAqL1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXZhbHVhdGUgdGhlIG1hdGNoIGNvdW50IGFjY29yZGluZyB0byB0aGUgbWluLCBtYXggdmFsdWVzICovXG4gICAgaWYgKHN5c0RhdGEuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gcmVwUGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gcmVwUGhyYXNlO1xuICAgIH0gZWxzZSBpZiAocmVwQ291bnQgPj0gb3AubWluKSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gcmVwUGhyYXNlID09PSAwID8gaWQuRU1QVFkgOiBpZC5NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gcmVwUGhyYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gMDtcbiAgICAgIHN5c0RhdGEudUZyYW1lLnBvcCh1bGVuKTtcbiAgICAgIHN5c0RhdGEucEZyYW1lLnBvcChwbGVuKTtcbiAgICAgIGlmICh0aGlzVGhpcy5hc3QpIHtcbiAgICAgICAgdGhpc1RoaXMuYXN0LnNldExlbmd0aChhc3RMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFRSR2Agb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBUUkdgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBgcGhyYXNlSW5kZXggLSAxYCB0byB0aGUgYG1pbmAgLSBgbWF4YCByYW5nZS5cbiAgY29uc3Qgb3BUUkdCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgIGlmIChwaHJhc2VJbmRleCA+IDApIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjaGFyc1twaHJhc2VJbmRleCAtIDFdO1xuICAgICAgaWYgKG9wLm1pbiA8PSBjaGFyICYmIGNoYXIgPD0gb3AubWF4KSB7XG4gICAgICAgIHN5c0RhdGEuc3RhdGUgPSBpZC5NQVRDSDtcbiAgICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gVGhlIHJpZ2h0LXRvLWxlZnQgYFRCU2Agb3BlcmF0b3IuPGJyPlxuICAvLyBDYWxsZWQgZm9yIGBUQlNgIG9wZXJhdG9ycyBpbiBsb29rIGJlaGluZCBtb2RlLlxuICAvLyBNYXRjaGVzIHRoZSBgVEJTYCBwaHJhc2UgdG8gdGhlIGxlZnQgb2YgYHBocmFzZUluZGV4YC5cbiAgY29uc3Qgb3BUQlNCZWhpbmQgPSBmdW5jdGlvbiAob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk5PTUFUQ0g7XG4gICAgY29uc3QgbGVuID0gb3Auc3RyaW5nLmxlbmd0aDtcbiAgICBjb25zdCBiZWcgPSBwaHJhc2VJbmRleCAtIGxlbjtcbiAgICBpZiAoYmVnID49IDApIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoY2hhcnNbYmVnICsgaV0gIT09IG9wLnN0cmluZ1tpXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLk1BVENIO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSBsZW47XG4gICAgfVxuICB9O1xuICAvLyBUaGUgcmlnaHQtdG8tbGVmdCBgVExTYCBvcGVyYXRvci48YnI+XG4gIC8vIENhbGxlZCBmb3IgYFRMU2Agb3BlcmF0b3JzIGluIGxvb2sgYmVoaW5kIG1vZGUuXG4gIC8vIE1hdGNoZXMgdGhlIGBUTFNgIHBocmFzZSB0byB0aGUgbGVmdCBvZiBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcFRMU0JlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBjaGFyO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBjb25zdCBsZW4gPSBvcC5zdHJpbmcubGVuZ3RoO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIC8qIEVNUFRZIG1hdGNoIGFsbG93ZWQgZm9yIFRMUyAqL1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiZWcgPSBwaHJhc2VJbmRleCAtIGxlbjtcbiAgICBpZiAoYmVnID49IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY2hhciA9IGNoYXJzW2JlZyArIGldO1xuICAgICAgICBpZiAoY2hhciA+PSA2NSAmJiBjaGFyIDw9IDkwKSB7XG4gICAgICAgICAgY2hhciArPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciAhPT0gb3Auc3RyaW5nW2ldKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIFRoZSByaWdodC10by1sZWZ0IGJhY2sgcmVmZXJlbmNlIG9wZXJhdG9yLjxicj5cbiAgLy8gTWF0Y2hlcyB0aGUgYmFjayByZWZlcmVuY2VkIHBocmFzZSB0byB0aGUgbGVmdCBvZiBgcGhyYXNlSW5kZXhgLlxuICBjb25zdCBvcEJLUkJlaGluZCA9IGZ1bmN0aW9uIChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSkge1xuICAgIGxldCBpO1xuICAgIGxldCBjb2RlO1xuICAgIGxldCBsbWNvZGU7XG4gICAgbGV0IGxvd2VyO1xuICAgIGNvbnN0IG9wID0gb3Bjb2Rlc1tvcEluZGV4XTtcbiAgICAvKiBOT01BVENIIGRlZmF1bHQgKi9cbiAgICBzeXNEYXRhLnN0YXRlID0gaWQuTk9NQVRDSDtcbiAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IDA7XG4gICAgaWYgKG9wLmluZGV4IDwgcnVsZXMubGVuZ3RoKSB7XG4gICAgICBsb3dlciA9IHJ1bGVzW29wLmluZGV4XS5sb3dlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbG93ZXIgPSB1ZHRzW29wLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5sb3dlcjtcbiAgICB9XG4gICAgY29uc3QgZnJhbWUgPSBvcC5ia3JNb2RlID09PSBpZC5CS1JfTU9ERV9QTSA/IHN5c0RhdGEucEZyYW1lLmdldFBocmFzZShsb3dlcikgOiBzeXNEYXRhLnVGcmFtZS5nZXRQaHJhc2UobG93ZXIpO1xuICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gb3AuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ0k7XG4gICAgaWYgKGZyYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxtSW5kZXggPSBmcmFtZS5waHJhc2VJbmRleDtcbiAgICBjb25zdCBsZW4gPSBmcmFtZS5waHJhc2VMZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgc3lzRGF0YS5zdGF0ZSA9IGlkLkVNUFRZO1xuICAgICAgc3lzRGF0YS5waHJhc2VMZW5ndGggPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiZWcgPSBwaHJhc2VJbmRleCAtIGxlbjtcbiAgICBpZiAoYmVnID49IDApIHtcbiAgICAgIGlmIChpbnNlbnNpdGl2ZSkge1xuICAgICAgICAvKiBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoICovXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvZGUgPSBjaGFyc1tiZWcgKyBpXTtcbiAgICAgICAgICBsbWNvZGUgPSBjaGFyc1tsbUluZGV4ICsgaV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkge1xuICAgICAgICAgICAgY29kZSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxtY29kZSA+PSA2NSAmJiBsbWNvZGUgPD0gOTApIHtcbiAgICAgICAgICAgIGxtY29kZSArPSAzMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvZGUgIT09IGxtY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICAgIHN5c0RhdGEucGhyYXNlTGVuZ3RoID0gbGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogY2FzZS1zZW5zaXRpdmUgbWF0Y2ggKi9cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29kZSA9IGNoYXJzW2JlZyArIGldO1xuICAgICAgICAgIGxtY29kZSA9IGNoYXJzW2xtSW5kZXggKyBpXTtcbiAgICAgICAgICBpZiAoY29kZSAhPT0gbG1jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeXNEYXRhLnN0YXRlID0gaWQuTUFUQ0g7XG4gICAgICBzeXNEYXRhLnBocmFzZUxlbmd0aCA9IGxlbjtcbiAgICB9XG4gIH07XG4gIC8vIEdlbmVyYWxpemVkIGV4ZWN1dGlvbiBmdW5jdGlvbi48YnI+XG4gIC8vIEhhdmluZyBhIHNpbmdsZSwgZ2VuZXJhbGl6ZWQgZnVuY3Rpb24sIGFsbG93cyBhIHNpbmdsZSBsb2NhdGlvblxuICAvLyBmb3IgdHJhY2luZyBhbmQgc3RhdGlzdGljcyBnYXRoZXJpbmcgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZC5cbiAgLy8gVHJhY2luZyBhbmQgc3RhdGlzdGljcyBhcmUgaGFuZGxlZCBpbiBzZXBhcmF0ZSBvYmplY3RzLlxuICAvLyBIb3dldmVyLCB0aGUgcGFyc2VyIGNhbGxzIHRoZWlyIEFQSSB0byBidWlsZCB0aGUgb2JqZWN0IGRhdGEgcmVjb3Jkcy5cbiAgLy8gU2VlIFtgdHJhY2UuanNgXSguL3RyYWNlLmh0bWwpIGFuZCBbYHN0YXRzLmpzYF0oLi9zdGF0cy5odG1sKSBmb3IgdGhlaXJcbiAgLy8gdXNhZ2UuXG4gIG9wRXhlY3V0ZSA9IGZ1bmN0aW9uIG9wRXhlY3V0ZUZ1bmMob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpIHtcbiAgICBsZXQgcmV0ID0gdHJ1ZTtcbiAgICBjb25zdCBvcCA9IG9wY29kZXNbb3BJbmRleF07XG4gICAgbm9kZUhpdHMgKz0gMTtcbiAgICBpZiAobm9kZUhpdHMgPiBsaW1pdE5vZGVIaXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4aW11bSBudW1iZXIgb2Ygbm9kZSBoaXRzIGV4Y2VlZGVkOiAke2xpbWl0Tm9kZUhpdHN9YCk7XG4gICAgfVxuICAgIHRyZWVEZXB0aCArPSAxO1xuICAgIGlmICh0cmVlRGVwdGggPiBtYXhUcmVlRGVwdGgpIHtcbiAgICAgIG1heFRyZWVEZXB0aCA9IHRyZWVEZXB0aDtcbiAgICAgIGlmIChtYXhUcmVlRGVwdGggPiBsaW1pdFRyZWVEZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcnNlcjogbWF4aW11bSBwYXJzZSB0cmVlIGRlcHRoIGV4Y2VlZGVkOiAke2xpbWl0VHJlZURlcHRofWApO1xuICAgICAgfVxuICAgIH1cbiAgICBzeXNEYXRhLnJlZnJlc2goKTtcbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIC8qIGNvbGxlY3QgdGhlIHRyYWNlIHJlY29yZCBmb3IgZG93biB0aGUgcGFyc2UgdHJlZSAqL1xuICAgICAgY29uc3QgbGsgPSBsb29rQXJvdW5kVmFsdWUoKTtcbiAgICAgIHRoaXNUaGlzLnRyYWNlLmRvd24ob3AsIHN5c0RhdGEuc3RhdGUsIHBocmFzZUluZGV4LCBzeXNEYXRhLnBocmFzZUxlbmd0aCwgbGsuYW5jaG9yLCBsay5sb29rQXJvdW5kKTtcbiAgICB9XG4gICAgaWYgKGluTG9va0JlaGluZCgpKSB7XG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSBpZC5BTFQ6XG4gICAgICAgICAgb3BBTFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkNBVDpcbiAgICAgICAgICBvcENBVEJlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUkVQOlxuICAgICAgICAgIG9wUkVQQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgb3BSTk0ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlVEVDpcbiAgICAgICAgICBvcFVEVChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQU5EOlxuICAgICAgICAgIG9wQU5EKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5OT1Q6XG4gICAgICAgICAgb3BOT1Qob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICBvcFRSR0JlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVEJTOlxuICAgICAgICAgIG9wVEJTQmVoaW5kKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UTFM6XG4gICAgICAgICAgb3BUTFNCZWhpbmQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLUjpcbiAgICAgICAgICBvcEJLUkJlaGluZChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktBOlxuICAgICAgICAgIG9wQktBKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS046XG4gICAgICAgICAgb3BCS04ob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFCRzpcbiAgICAgICAgICBvcEFCRyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQUVOOlxuICAgICAgICAgIG9wQUVOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgaWQuQUxUOlxuICAgICAgICAgIG9wQUxUKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5DQVQ6XG4gICAgICAgICAgb3BDQVQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlJFUDpcbiAgICAgICAgICBvcFJFUChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuUk5NOlxuICAgICAgICAgIG9wUk5NKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5VRFQ6XG4gICAgICAgICAgb3BVRFQob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFORDpcbiAgICAgICAgICBvcEFORChvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuTk9UOlxuICAgICAgICAgIG9wTk9UKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5UUkc6XG4gICAgICAgICAgb3BUUkcob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLlRCUzpcbiAgICAgICAgICBvcFRCUyhvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgIG9wVExTKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5CS1I6XG4gICAgICAgICAgb3BCS1Iob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkJLQTpcbiAgICAgICAgICBvcEJLQShvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgaWQuQktOOlxuICAgICAgICAgIG9wQktOKG9wSW5kZXgsIHBocmFzZUluZGV4LCBzeXNEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5BQkc6XG4gICAgICAgICAgb3BBQkcob3BJbmRleCwgcGhyYXNlSW5kZXgsIHN5c0RhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkFFTjpcbiAgICAgICAgICBvcEFFTihvcEluZGV4LCBwaHJhc2VJbmRleCwgc3lzRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW5Mb29rQXJvdW5kKCkgJiYgcGhyYXNlSW5kZXggKyBzeXNEYXRhLnBocmFzZUxlbmd0aCA+IG1heE1hdGNoZWQpIHtcbiAgICAgIG1heE1hdGNoZWQgPSBwaHJhc2VJbmRleCArIHN5c0RhdGEucGhyYXNlTGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMuc3RhdHMgIT09IG51bGwpIHtcbiAgICAgIC8qIGNvbGxlY3QgdGhlIHN0YXRpc3RpY3MgKi9cbiAgICAgIHRoaXNUaGlzLnN0YXRzLmNvbGxlY3Qob3AsIHN5c0RhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpc1RoaXMudHJhY2UgIT09IG51bGwpIHtcbiAgICAgIC8qIGNvbGxlY3QgdGhlIHRyYWNlIHJlY29yZCBmb3IgdXAgdGhlIHBhcnNlIHRyZWUgKi9cbiAgICAgIGNvbnN0IGxrID0gbG9va0Fyb3VuZFZhbHVlKCk7XG4gICAgICB0aGlzVGhpcy50cmFjZS51cChvcCwgc3lzRGF0YS5zdGF0ZSwgcGhyYXNlSW5kZXgsIHN5c0RhdGEucGhyYXNlTGVuZ3RoLCBsay5hbmNob3IsIGxrLmxvb2tBcm91bmQpO1xuICAgIH1cbiAgICB0cmVlRGVwdGggLT0gMTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/stats.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/stats.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\nmodule.exports = function statsFunc() {\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\");\n\n  const thisFileName = 'stats.js: ';\n  let rules = [];\n  let udts = [];\n  const stats = [];\n  let totals;\n  const ruleStats = [];\n  const udtStats = [];\n  this.statsObject = 'statsObject';\n  const nameId = 'stats';\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */\n  const sortAlpha = function sortAlpha(lhs, rhs) {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */\n  const sortHits = function sortHits(lhs, rhs) {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */\n  /* (in the order in which they appear in the SABNF grammar). */\n  const sortIndex = function sortIndex(lhs, rhs) {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function EmptyStat() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = function clear() {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    stats[id.BKR] = new EmptyStat();\n    stats[id.BKA] = new EmptyStat();\n    stats[id.BKN] = new EmptyStat();\n    stats[id.ABG] = new EmptyStat();\n    stats[id.AEN] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = function incStat(stat, state) {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n  /* helper for toHtml() */\n  const displayRow = function displayRow(name, stat) {\n    let html = '';\n    html += '<tr>';\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n    html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n    html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n    html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n    html += '</tr>\\n';\n    return html;\n  };\n  const displayOpsOnly = function displayOpsOnly() {\n    let html = '';\n    html += displayRow('ALT', stats[id.ALT]);\n    html += displayRow('CAT', stats[id.CAT]);\n    html += displayRow('REP', stats[id.REP]);\n    html += displayRow('RNM', stats[id.RNM]);\n    html += displayRow('TRG', stats[id.TRG]);\n    html += displayRow('TBS', stats[id.TBS]);\n    html += displayRow('TLS', stats[id.TLS]);\n    html += displayRow('UDT', stats[id.UDT]);\n    html += displayRow('AND', stats[id.AND]);\n    html += displayRow('NOT', stats[id.NOT]);\n    html += displayRow('BKR', stats[id.BKR]);\n    html += displayRow('BKA', stats[id.BKA]);\n    html += displayRow('BKN', stats[id.BKN]);\n    html += displayRow('ABG', stats[id.ABG]);\n    html += displayRow('AEN', stats[id.AEN]);\n    html += displayRow('totals', totals);\n    return html;\n  };\n  /* helper for toHtml() */\n  const displayRules = function displayRules() {\n    let html = '';\n    html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n    html += '<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n';\n    for (let i = 0; i < rules.length; i += 1) {\n      if (ruleStats[i].total > 0) {\n        html += '<tr>';\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n        html += '</tr>\\n';\n      }\n    }\n    if (udts.length > 0) {\n      html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n      html += '<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n';\n      for (let i = 0; i < udts.length; i += 1) {\n        if (udtStats[i].total > 0) {\n          html += '<tr>';\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n          html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n          html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n          html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n          html += '</tr>\\n';\n        }\n      }\n    }\n    return html;\n  };\n  /* called only by the parser to validate a stats object */\n  this.validate = function validate(name) {\n    let ret = false;\n    if (typeof name === 'string' && nameId === name) {\n      ret = true;\n    }\n    return ret;\n  };\n  /* no verification of input - only called by parser() */\n  this.init = function init(inputRules, inputUdts) {\n    rules = inputRules;\n    udts = inputUdts;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = function collect(op, result) {\n    incStat(totals, result.state, result.phraseLength);\n    incStat(stats[op.type], result.state, result.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], result.state, result.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], result.state, result.phraseLength);\n    }\n  };\n  // Display the statistics as an HTML table.\n  // - *type*\n  //   - \"ops\" - (default) display only the total hit counts for all operator types.\n  //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n  //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n  //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n  // - *caption* - optional caption for the table\n  this.toHtml = function toHtml(type, caption) {\n    let html = '';\n    html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n    if (typeof caption === 'string') {\n      html += `<caption>${caption}</caption>\\n`;\n    }\n    html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n    html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n    html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n    const test = true;\n    while (test) {\n      if (type === undefined) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === null) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'ops') {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'index') {\n        ruleStats.sort(sortIndex);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'hits') {\n        ruleStats.sort(sortHits);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'alpha') {\n        ruleStats.sort(sortAlpha);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortAlpha);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      break;\n    }\n    html += '</table>\\n';\n    return html;\n  };\n  // Display the stats table in a complete HTML5 page.\n  this.toHtmlPage = function toHtmlPage(type, caption, title) {\n    return utils.htmlToPage(this.toHtml(type, caption), title);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0YXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw2RUFBZTtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWEsNENBQTRDLE1BQU07QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQixJQUFJLEtBQUs7QUFDdEQsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLGtCQUFrQixJQUFJLFdBQVc7QUFDM0QsMEJBQTBCLG9CQUFvQixJQUFJLGFBQWE7QUFDL0QsMEJBQTBCLG1CQUFtQixJQUFJLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3ZFLDhCQUE4QixrQkFBa0IsSUFBSSxtQkFBbUI7QUFDdkUsOEJBQThCLGtCQUFrQixJQUFJLG1CQUFtQjtBQUN2RSw4QkFBOEIsb0JBQW9CLElBQUkscUJBQXFCO0FBQzNFLDhCQUE4QixtQkFBbUIsSUFBSSxtQkFBbUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQixJQUFJLGlCQUFpQjtBQUN4RSxnQ0FBZ0Msa0JBQWtCLElBQUksa0JBQWtCO0FBQ3hFLGdDQUFnQyxrQkFBa0IsSUFBSSxrQkFBa0I7QUFDeEUsZ0NBQWdDLG9CQUFvQixJQUFJLG9CQUFvQjtBQUM1RSxnQ0FBZ0MsbUJBQW1CLElBQUksa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pELDBCQUEwQixrQkFBa0I7QUFDNUMsMEJBQTBCLGtCQUFrQjtBQUM1QywwQkFBMEIsb0JBQW9CO0FBQzlDLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0YXRzLmpzPzU3MzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgc3RhdGlzdGljcyBnYXRoZXJpbmcgb2JqZWN0LlxuLy8gVGhlIHN0YXRpc3RpY3MgYXJlIG5vdGhpbmcgbW9yZSB0aGFuIGtlZXBpbmcgYSBjb3VudCBvZiB0aGVcbi8vIG51bWJlciBvZiB0aW1lcyBlYWNoIG5vZGUgaW4gdGhlIHBhcnNlIHRyZWUgaXMgdHJhdmVyc2VkLlxuLy9cbi8vIENvdW50cyBhcmUgY29sbGVjdGVkIGZvciBlYWNoIG9mIHRoZSBpbmRpdmlkdWFsIHR5cGVzIG9mIG9wZXJhdG9ycy5cbi8vIEFkZGl0aW9uYWxseSwgY291bnRzIGFyZSBjb2xsZWN0ZWQgZm9yIGVhY2ggb2YgdGhlIGluZGl2aWR1YWxseSBuYW1lZFxuLy8gYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RhdHNGdW5jKCkge1xuICBjb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcbiAgY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpO1xuICBjb25zdCBzdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKTtcblxuICBjb25zdCB0aGlzRmlsZU5hbWUgPSAnc3RhdHMuanM6ICc7XG4gIGxldCBydWxlcyA9IFtdO1xuICBsZXQgdWR0cyA9IFtdO1xuICBjb25zdCBzdGF0cyA9IFtdO1xuICBsZXQgdG90YWxzO1xuICBjb25zdCBydWxlU3RhdHMgPSBbXTtcbiAgY29uc3QgdWR0U3RhdHMgPSBbXTtcbiAgdGhpcy5zdGF0c09iamVjdCA9ICdzdGF0c09iamVjdCc7XG4gIGNvbnN0IG5hbWVJZCA9ICdzdGF0cyc7XG4gIC8qIGBBcnJheS5zb3J0KClgIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgYWxwaGFiZXRpY2FsbHkgYnkgbmFtZS4gKi9cbiAgY29uc3Qgc29ydEFscGhhID0gZnVuY3Rpb24gc29ydEFscGhhKGxocywgcmhzKSB7XG4gICAgaWYgKGxocy5sb3dlciA8IHJocy5sb3dlcikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAobGhzLmxvd2VyID4gcmhzLmxvd2VyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIC8qIGBBcnJheS5zb3J0KClgIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgYnkgaGl0IGNvdW50LiAqL1xuICBjb25zdCBzb3J0SGl0cyA9IGZ1bmN0aW9uIHNvcnRIaXRzKGxocywgcmhzKSB7XG4gICAgaWYgKGxocy50b3RhbCA8IHJocy50b3RhbCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChsaHMudG90YWwgPiByaHMudG90YWwpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRBbHBoYShsaHMsIHJocyk7XG4gIH07XG4gIC8qIGBBcnJheS5zb3J0KClgIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgYnkgaW5kZXggKi9cbiAgLyogKGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhciBpbiB0aGUgU0FCTkYgZ3JhbW1hcikuICovXG4gIGNvbnN0IHNvcnRJbmRleCA9IGZ1bmN0aW9uIHNvcnRJbmRleChsaHMsIHJocykge1xuICAgIGlmIChsaHMuaW5kZXggPCByaHMuaW5kZXgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGxocy5pbmRleCA+IHJocy5pbmRleCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICBjb25zdCBFbXB0eVN0YXQgPSBmdW5jdGlvbiBFbXB0eVN0YXQoKSB7XG4gICAgdGhpcy5lbXB0eSA9IDA7XG4gICAgdGhpcy5tYXRjaCA9IDA7XG4gICAgdGhpcy5ub21hdGNoID0gMDtcbiAgICB0aGlzLnRvdGFsID0gMDtcbiAgfTtcbiAgLyogWmVybyBvdXQgYWxsIHN0YXRzICovXG4gIGNvbnN0IGNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgc3RhdHMubGVuZ3RoID0gMDtcbiAgICB0b3RhbHMgPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQUxUXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5DQVRdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlJFUF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuUk5NXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5UUkddID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLlRCU10gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuVExTXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5VRFRdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkFORF0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuTk9UXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5CS1JdID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkJLQV0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgc3RhdHNbaWQuQktOXSA9IG5ldyBFbXB0eVN0YXQoKTtcbiAgICBzdGF0c1tpZC5BQkddID0gbmV3IEVtcHR5U3RhdCgpO1xuICAgIHN0YXRzW2lkLkFFTl0gPSBuZXcgRW1wdHlTdGF0KCk7XG4gICAgcnVsZVN0YXRzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgcnVsZVN0YXRzLnB1c2goe1xuICAgICAgICBlbXB0eTogMCxcbiAgICAgICAgbWF0Y2g6IDAsXG4gICAgICAgIG5vbWF0Y2g6IDAsXG4gICAgICAgIHRvdGFsOiAwLFxuICAgICAgICBuYW1lOiBydWxlc1tpXS5uYW1lLFxuICAgICAgICBsb3dlcjogcnVsZXNbaV0ubG93ZXIsXG4gICAgICAgIGluZGV4OiBydWxlc1tpXS5pbmRleCxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICB1ZHRTdGF0cy5sZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHVkdFN0YXRzLnB1c2goe1xuICAgICAgICAgIGVtcHR5OiAwLFxuICAgICAgICAgIG1hdGNoOiAwLFxuICAgICAgICAgIG5vbWF0Y2g6IDAsXG4gICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgICAgbmFtZTogdWR0c1tpXS5uYW1lLFxuICAgICAgICAgIGxvd2VyOiB1ZHRzW2ldLmxvd2VyLFxuICAgICAgICAgIGluZGV4OiB1ZHRzW2ldLmluZGV4LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIGluY3JlbWVudCB0aGUgZGVzaWduYXRlZCBvcGVyYXRvciBoaXQgY291bnQgYnkgb25lICovXG4gIGNvbnN0IGluY1N0YXQgPSBmdW5jdGlvbiBpbmNTdGF0KHN0YXQsIHN0YXRlKSB7XG4gICAgc3RhdC50b3RhbCArPSAxO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgaWQuRU1QVFk6XG4gICAgICAgIHN0YXQuZW1wdHkgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGlkLk1BVENIOlxuICAgICAgICBzdGF0Lm1hdGNoICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgICBzdGF0Lm5vbWF0Y2ggKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNvbGxlY3QoKTogaW5jU3RhdCgpOiB1bnJlY29nbml6ZWQgc3RhdGU6ICR7c3RhdGV9YCk7XG4gICAgfVxuICB9O1xuICAvKiBoZWxwZXIgZm9yIHRvSHRtbCgpICovXG4gIGNvbnN0IGRpc3BsYXlSb3cgPSBmdW5jdGlvbiBkaXNwbGF5Um93KG5hbWUsIHN0YXQpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7bmFtZX08L3RkPmA7XG4gICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj4ke3N0YXQuZW1wdHl9PC90ZD5gO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JHtzdGF0Lm1hdGNofTwvdGQ+YDtcbiAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JHtzdGF0Lm5vbWF0Y2h9PC90ZD5gO1xuICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7c3RhdC50b3RhbH08L3RkPmA7XG4gICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICBjb25zdCBkaXNwbGF5T3BzT25seSA9IGZ1bmN0aW9uIGRpc3BsYXlPcHNPbmx5KCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdBTFQnLCBzdGF0c1tpZC5BTFRdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0NBVCcsIHN0YXRzW2lkLkNBVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnUkVQJywgc3RhdHNbaWQuUkVQXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdSTk0nLCBzdGF0c1tpZC5STk1dKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1RSRycsIHN0YXRzW2lkLlRSR10pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnVEJTJywgc3RhdHNbaWQuVEJTXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdUTFMnLCBzdGF0c1tpZC5UTFNdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ1VEVCcsIHN0YXRzW2lkLlVEVF0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQU5EJywgc3RhdHNbaWQuQU5EXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdOT1QnLCBzdGF0c1tpZC5OT1RdKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0JLUicsIHN0YXRzW2lkLkJLUl0pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQktBJywgc3RhdHNbaWQuQktBXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCdCS04nLCBzdGF0c1tpZC5CS05dKTtcbiAgICBodG1sICs9IGRpc3BsYXlSb3coJ0FCRycsIHN0YXRzW2lkLkFCR10pO1xuICAgIGh0bWwgKz0gZGlzcGxheVJvdygnQUVOJywgc3RhdHNbaWQuQUVOXSk7XG4gICAgaHRtbCArPSBkaXNwbGF5Um93KCd0b3RhbHMnLCB0b3RhbHMpO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBoZWxwZXIgZm9yIHRvSHRtbCgpICovXG4gIGNvbnN0IGRpc3BsYXlSdWxlcyA9IGZ1bmN0aW9uIGRpc3BsYXlSdWxlcygpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGh0bWwgKz0gJzx0cj48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgaHRtbCArPSAnPHRyPjx0aD5ydWxlczwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PC90cj5cXG4nO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChydWxlU3RhdHNbaV0udG90YWwgPiAwKSB7XG4gICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4ke3J1bGVTdGF0c1tpXS5uYW1lfTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj4ke3J1bGVTdGF0c1tpXS5lbXB0eX08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JHtydWxlU3RhdHNbaV0ubWF0Y2h9PC90ZD5gO1xuICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JHtydWxlU3RhdHNbaV0ubm9tYXRjaH08L3RkPmA7XG4gICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7cnVsZVN0YXRzW2ldLnRvdGFsfTwvdGQ+YDtcbiAgICAgICAgaHRtbCArPSAnPC90cj5cXG4nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodWR0cy5sZW5ndGggPiAwKSB7XG4gICAgICBodG1sICs9ICc8dHI+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PHRoPjwvdGg+PC90cj5cXG4nO1xuICAgICAgaHRtbCArPSAnPHRyPjx0aD51ZHRzPC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48dGg+PC90aD48L3RyPlxcbic7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVkdHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHVkdFN0YXRzW2ldLnRvdGFsID4gMCkge1xuICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7dWR0U3RhdHNbaV0ubmFtZX08L3RkPmA7XG4gICAgICAgICAgaHRtbCArPSBgPHRkIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj4ke3VkdFN0YXRzW2ldLmVtcHR5fTwvdGQ+YDtcbiAgICAgICAgICBodG1sICs9IGA8dGQgY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPiR7dWR0U3RhdHNbaV0ubWF0Y2h9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj4ke3VkdFN0YXRzW2ldLm5vbWF0Y2h9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gYDx0ZCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPiR7dWR0U3RhdHNbaV0udG90YWx9PC90ZD5gO1xuICAgICAgICAgIGh0bWwgKz0gJzwvdHI+XFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogY2FsbGVkIG9ubHkgYnkgdGhlIHBhcnNlciB0byB2YWxpZGF0ZSBhIHN0YXRzIG9iamVjdCAqL1xuICB0aGlzLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUobmFtZSkge1xuICAgIGxldCByZXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWVJZCA9PT0gbmFtZSkge1xuICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgLyogbm8gdmVyaWZpY2F0aW9uIG9mIGlucHV0IC0gb25seSBjYWxsZWQgYnkgcGFyc2VyKCkgKi9cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gaW5pdChpbnB1dFJ1bGVzLCBpbnB1dFVkdHMpIHtcbiAgICBydWxlcyA9IGlucHV0UnVsZXM7XG4gICAgdWR0cyA9IGlucHV0VWR0cztcbiAgICBjbGVhcigpO1xuICB9O1xuICAvKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSBtYWluIGludGVyYWN0aW9uIHdpdGggdGhlIHBhcnNlci4gKi9cbiAgLyogVGhlIHBhcnNlciBjYWxscyBpdCBhZnRlciBlYWNoIG5vZGUgaGFzIGJlZW4gdHJhdmVyc2VkLiAqL1xuICB0aGlzLmNvbGxlY3QgPSBmdW5jdGlvbiBjb2xsZWN0KG9wLCByZXN1bHQpIHtcbiAgICBpbmNTdGF0KHRvdGFscywgcmVzdWx0LnN0YXRlLCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICBpbmNTdGF0KHN0YXRzW29wLnR5cGVdLCByZXN1bHQuc3RhdGUsIHJlc3VsdC5waHJhc2VMZW5ndGgpO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5STk0pIHtcbiAgICAgIGluY1N0YXQocnVsZVN0YXRzW29wLmluZGV4XSwgcmVzdWx0LnN0YXRlLCByZXN1bHQucGhyYXNlTGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlVEVCkge1xuICAgICAgaW5jU3RhdCh1ZHRTdGF0c1tvcC5pbmRleF0sIHJlc3VsdC5zdGF0ZSwgcmVzdWx0LnBocmFzZUxlbmd0aCk7XG4gICAgfVxuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBzdGF0aXN0aWNzIGFzIGFuIEhUTUwgdGFibGUuXG4gIC8vIC0gKnR5cGUqXG4gIC8vICAgLSBcIm9wc1wiIC0gKGRlZmF1bHQpIGRpc3BsYXkgb25seSB0aGUgdG90YWwgaGl0IGNvdW50cyBmb3IgYWxsIG9wZXJhdG9yIHR5cGVzLlxuICAvLyAgIC0gXCJpbmRleFwiIC0gYWRkaXRpb25hbGx5LCBkaXNwbGF5IHRoZSBoaXQgY291bnRzIGZvciB0aGUgaW5kaXZpZHVhbCBgUk5NYCBhbmQgYFVEVGAgb3BlcmF0b3JzIG9yZGVyZWQgYnkgaW5kZXguXG4gIC8vICAgLSBcImhpdHNcIiAtIGFkZGl0aW9uYWxseSwgZGlzcGxheSB0aGUgaGl0IGNvdW50cyBmb3IgdGhlIGluZGl2aWR1YWwgYFJOTWAgYW5kIGBVRFRgIG9wZXJhdG9ycyBieSBoaXQgY291bnQuXG4gIC8vICAgLSBcImFscGhhXCIgLSBhZGRpdGlvbmFsbHksIGRpc3BsYXkgdGhlIGhpdCBjb3VudHMgZm9yIHRoZSBpbmRpdmlkdWFsIGBSTk1gIGFuZCBgVURUYCBvcGVyYXRvcnMgYnkgbmFtZSBhbHBoYWJldGljYWxseS5cbiAgLy8gLSAqY2FwdGlvbiogLSBvcHRpb25hbCBjYXB0aW9uIGZvciB0aGUgdGFibGVcbiAgdGhpcy50b0h0bWwgPSBmdW5jdGlvbiB0b0h0bWwodHlwZSwgY2FwdGlvbikge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSBgPHRhYmxlIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19TVEFUU31cIj5cXG5gO1xuICAgIGlmICh0eXBlb2YgY2FwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGh0bWwgKz0gYDxjYXB0aW9uPiR7Y2FwdGlvbn08L2NhcHRpb24+XFxuYDtcbiAgICB9XG4gICAgaHRtbCArPSBgPHRyPjx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQUNUSVZFfVwiPm9wczwvdGg+XFxuYDtcbiAgICBodG1sICs9IGA8dGggY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPkVNUFRZPC90aD5cXG5gO1xuICAgIGh0bWwgKz0gYDx0aCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+TUFUQ0g8L3RoPlxcbmA7XG4gICAgaHRtbCArPSBgPHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPk5PTUFUQ0g8L3RoPlxcbmA7XG4gICAgaHRtbCArPSBgPHRoIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19BQ1RJVkV9XCI+dG90YWxzPC90aD48L3RyPlxcbmA7XG4gICAgY29uc3QgdGVzdCA9IHRydWU7XG4gICAgd2hpbGUgKHRlc3QpIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU9wc09ubHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ29wcycpIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnaW5kZXgnKSB7XG4gICAgICAgIHJ1bGVTdGF0cy5zb3J0KHNvcnRJbmRleCk7XG4gICAgICAgIGlmICh1ZHRTdGF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdWR0U3RhdHMuc29ydChzb3J0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU9wc09ubHkoKTtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5UnVsZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2hpdHMnKSB7XG4gICAgICAgIHJ1bGVTdGF0cy5zb3J0KHNvcnRIaXRzKTtcbiAgICAgICAgaWYgKHVkdFN0YXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1ZHRTdGF0cy5zb3J0KHNvcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSBkaXNwbGF5T3BzT25seSgpO1xuICAgICAgICBodG1sICs9IGRpc3BsYXlSdWxlcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAnYWxwaGEnKSB7XG4gICAgICAgIHJ1bGVTdGF0cy5zb3J0KHNvcnRBbHBoYSk7XG4gICAgICAgIGlmICh1ZHRTdGF0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdWR0U3RhdHMuc29ydChzb3J0QWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheU9wc09ubHkoKTtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5UnVsZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaHRtbCArPSAnPC90YWJsZT5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvLyBEaXNwbGF5IHRoZSBzdGF0cyB0YWJsZSBpbiBhIGNvbXBsZXRlIEhUTUw1IHBhZ2UuXG4gIHRoaXMudG9IdG1sUGFnZSA9IGZ1bmN0aW9uIHRvSHRtbFBhZ2UodHlwZSwgY2FwdGlvbiwgdGl0bGUpIHtcbiAgICByZXR1cm4gdXRpbHMuaHRtbFRvUGFnZSh0aGlzLnRvSHRtbCh0eXBlLCBjYXB0aW9uKSwgdGl0bGUpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/stats.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/style.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/style.js ***!
  \**************************************************/
/***/ ((module) => {

eval("module.exports = {\n\n  // Generated by apglib/style.js \n  CLASS_MONOSPACE: 'apg-mono',\n  CLASS_ACTIVE: 'apg-active',\n  CLASS_EMPTY: 'apg-empty',\n  CLASS_MATCH: 'apg-match',\n  CLASS_NOMATCH: 'apg-nomatch',\n  CLASS_LOOKAHEAD: 'apg-lh-match',\n  CLASS_LOOKBEHIND: 'apg-lb-match',\n  CLASS_REMAINDER: 'apg-remainder',\n  CLASS_CTRLCHAR: 'apg-ctrl-char',\n  CLASS_LINEEND: 'apg-line-end',\n  CLASS_ERROR: 'apg-error',\n  CLASS_PHRASE: 'apg-phrase',\n  CLASS_EMPTYPHRASE: 'apg-empty-phrase',\n  CLASS_STATE: 'apg-state',\n  CLASS_STATS: 'apg-stats',\n  CLASS_TRACE: 'apg-trace',\n  CLASS_GRAMMAR: 'apg-grammar',\n  CLASS_RULES: 'apg-rules',\n  CLASS_RULESLINK: 'apg-rules-link',\n  CLASS_ATTRIBUTES: 'apg-attrs',\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3N0eWxlLmpzPzRhNTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLy8gR2VuZXJhdGVkIGJ5IGFwZ2xpYi9zdHlsZS5qcyBcbiAgQ0xBU1NfTU9OT1NQQUNFOiAnYXBnLW1vbm8nLFxuICBDTEFTU19BQ1RJVkU6ICdhcGctYWN0aXZlJyxcbiAgQ0xBU1NfRU1QVFk6ICdhcGctZW1wdHknLFxuICBDTEFTU19NQVRDSDogJ2FwZy1tYXRjaCcsXG4gIENMQVNTX05PTUFUQ0g6ICdhcGctbm9tYXRjaCcsXG4gIENMQVNTX0xPT0tBSEVBRDogJ2FwZy1saC1tYXRjaCcsXG4gIENMQVNTX0xPT0tCRUhJTkQ6ICdhcGctbGItbWF0Y2gnLFxuICBDTEFTU19SRU1BSU5ERVI6ICdhcGctcmVtYWluZGVyJyxcbiAgQ0xBU1NfQ1RSTENIQVI6ICdhcGctY3RybC1jaGFyJyxcbiAgQ0xBU1NfTElORUVORDogJ2FwZy1saW5lLWVuZCcsXG4gIENMQVNTX0VSUk9SOiAnYXBnLWVycm9yJyxcbiAgQ0xBU1NfUEhSQVNFOiAnYXBnLXBocmFzZScsXG4gIENMQVNTX0VNUFRZUEhSQVNFOiAnYXBnLWVtcHR5LXBocmFzZScsXG4gIENMQVNTX1NUQVRFOiAnYXBnLXN0YXRlJyxcbiAgQ0xBU1NfU1RBVFM6ICdhcGctc3RhdHMnLFxuICBDTEFTU19UUkFDRTogJ2FwZy10cmFjZScsXG4gIENMQVNTX0dSQU1NQVI6ICdhcGctZ3JhbW1hcicsXG4gIENMQVNTX1JVTEVTOiAnYXBnLXJ1bGVzJyxcbiAgQ0xBU1NfUlVMRVNMSU5LOiAnYXBnLXJ1bGVzLWxpbmsnLFxuICBDTEFTU19BVFRSSUJVVEVTOiAnYXBnLWF0dHJzJyxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/style.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/trace.js":
/*!**************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/trace.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\nmodule.exports = function exportTrace() {\n  const utils = __webpack_require__(/*! ./utilities */ \"(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\");\n  const style = __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\");\n  const circular = new (__webpack_require__(/*! ./circular-buffer */ \"(ssr)/./node_modules/apg-js/src/apg-lib/circular-buffer.js\"))();\n  const id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n\n  const thisFileName = 'trace.js: ';\n  const that = this;\n  const MODE_HEX = 16;\n  const MODE_DEC = 10;\n  const MODE_ASCII = 8;\n  const MODE_UNICODE = 32;\n  const MAX_PHRASE = 80;\n  const MAX_TLS = 5;\n  const records = [];\n  let maxRecords = 5000;\n  let lastRecord = -1;\n  let filteredRecords = 0;\n  let treeDepth = 0;\n  const recordStack = [];\n  let chars = null;\n  let rules = null;\n  let udts = null;\n  const operatorFilter = [];\n  const ruleFilter = [];\n  /* special trace table phrases */\n  const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n  const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n  const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n  /* filter the non-RNM & non-UDT operators */\n  const initOperatorFilter = function () {\n    const setOperators = function (set) {\n      operatorFilter[id.ALT] = set;\n      operatorFilter[id.CAT] = set;\n      operatorFilter[id.REP] = set;\n      operatorFilter[id.TLS] = set;\n      operatorFilter[id.TBS] = set;\n      operatorFilter[id.TRG] = set;\n      operatorFilter[id.AND] = set;\n      operatorFilter[id.NOT] = set;\n      operatorFilter[id.BKR] = set;\n      operatorFilter[id.BKA] = set;\n      operatorFilter[id.BKN] = set;\n      operatorFilter[id.ABG] = set;\n      operatorFilter[id.AEN] = set;\n    };\n    let items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.operators) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: no operators specified: default: do not trace any operators */\n      setOperators(false);\n      return;\n    }\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      if (upper === '<ALL>') {\n        /* case 2: <all> operators specified: trace all operators ignore all other operator commands */\n        setOperators(true);\n        return;\n      }\n      if (upper === '<NONE>') {\n        /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */\n        setOperators(false);\n        return;\n      }\n    }\n    setOperators(false);\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      /* case 4: one or more individual operators specified: trace 'true' operators only */\n      if (upper === 'ALT') {\n        operatorFilter[id.ALT] = that.filter.operators[name] === true;\n      } else if (upper === 'CAT') {\n        operatorFilter[id.CAT] = that.filter.operators[name] === true;\n      } else if (upper === 'REP') {\n        operatorFilter[id.REP] = that.filter.operators[name] === true;\n      } else if (upper === 'AND') {\n        operatorFilter[id.AND] = that.filter.operators[name] === true;\n      } else if (upper === 'NOT') {\n        operatorFilter[id.NOT] = that.filter.operators[name] === true;\n      } else if (upper === 'TLS') {\n        operatorFilter[id.TLS] = that.filter.operators[name] === true;\n      } else if (upper === 'TBS') {\n        operatorFilter[id.TBS] = that.filter.operators[name] === true;\n      } else if (upper === 'TRG') {\n        operatorFilter[id.TRG] = that.filter.operators[name] === true;\n      } else if (upper === 'BKR') {\n        operatorFilter[id.BKR] = that.filter.operators[name] === true;\n      } else if (upper === 'BKA') {\n        operatorFilter[id.BKA] = that.filter.operators[name] === true;\n      } else if (upper === 'BKN') {\n        operatorFilter[id.BKN] = that.filter.operators[name] === true;\n      } else if (upper === 'ABG') {\n        operatorFilter[id.ABG] = that.filter.operators[name] === true;\n      } else if (upper === 'AEN') {\n        operatorFilter[id.AEN] = that.filter.operators[name] === true;\n      } else {\n        throw new Error(\n          `${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` +\n            ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`\n        );\n      }\n    }\n  };\n  /* filter the rule and `UDT` named operators */\n  const initRuleFilter = function () {\n    const setRules = function (set) {\n      operatorFilter[id.RNM] = set;\n      operatorFilter[id.UDT] = set;\n      const count = rules.length + udts.length;\n      ruleFilter.length = 0;\n      for (let i = 0; i < count; i += 1) {\n        ruleFilter.push(set);\n      }\n    };\n    let items;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    ruleFilter.length = 0;\n    items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.rules) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: default to all rules & udts */\n      setRules(true);\n      return;\n    }\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      if (lower === '<all>') {\n        /* case 2: trace all rules ignore all other rule commands */\n        setRules(true);\n        return;\n      }\n      if (lower === '<none>') {\n        /* case 3: trace no rules */\n        setRules(false);\n        return;\n      }\n    }\n    /* case 4: trace only individually specified rules */\n    setRules(false);\n    operatorFilter[id.RNM] = true;\n    operatorFilter[id.UDT] = true;\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n      }\n      ruleFilter[i] = that.filter.rules[name] === true;\n    }\n  };\n  /* used by other APG components to verify that they have a valid trace object */\n  this.traceObject = 'traceObject';\n  this.filter = {\n    operators: [],\n    rules: [],\n  };\n  // Set the maximum number of records to keep (default = 5000).\n  // Each record number larger than `maxRecords`\n  // will result in deleting the previously oldest record.\n  // - `max`: maximum number of records to retain (default = 5000)\n  // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n  this.setMaxRecords = function (max, last) {\n    lastRecord = -1;\n    if (typeof max === 'number' && max > 0) {\n      maxRecords = Math.ceil(max);\n    } else {\n      maxRecords = 0;\n      return;\n    }\n    if (typeof last === 'number') {\n      lastRecord = Math.floor(last);\n      if (lastRecord < 0) {\n        lastRecord = -1;\n      }\n    }\n  };\n  // Returns `maxRecords` to the caller.\n  this.getMaxRecords = function () {\n    return maxRecords;\n  };\n  // Returns `lastRecord` to the caller.\n  this.getLastRecord = function () {\n    return lastRecord;\n  };\n  /* Called only by the `parser.js` object. No verification of input. */\n  this.init = function (rulesIn, udtsIn, charsIn) {\n    records.length = 0;\n    recordStack.length = 0;\n    filteredRecords = 0;\n    treeDepth = 0;\n    chars = charsIn;\n    rules = rulesIn;\n    udts = udtsIn;\n    initOperatorFilter();\n    initRuleFilter();\n    circular.init(maxRecords);\n  };\n  /* returns true if this records passes through the designated filter, false if the record is to be skipped */\n  const filterOps = function (op) {\n    let ret = false;\n    if (op.type === id.RNM) {\n      if (operatorFilter[op.type] && ruleFilter[op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else if (op.type === id.UDT) {\n      if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else {\n      ret = operatorFilter[op.type];\n    }\n    return ret;\n  };\n  const filterRecords = function (record) {\n    if (lastRecord === -1) {\n      return true;\n    }\n    if (record <= lastRecord) {\n      return true;\n    }\n    return false;\n  };\n  /* Collect the \"down\" record. */\n  this.down = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      recordStack.push(filteredRecords);\n      records[circular.increment()] = {\n        dirUp: false,\n        depth: treeDepth,\n        thisLine: filteredRecords,\n        thatLine: undefined,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n      treeDepth += 1;\n    }\n  };\n  /* Collect the \"up\" record. */\n  this.up = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      const thisLine = filteredRecords;\n      const thatLine = recordStack.pop();\n      const thatRecord = circular.getListIndex(thatLine);\n      if (thatRecord !== -1) {\n        records[thatRecord].thatLine = thisLine;\n      }\n      treeDepth -= 1;\n      records[circular.increment()] = {\n        dirUp: true,\n        depth: treeDepth,\n        thisLine,\n        thatLine,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n    }\n  };\n  /* convert the trace records to a tree of nodes */\n  const toTreeObj = function () {\n    /* private helper functions */\n    function nodeOpcode(node, opcode) {\n      let name;\n      let casetype;\n      let modetype;\n      if (opcode) {\n        node.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };\n        node.opData = undefined;\n        switch (opcode.type) {\n          case id.RNM:\n            node.opData = rules[opcode.index].name;\n            break;\n          case id.UDT:\n            node.opData = udts[opcode.index].name;\n            break;\n          case id.BKR:\n            if (opcode.index < rules.length) {\n              name = rules[opcode.index].name;\n            } else {\n              name = udts[opcode.index - rules.length].name;\n            }\n            casetype = opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n            modetype = opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n            node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n            break;\n          case id.TLS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TBS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TRG:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          case id.REP:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          default:\n            throw new Error('unrecognized opcode');\n        }\n      } else {\n        node.op = { id: undefined, name: undefined };\n        node.opData = undefined;\n      }\n    }\n    function nodePhrase(state, index, length) {\n      if (state === id.MATCH) {\n        return {\n          index,\n          length,\n        };\n      }\n      if (state === id.NOMATCH) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      if (state === id.EMPTY) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      return null;\n    }\n    let nodeId = -1;\n    function nodeDown(parent, record, depth) {\n      const node = {\n        // eslint-disable-next-line no-plusplus\n        id: nodeId++,\n        branch: -1,\n        parent,\n        up: false,\n        down: false,\n        depth,\n        children: [],\n      };\n      if (record) {\n        node.down = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = null;\n        nodeOpcode(node, record.opcode);\n      } else {\n        node.state = { id: undefined, name: undefined };\n        node.phrase = nodePhrase();\n        nodeOpcode(node, undefined);\n      }\n      return node;\n    }\n    function nodeUp(node, record) {\n      if (record) {\n        node.up = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n        if (!node.down) {\n          nodeOpcode(node, record.opcode);\n        }\n      }\n    }\n    /* walk the final tree: label branches and count leaf nodes */\n    let leafNodes = 0;\n    let depth = -1;\n    let branchCount = 1;\n    function walk(node) {\n      depth += 1;\n      node.branch = branchCount;\n      if (depth > treeDepth) {\n        treeDepth = depth;\n      }\n      if (node.children.length === 0) {\n        leafNodes += 1;\n      } else {\n        for (let i = 0; i < node.children.length; i += 1) {\n          if (i > 0) {\n            branchCount += 1;\n          }\n          node.children[i].leftMost = false;\n          node.children[i].rightMost = false;\n          if (node.leftMost) {\n            node.children[i].leftMost = i === 0;\n          }\n          if (node.rightMost) {\n            node.children[i].rightMost = i === node.children.length - 1;\n          }\n          walk(node.children[i]);\n        }\n      }\n      depth -= 1;\n    }\n    function display(node, offset) {\n      let name;\n      const obj = {};\n      obj.id = node.id;\n      obj.branch = node.branch;\n      obj.leftMost = node.leftMost;\n      obj.rightMost = node.rightMost;\n      name = node.state.name ? node.state.name : 'ACTIVE';\n      obj.state = { id: node.state.id, name };\n      name = node.op.name ? node.op.name : '?';\n      obj.op = { id: node.op.id, name };\n      if (typeof node.opData === 'string') {\n        obj.opData = node.opData;\n      } else if (Array.isArray(node.opData)) {\n        obj.opData = [];\n        for (let i = 0; i < node.opData.length; i += 1) {\n          obj.opData[i] = node.opData[i];\n        }\n      } else {\n        obj.opData = undefined;\n      }\n      if (node.phrase) {\n        obj.phrase = { index: node.phrase.index, length: node.phrase.length };\n      } else {\n        obj.phrase = null;\n      }\n      obj.depth = node.depth;\n      obj.children = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const c = i !== node.children.length - 1;\n        obj.children[i] = display(node.children[i], offset, c);\n      }\n      return obj;\n    }\n\n    /* construct the tree beginning here */\n    const branch = [];\n    let root;\n    let node;\n    let parent;\n    let record;\n    let firstRecord = true;\n    /* push a dummy node so the root node will have a non-null parent */\n    const dummy = nodeDown(null, null, -1);\n    branch.push(dummy);\n    node = dummy;\n    circular.forEach((lineIndex) => {\n      record = records[lineIndex];\n      if (firstRecord) {\n        firstRecord = false;\n        if (record.depth > 0) {\n          /* push some dummy nodes to fill in for missing records */\n          const num = record.dirUp ? record.depth + 1 : record.depth;\n          for (let i = 0; i < num; i += 1) {\n            parent = node;\n            node = nodeDown(node, null, i);\n            branch.push(node);\n            parent.children.push(node);\n          }\n        }\n      }\n      if (record.dirUp) {\n        /* handle the next record up */\n        node = branch.pop();\n        nodeUp(node, record);\n        node = branch[branch.length - 1];\n      } else {\n        /* handle the next record down */\n        parent = node;\n        node = nodeDown(node, record, record.depth);\n        branch.push(node);\n        parent.children.push(node);\n      }\n    });\n\n    /* if not at root, walk it up to root */\n    while (branch.length > 1) {\n      node = branch.pop();\n      nodeUp(node, null);\n    }\n    /* maybe redundant or paranoid tests: these should never happen */\n    if (dummy.children.length === 0) {\n      throw new Error('trace.toTree(): parse tree has no nodes');\n    }\n    if (branch.length === 0) {\n      throw new Error('trace.toTree(): integrity check: dummy root node disappeared?');\n    }\n\n    /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */\n    root = dummy.children[0];\n    let prev = root;\n    while (root && !root.down && !root.up) {\n      prev = root;\n      root = root.children[0];\n    }\n    root = prev;\n\n    /* walk the tree of nodes: label brances and count leaves */\n    root.leftMost = true;\n    root.rightMost = true;\n    walk(root);\n    root.branch = 0;\n\n    /* generate the exported object */\n    const obj = {};\n    obj.string = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      obj.string[i] = chars[i];\n    }\n    /* generate the exported rule names */\n    obj.rules = [];\n    for (let i = 0; i < rules.length; i += 1) {\n      obj.rules[i] = rules[i].name;\n    }\n    /* generate the exported UDT names */\n    obj.udts = [];\n    for (let i = 0; i < udts.length; i += 1) {\n      obj.udts[i] = udts[i].name;\n    }\n    /* generate the ids */\n    obj.id = {};\n    obj.id.ALT = { id: id.ALT, name: 'ALT' };\n    obj.id.CAT = { id: id.CAT, name: 'CAT' };\n    obj.id.REP = { id: id.REP, name: 'REP' };\n    obj.id.RNM = { id: id.RNM, name: 'RNM' };\n    obj.id.TLS = { id: id.TLS, name: 'TLS' };\n    obj.id.TBS = { id: id.TBS, name: 'TBS' };\n    obj.id.TRG = { id: id.TRG, name: 'TRG' };\n    obj.id.UDT = { id: id.UDT, name: 'UDT' };\n    obj.id.AND = { id: id.AND, name: 'AND' };\n    obj.id.NOT = { id: id.NOT, name: 'NOT' };\n    obj.id.BKR = { id: id.BKR, name: 'BKR' };\n    obj.id.BKA = { id: id.BKA, name: 'BKA' };\n    obj.id.BKN = { id: id.BKN, name: 'BKN' };\n    obj.id.ABG = { id: id.ABG, name: 'ABG' };\n    obj.id.AEN = { id: id.AEN, name: 'AEN' };\n    obj.id.ACTIVE = { id: id.ACTIVE, name: 'ACTIVE' };\n    obj.id.MATCH = { id: id.MATCH, name: 'MATCH' };\n    obj.id.EMPTY = { id: id.EMPTY, name: 'EMPTY' };\n    obj.id.NOMATCH = { id: id.NOMATCH, name: 'NOMATCH' };\n    /* generate the max tree depth */\n    obj.treeDepth = treeDepth;\n    /* generate the number of leaf nodes (branches) */\n    obj.leafNodes = leafNodes;\n    /* generate the types of the left- and right-most branches */\n    let branchesIncomplete;\n    if (root.down) {\n      if (root.up) {\n        branchesIncomplete = 'none';\n      } else {\n        branchesIncomplete = 'right';\n      }\n    } else if (root.up) {\n      branchesIncomplete = 'left';\n    } else {\n      branchesIncomplete = 'both';\n    }\n    obj.branchesIncomplete = branchesIncomplete;\n    obj.tree = display(root, root.depth, false);\n    return obj;\n  };\n  // Returns the trace records as JSON parse tree object.\n  // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n  this.toTree = function (stringify) {\n    const obj = toTreeObj();\n    if (stringify) {\n      return JSON.stringify(obj);\n    }\n    return obj;\n  };\n  // Translate the trace records to HTML format and create a complete HTML page for browser display.\n  this.toHtmlPage = function (mode, caption, title) {\n    return utils.htmlToPage(this.toHtml(mode, caption), title);\n  };\n\n  /* From here on down, these are just helper functions for `toHtml()`. */\n  const htmlHeader = function (mode, caption) {\n    /* open the page */\n    /* write the HTML5 header with table style */\n    /* open the <table> tag */\n    let modeName;\n    switch (mode) {\n      case MODE_HEX:\n        modeName = 'hexadecimal';\n        break;\n      case MODE_DEC:\n        modeName = 'decimal';\n        break;\n      case MODE_ASCII:\n        modeName = 'ASCII';\n        break;\n      case MODE_UNICODE:\n        modeName = 'UNICODE';\n        break;\n      default:\n        throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n    }\n    let header = '';\n    header += `<p>display mode: ${modeName}</p>\\n`;\n    header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n    if (typeof caption === 'string') {\n      header += `<caption>${caption}</caption>`;\n    }\n    return header;\n  };\n  const htmlFooter = function () {\n    let footer = '';\n    /* close the </table> tag */\n    footer += '</table>\\n';\n    /* display a table legend */\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n    footer += '(a)&nbsp;-&nbsp;line number<br>\\n';\n    footer += '(b)&nbsp;-&nbsp;matching line number<br>\\n';\n    footer += '(c)&nbsp;-&nbsp;phrase offset<br>\\n';\n    footer += '(d)&nbsp;-&nbsp;phrase length<br>\\n';\n    footer += '(e)&nbsp;-&nbsp;tree depth<br>\\n';\n    footer += '(f)&nbsp;-&nbsp;operator state<br>\\n';\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n    footer +=\n      'operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n';\n    footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n    footer += '</p>\\n';\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n    footer += '<sup>&dagger;</sup>original ABNF operators:<br>\\n';\n    footer += 'ALT - alternation<br>\\n';\n    footer += 'CAT - concatenation<br>\\n';\n    footer += 'REP - repetition<br>\\n';\n    footer += 'RNM - rule name<br>\\n';\n    footer += 'TRG - terminal range<br>\\n';\n    footer += 'TLS - terminal literal string (case insensitive)<br>\\n';\n    footer += 'TBS - terminal binary string (case sensitive)<br>\\n';\n    footer += '<br>\\n';\n    footer += '<sup>&Dagger;</sup>super set SABNF operators:<br>\\n';\n    footer += 'UDT - user-defined terminal<br>\\n';\n    footer += 'AND - positive look ahead<br>\\n';\n    footer += 'NOT - negative look ahead<br>\\n';\n    footer += 'BKA - positive look behind<br>\\n';\n    footer += 'BKN - negative look behind<br>\\n';\n    footer += 'BKR - back reference<br>\\n';\n    footer += 'ABG - anchor - begin of input string<br>\\n';\n    footer += 'AEN - anchor - end of input string<br>\\n';\n    footer += '</p>\\n';\n    return footer;\n  };\n  this.indent = function (depth) {\n    let html = '';\n    for (let i = 0; i < depth; i += 1) {\n      html += '.';\n    }\n    return html;\n  };\n  /* format the TRG operator */\n  const displayTrg = function (mode, op) {\n    let html = '';\n    if (op.type === id.TRG) {\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        html += hex;\n        hex = op.max.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += `&ndash;${hex}`;\n      } else {\n        html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      }\n    }\n    return html;\n  };\n  /* format the REP operator */\n  const displayRep = function (mode, op) {\n    let html = '';\n    if (op.type === id.REP) {\n      if (mode === MODE_HEX) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html = `x${hex}`;\n        if (op.max < Infinity) {\n          hex = op.max.toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n        } else {\n          hex = 'inf';\n        }\n        html += `&ndash;${hex}`;\n      } else if (op.max < Infinity) {\n        html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      } else {\n        html = `${op.min.toString(10)}&ndash;inf`;\n      }\n    }\n    return html;\n  };\n  /* format the TBS operator */\n  const displayTbs = function (mode, op) {\n    let html = '';\n    if (op.type === id.TBS) {\n      const len = Math.min(op.string.length, MAX_TLS * 2);\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        for (let i = 0; i < len; i += 1) {\n          let hex;\n          if (i > 0) {\n            html += '.';\n          }\n          hex = op.string[i].toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n          html += hex;\n        }\n      } else {\n        html = '%d';\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          html += op.string[i].toString(10);\n        }\n      }\n      if (len < op.string.length) {\n        html += PHRASE_CONTINUE;\n      }\n    }\n    return html;\n  };\n  /* format the TLS operator */\n  const displayTls = function (mode, op) {\n    let html = '';\n    if (op.type === id.TLS) {\n      const len = Math.min(op.string.length, MAX_TLS);\n      if (mode === MODE_HEX || mode === MODE_DEC) {\n        let charu;\n        let charl;\n        let base;\n        if (mode === MODE_HEX) {\n          html = '%x';\n          base = 16;\n        } else {\n          html = '%d';\n          base = 10;\n        }\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          charl = op.string[i];\n          if (charl >= 97 && charl <= 122) {\n            charu = charl - 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else if (charl >= 65 && charl <= 90) {\n            charu = charl;\n            charl += 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else {\n            html += charl.toString(base).toUpperCase();\n          }\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n      } else {\n        html = '\"';\n        for (let i = 0; i < len; i += 1) {\n          html += utils.asciiChars[op.string[i]];\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n        html += '\"';\n      }\n    }\n    return html;\n  };\n  const subPhrase = function (mode, charsArg, index, length, prev) {\n    if (length === 0) {\n      return '';\n    }\n    let phrase = '';\n    const comma = prev ? ',' : '';\n    switch (mode) {\n      case MODE_HEX:\n        phrase = comma + utils.charsToHex(charsArg, index, length);\n        break;\n      case MODE_DEC:\n        if (prev) {\n          return `,${utils.charsToDec(charsArg, index, length)}`;\n        }\n        phrase = comma + utils.charsToDec(charsArg, index, length);\n        break;\n      case MODE_UNICODE:\n        phrase = utils.charsToUnicode(charsArg, index, length);\n        break;\n      case MODE_ASCII:\n      default:\n        phrase = utils.charsToAsciiHtml(charsArg, index, length);\n        break;\n    }\n    return phrase;\n  };\n  /* display phrases matched in look-behind mode */\n  const displayBehind = function (mode, charsArg, state, index, length, anchor) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.MATCH:\n      case id.ACTIVE:\n        beg1 = index - length;\n        len1 = anchor - beg1;\n        beg2 = anchor;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanBehind;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  const displayForward = function (mode, charsArg, state, index, length, spanAhead) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.ACTIVE:\n        beg1 = index;\n        len1 = 0;\n        beg2 = index;\n        len2 = charsArg.length - beg2;\n        break;\n      case id.MATCH:\n        beg1 = index;\n        len1 = length;\n        beg2 = index + len1;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanAhead;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  /* display phrases matched in look-ahead mode */\n  const displayAhead = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* display phrases matched in normal parsing mode */\n  const displayNone = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* Returns the filtered records, formatted as an HTML table. */\n  const htmlTable = function (mode) {\n    if (rules === null) {\n      return '';\n    }\n    let html = '';\n    let thisLine;\n    let thatLine;\n    let lookAhead;\n    let lookBehind;\n    let lookAround;\n    let anchor;\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    circular.forEach((lineIndex) => {\n      const line = records[lineIndex];\n      thisLine = line.thisLine;\n      thatLine = line.thatLine !== undefined ? line.thatLine : '--';\n      lookAhead = false;\n      lookBehind = false;\n      lookAround = false;\n      if (line.lookAround === id.LOOKAROUND_AHEAD) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      if (line.lookAround === id.LOOKAROUND_BEHIND) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      html += '<tr>';\n      html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n      html += `<td>${line.phraseIndex}</td>`;\n      html += `<td>${line.phraseLength}</td>`;\n      html += `<td>${line.depth}</td>`;\n      html += '<td>';\n      switch (line.state) {\n        case id.ACTIVE:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n          break;\n        case id.MATCH:\n          html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n          break;\n        case id.NOMATCH:\n          html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n          break;\n        case id.EMPTY:\n          html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n          break;\n        default:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n          break;\n      }\n      html += '</td>';\n      html += '<td>';\n      html += that.indent(line.depth);\n      if (lookAhead) {\n        html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n      } else if (lookBehind) {\n        html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n      }\n      html += utils.opcodeToString(line.opcode.type);\n      if (line.opcode.type === id.RNM) {\n        html += `(${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.BKR) {\n        const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n        const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n        html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.UDT) {\n        html += `(${udts[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.TRG) {\n        html += `(${displayTrg(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TBS) {\n        html += `(${displayTbs(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TLS) {\n        html += `(${displayTls(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.REP) {\n        html += `(${displayRep(mode, line.opcode)}) `;\n      }\n      if (lookAround) {\n        html += '</span>';\n      }\n      html += '</td>';\n      html += '<td>';\n      if (lookBehind) {\n        html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n      } else if (lookAhead) {\n        html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      } else {\n        html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      }\n      html += '</td></tr>\\n';\n    });\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    html += '</table>\\n';\n    return html;\n  };\n  // Translate the trace records to HTML format.\n  // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n  // Determines the format of the string character code display.\n  // - *caption* - optional caption for the HTML table.\n  this.toHtml = function (modearg, caption) {\n    /* writes the trace records as a table in a complete html page */\n    let mode = MODE_ASCII;\n    if (typeof modearg === 'string' && modearg.length >= 3) {\n      const modein = modearg.toLowerCase().slice(0, 3);\n      if (modein === 'hex') {\n        mode = MODE_HEX;\n      } else if (modein === 'dec') {\n        mode = MODE_DEC;\n      } else if (modein === 'uni') {\n        mode = MODE_UNICODE;\n      }\n    }\n    let html = '';\n    html += htmlHeader(mode, caption);\n    html += htmlTable(mode);\n    html += htmlFooter();\n    return html;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3RyYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFtQjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsNkVBQWU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CLFFBQVE7QUFDakUsMENBQTBDLG9CQUFvQixVQUFVO0FBQ3hFLHVDQUF1QyxrQkFBa0IsV0FBVztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3RyYWNlLmpzPzZhZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgIGNvcHlyaWdodDogQ29weXJpZ2h0IChjKSAyMDIxIExvd2VsbCBELiBUaG9tYXMsIGFsbCByaWdodHMgcmVzZXJ2ZWRcbiAqICAgICBsaWNlbnNlOiBCU0QtMi1DbGF1c2UgKGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTItQ2xhdXNlKVxuICogICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8vIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgbWVhbnMgb2YgdHJhY2luZyB0aGUgcGFyc2VyIHRocm91Z2ggdGhlIHBhcnNlIHRyZWUgYXMgaXQgZ29lcy5cbi8vIEl0IGlzIHRoZSBwcmltYXJ5IGRlYnVnZ2luZyBmYWNpbGl0eSBmb3IgZGVidWdnaW5nIGJvdGggdGhlIFNBQk5GIGdyYW1tYXIgc3ludGF4XG4vLyBhbmQgdGhlIGlucHV0IHN0cmluZ3MgdGhhdCBhcmUgc3VwcG9zZWQgdG8gYmUgdmFsaWQgZ3JhbW1hciBzZW50ZW5jZXMuXG4vLyBJdCBpcyBhbHNvIGEgdmVyeSBpbmZvcm1hdGl2ZSBhbmQgZWR1Y2F0aW9uYWwgdG9vbCBmb3IgdW5kZXJzdGFuZGluZ1xuLy8gaG93IGEgcGFyc2VyIGFjdHVhbGx5IG9wZXJhdGVzIGZvciBhIGdpdmVuIGxhbmd1YWdlLlxuLy9cbi8vIFRyYWNpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgZ2VuZXJhdGluZyBhbmQgc2F2aW5nIGEgcmVjb3JkIG9mIGluZm9ybWF0aW9uIGZvciBlYWNoIHBhc3NhZ2Vcbi8vIG9mIHRoZSBwYXJzZXIgdGhyb3VnaCBhIHBhcnNlIHRyZWUgbm9kZS4gQW5kIHNpbmNlIGl0IHRyYXZlcnNlcyBlYWNoIG5vZGUgdHdpY2UsIG9uY2UgZG93biB0aGUgdHJlZVxuLy8gYW5kIG9uY2UgY29taW5nIGJhY2sgdXAsIHRoZXJlIGFyZSB0d28gcmVjb3JkcyBmb3IgZWFjaCBub2RlLlxuLy8gVGhpcywgb2J2aW91c2x5LCBoYXMgdGhlIHBvdGVudGlhbCBvZiBnZW5lcmF0aW5nIGxvdHMgb2YgcmVjb3Jkcy5cbi8vIEFuZCBzaW5jZSB0aGVzZSByZWNvcmRzIGFyZSBub3JtYWxseSBkaXNwbGF5ZWQgb24gYSB3ZWIgcGFnZVxuLy8gaXQgaXMgaW1wb3J0YW50IHRvIGhhdmUgYSBtZWFucyB0byBsaW1pdCB0aGUgYWN0dWFsIG51bWJlciBvZiByZWNvcmRzIGdlbmVyYXRlZCB0b1xuLy8gcHJvYmFibHkgbm8gbW9yZSB0aGF0IGEgZmV3IHRob3VzYW5kLiBUaGlzIGlzIGFsbW9zdCBhbHdheXMgZW5vdWdoIHRvIGZpbmQgYW55IGVycm9ycy5cbi8vIFRoZSBwcm9ibGVtIGlzIHRvIGdldCB0aGUgKnJpZ2h0KiBmZXcgdGhvdXNhbmQgcmVjb3Jkcy5cbi8vIFRoZXJlZm9yZSwgdGhpcyBtb2R1bGUgaGFzIGEgbnVtYmVyIG9mIHdheXMgb2YgbGltaXRpbmcgYW5kL29yIGZpbHRlcmluZywgdGhlIG51bWJlciBhbmQgdHlwZSBvZiByZWNvcmRzLlxuLy8gQ29uc2lkZXJhYmxlIGVmZm9ydCBoYXMgYmVlbiBtYWRlIHRvIG1ha2UgdGhpcyBmaWx0ZXJpbmcgb2YgdGhlIHRyYWNlIG91dHB1dCBhcyBzaW1wbGVcbi8vIGFuZCBpbnR1aXRpdmUgYXMgcG9zc2libGUuXG4vL1xuLy8gSG93ZXZlciwgdGhlIGFiaWxpdHkgdG8gZmlsdGVyIHRoZSB0cmFjZSByZWNvcmRzLCBvciBmb3IgdGhhdCBtYXR0ZXIgZXZlbiB1bmRlcnN0YW5kIHdoYXQgdGhleSBhcmVcbi8vIGFuZCB0aGUgaW5mb3JtYXRpb24gdGhleSBjb250YWluLCBkb2VzIHJlcXVpcmUgYSBtaW5pbXVtIGFtb3VudCBvZiB1bmRlcnN0YW5kaW5nIG9mIHRoZSBBUEcgcGFyc2luZ1xuLy8gbWV0aG9kLiBUaGUgcGFyc2UgdHJlZSBub2RlcyBhcmUgYWxsIHJlcHJlc2VudGVkIGJ5IEFQRyBvcGVyYXRvcnMuIFRoZXkgYnJlYWsgZG93biBpbnRvIHR3byBuYXR1cmFsIGdyb3Vwcy5cbi8vIC0gVGhlIGBSTk1gIG9wZXJhdG9ycyBhbmQgYFVEVGAgb3BlcmF0b3JzIGFyZSBuYW1lZCBwaHJhc2VzLlxuLy8gVGhlc2UgYXJlIG5hbWVzIGNob3NlbiBieSB0aGUgd3JpdGVyIG9mIHRoZSBTQUJORiBncmFtbWFyIHRvIHJlcHJlc2VudCBzcGVjaWFsIHBocmFzZXMgb2YgaW50ZXJlc3QuXG4vLyAtIEFsbCBvdGhlcnMgY29sbGVjdCwgY29uY2F0ZW5hdGUgYW5kIG90aGVyd2lzZSBtYW5pcHVsYXRlIHZhcmlvdXMgaW50ZXJtZWRpYXRlIHBocmFzZXMgYWxvbmcgdGhlIHdheS5cbi8vXG4vLyBUaGVyZSBhcmUgc2VwYXJhdGUgbWVhbnMgb2YgZmlsdGVyaW5nIHdoaWNoIG9mIHRoZXNlIG9wZXJhdG9ycyBpbiBlYWNoIG9mIHRoZXNlIHR3byBncm91cHMgZ2V0IHRyYWNlZC5cbi8vIExldCBgdHJhY2VgIGJlIGFuIGluc3RhbnRpYXRlZCBgdHJhY2UuanNgIG9iamVjdC5cbi8vIFByaW9yIHRvIHBhcnNpbmcgdGhlIHN0cmluZywgZmlsdGVyaW5nIHRoZSBydWxlcyBhbmQgVURUcyBjYW4gYmUgZGVmaW5lZCBhcyBmb2xsb3dzOlxuLy8gYGBgXG4vLyB0cmFjZS5maWx0ZXIucnVsZXNbXCJydWxlbmFtZVwiXSA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgcnVsZSBuYW1lIFwicnVsZW5hbWVcIiAqL1xuLy8gdHJhY2UuZmlsdGVyLnJ1bGVzW1widWR0bmFtZVwiXSAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIFVEVCBuYW1lIFwidWR0bmFtZVwiICovXG4vLyB0cmFjZS5maWx0ZXIucnVsZXNbXCI8QUxMPlwiXSAgICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgYWxsIHJ1bGVzIGFuZCBVRFRzICh0aGUgZGVmYXVsdCkgKi9cbi8vIHRyYWNlLmZpbHRlci5ydWxlc1tcIjxOT05FPlwiXSAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBubyBydWxlcyBvciBVRFRTICovXG4vLyBgYGBcbi8vIElmIGFueSBydWxlIG9yIFVEVCBuYW1lIG90aGVyIHRoYW4gXCImbHQ7QUxMPlwiIG9yIFwiJmx0O05PTkU+XCIgaXMgc3BlY2lmaWVkLCBhbGwgb3RoZXIgbmFtZXMgYXJlIHR1cm5lZCBvZmYuXG4vLyBUaGVyZWZvcmUsIHRvIGJlIHNlbGVjdGl2ZSBvZiBydWxlIG5hbWVzLCBhIGZpbHRlciBzdGF0ZW1lbnQgaXMgcmVxdWlyZWQgZm9yIGVhY2ggcnVsZS9VRFQgbmFtZSBkZXNpcmVkLlxuLy9cbi8vIEZpbHRlcmluZyBvZiB0aGUgb3RoZXIgb3BlcmF0b3JzIGZvbGxvd3MgYSBzaW1pbGFyIHByb2NlZHVyZS5cbi8vIGBgYFxuLy8gdHJhY2UuZmlsdGVyLm9wZXJhdG9yc1tcIlRSR1wiXSA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgdGhlIHRlcm1pbmFsIHJhbmdlLCBUUkcsIG9wZXJhdG9ycyAqL1xuLy8gdHJhY2UuZmlsdGVyLm9wZXJhdG9yc1tcIkNBVFwiXSAgPSB0cnVlO1xuLy8gICAgIC8qIHRyYWNlIHRoZSBjb25jYXRlbmF0aW9ucywgQ0FULCBvcGVyYXRvcnMgKi9cbi8vIHRyYWNlLmZpbHRlci5vcGVyYXRvcnNbXCI8QUxMPlwiXSAgICA9IHRydWU7XG4vLyAgICAgLyogdHJhY2UgYWxsIG9wZXJhdG9ycyAqL1xuLy8gdHJhY2UuZmlsdGVyLm9wZXJhdG9yc1tcIjxOT05FPlwiXSAgID0gdHJ1ZTtcbi8vICAgICAvKiB0cmFjZSBubyBvcGVyYXRvcnMgKHRoZSBkZWZhdWx0KSAqL1xuLy8gYGBgXG4vLyBJZiBhbnkgb3BlcmF0b3IgbmFtZSBvdGhlciB0aGFuIFwiJmx0O0FMTD5cIiBvciBcIiZsdDtOT05FPlwiIGlzIHNwZWNpZmllZCwgYWxsIG90aGVyIG5hbWVzIGFyZSB0dXJuZWQgb2ZmLlxuLy8gVGhlcmVmb3JlLCB0byBiZSBzZWxlY3RpdmUgb2Ygb3BlcmF0b3IgbmFtZXMsIGEgZmlsdGVyIHN0YXRlbWVudCBpcyByZXF1aXJlZCBmb3IgZWFjaCBuYW1lIGRlc2lyZWQuXG4vL1xuLy8gVGhlcmUgaXMsIGFkZGl0aW9uYWxseSwgYSBtZWFucyBmb3IgbGltaXRpbmcgdGhlIHRvdGFsIG51bWJlciBvZiBmaWx0ZXJlZCBvciBzYXZlZCB0cmFjZSByZWNvcmRzLlxuLy8gU2VlIHRoZSBmdW5jdGlvbiwgYHNldE1heFJlY29yZHMobWF4KWAgYmVsb3cuIFRoaXMgd2lsbCByZXN1bHQgaW4gb25seSB0aGUgbGFzdCBgbWF4YCByZWNvcmRzIGJlaW5nIHNhdmVkLlxuLy9cbi8vIChTZWUgW2BhcGctZXhhbXBsZXNgXShodHRwczovL2dpdGh1Yi5jb20vbGR0aG9tYXMvYXBnLWpzLWV4YW1wbGVzKSBmb3IgZXhhbXBsZXMgb2YgdXNpbmcgYHRyYWNlLmpzYC4pXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cG9ydFRyYWNlKCkge1xuICBjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJyk7XG4gIGNvbnN0IHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuICBjb25zdCBjaXJjdWxhciA9IG5ldyAocmVxdWlyZSgnLi9jaXJjdWxhci1idWZmZXInKSkoKTtcbiAgY29uc3QgaWQgPSByZXF1aXJlKCcuL2lkZW50aWZpZXJzJyk7XG5cbiAgY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3RyYWNlLmpzOiAnO1xuICBjb25zdCB0aGF0ID0gdGhpcztcbiAgY29uc3QgTU9ERV9IRVggPSAxNjtcbiAgY29uc3QgTU9ERV9ERUMgPSAxMDtcbiAgY29uc3QgTU9ERV9BU0NJSSA9IDg7XG4gIGNvbnN0IE1PREVfVU5JQ09ERSA9IDMyO1xuICBjb25zdCBNQVhfUEhSQVNFID0gODA7XG4gIGNvbnN0IE1BWF9UTFMgPSA1O1xuICBjb25zdCByZWNvcmRzID0gW107XG4gIGxldCBtYXhSZWNvcmRzID0gNTAwMDtcbiAgbGV0IGxhc3RSZWNvcmQgPSAtMTtcbiAgbGV0IGZpbHRlcmVkUmVjb3JkcyA9IDA7XG4gIGxldCB0cmVlRGVwdGggPSAwO1xuICBjb25zdCByZWNvcmRTdGFjayA9IFtdO1xuICBsZXQgY2hhcnMgPSBudWxsO1xuICBsZXQgcnVsZXMgPSBudWxsO1xuICBsZXQgdWR0cyA9IG51bGw7XG4gIGNvbnN0IG9wZXJhdG9yRmlsdGVyID0gW107XG4gIGNvbnN0IHJ1bGVGaWx0ZXIgPSBbXTtcbiAgLyogc3BlY2lhbCB0cmFjZSB0YWJsZSBwaHJhc2VzICovXG4gIGNvbnN0IFBIUkFTRV9FTkQgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xJTkVFTkR9XCI+JmJ1bGw7PC9zcGFuPmA7XG4gIGNvbnN0IFBIUkFTRV9DT05USU5VRSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTElORUVORH1cIj4maGVsbGlwOzwvc3Bhbj5gO1xuICBjb25zdCBQSFJBU0VfRU1QVFkgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPiYjMTIwNjM0Ozwvc3Bhbj5gO1xuICAvKiBmaWx0ZXIgdGhlIG5vbi1STk0gJiBub24tVURUIG9wZXJhdG9ycyAqL1xuICBjb25zdCBpbml0T3BlcmF0b3JGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2V0T3BlcmF0b3JzID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUxUXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkNBVF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5SRVBdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVExTXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRCU10gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5UUkddID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQU5EXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLk5PVF0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5CS1JdID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktBXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLTl0gPSBzZXQ7XG4gICAgICBvcGVyYXRvckZpbHRlcltpZC5BQkddID0gc2V0O1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQUVOXSA9IHNldDtcbiAgICB9O1xuICAgIGxldCBpdGVtcyA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLm9wZXJhdG9ycykge1xuICAgICAgaXRlbXMgKz0gMTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zID09PSAwKSB7XG4gICAgICAvKiBjYXNlIDE6IG5vIG9wZXJhdG9ycyBzcGVjaWZpZWQ6IGRlZmF1bHQ6IGRvIG5vdCB0cmFjZSBhbnkgb3BlcmF0b3JzICovXG4gICAgICBzZXRPcGVyYXRvcnMoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhhdC5maWx0ZXIub3BlcmF0b3JzKSB7XG4gICAgICBjb25zdCB1cHBlciA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICh1cHBlciA9PT0gJzxBTEw+Jykge1xuICAgICAgICAvKiBjYXNlIDI6IDxhbGw+IG9wZXJhdG9ycyBzcGVjaWZpZWQ6IHRyYWNlIGFsbCBvcGVyYXRvcnMgaWdub3JlIGFsbCBvdGhlciBvcGVyYXRvciBjb21tYW5kcyAqL1xuICAgICAgICBzZXRPcGVyYXRvcnModHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciA9PT0gJzxOT05FPicpIHtcbiAgICAgICAgLyogY2FzZSAzOiA8bm9uZT4gb3BlcmF0b3JzIHNwZWNpZmllZDogdHJhY2UgTk8gb3BlcmF0b3JzIGlnbm9yZSBhbGwgb3RoZXIgb3BlcmF0b3IgY29tbWFuZHMgKi9cbiAgICAgICAgc2V0T3BlcmF0b3JzKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRPcGVyYXRvcnMoZmFsc2UpO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGF0LmZpbHRlci5vcGVyYXRvcnMpIHtcbiAgICAgIGNvbnN0IHVwcGVyID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgLyogY2FzZSA0OiBvbmUgb3IgbW9yZSBpbmRpdmlkdWFsIG9wZXJhdG9ycyBzcGVjaWZpZWQ6IHRyYWNlICd0cnVlJyBvcGVyYXRvcnMgb25seSAqL1xuICAgICAgaWYgKHVwcGVyID09PSAnQUxUJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5BTFRdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0NBVCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQ0FUXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdSRVAnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlJFUF0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQU5EJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5BTkRdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ05PVCcpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuTk9UXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdUTFMnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlRMU10gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnVEJTJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5UQlNdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ1RSRycpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuVFJHXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdCS1InKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkJLUl0gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQktBJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5CS0FdID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1cHBlciA9PT0gJ0JLTicpIHtcbiAgICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuQktOXSA9IHRoYXQuZmlsdGVyLm9wZXJhdG9yc1tuYW1lXSA9PT0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodXBwZXIgPT09ICdBQkcnKSB7XG4gICAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLkFCR10gPSB0aGF0LmZpbHRlci5vcGVyYXRvcnNbbmFtZV0gPT09IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHVwcGVyID09PSAnQUVOJykge1xuICAgICAgICBvcGVyYXRvckZpbHRlcltpZC5BRU5dID0gdGhhdC5maWx0ZXIub3BlcmF0b3JzW25hbWVdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAke3RoaXNGaWxlTmFtZX1pbml0T3ByYXRvckZpbHRlcjogJyR7bmFtZX0nIG5vdCBhIHZhbGlkIG9wZXJhdG9yIG5hbWUuYCArXG4gICAgICAgICAgICBgIE11c3QgYmUgPGFsbD4sIDxub25lPiwgYWx0LCBjYXQsIHJlcCwgdGxzLCB0YnMsIHRyZywgYW5kLCBub3QsIGJrciwgYmthIG9yIGJrbmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIGZpbHRlciB0aGUgcnVsZSBhbmQgYFVEVGAgbmFtZWQgb3BlcmF0b3JzICovXG4gIGNvbnN0IGluaXRSdWxlRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNldFJ1bGVzID0gZnVuY3Rpb24gKHNldCkge1xuICAgICAgb3BlcmF0b3JGaWx0ZXJbaWQuUk5NXSA9IHNldDtcbiAgICAgIG9wZXJhdG9yRmlsdGVyW2lkLlVEVF0gPSBzZXQ7XG4gICAgICBjb25zdCBjb3VudCA9IHJ1bGVzLmxlbmd0aCArIHVkdHMubGVuZ3RoO1xuICAgICAgcnVsZUZpbHRlci5sZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHJ1bGVGaWx0ZXIucHVzaChzZXQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGl0ZW1zO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxpc3QucHVzaChydWxlc1tpXS5sb3dlcik7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB1ZHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsaXN0LnB1c2godWR0c1tpXS5sb3dlcik7XG4gICAgfVxuICAgIHJ1bGVGaWx0ZXIubGVuZ3RoID0gMDtcbiAgICBpdGVtcyA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLnJ1bGVzKSB7XG4gICAgICBpdGVtcyArPSAxO1xuICAgIH1cbiAgICBpZiAoaXRlbXMgPT09IDApIHtcbiAgICAgIC8qIGNhc2UgMTogZGVmYXVsdCB0byBhbGwgcnVsZXMgJiB1ZHRzICovXG4gICAgICBzZXRSdWxlcyh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLnJ1bGVzKSB7XG4gICAgICBjb25zdCBsb3dlciA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlciA9PT0gJzxhbGw+Jykge1xuICAgICAgICAvKiBjYXNlIDI6IHRyYWNlIGFsbCBydWxlcyBpZ25vcmUgYWxsIG90aGVyIHJ1bGUgY29tbWFuZHMgKi9cbiAgICAgICAgc2V0UnVsZXModHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gJzxub25lPicpIHtcbiAgICAgICAgLyogY2FzZSAzOiB0cmFjZSBubyBydWxlcyAqL1xuICAgICAgICBzZXRSdWxlcyhmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogY2FzZSA0OiB0cmFjZSBvbmx5IGluZGl2aWR1YWxseSBzcGVjaWZpZWQgcnVsZXMgKi9cbiAgICBzZXRSdWxlcyhmYWxzZSk7XG4gICAgb3BlcmF0b3JGaWx0ZXJbaWQuUk5NXSA9IHRydWU7XG4gICAgb3BlcmF0b3JGaWx0ZXJbaWQuVURUXSA9IHRydWU7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoYXQuZmlsdGVyLnJ1bGVzKSB7XG4gICAgICBjb25zdCBsb3dlciA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGkgPSBsaXN0LmluZGV4T2YobG93ZXIpO1xuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aW5pdFJ1bGVGaWx0ZXI6ICcke25hbWV9JyBub3QgYSB2YWxpZCBydWxlIG9yIHVkdCBuYW1lYCk7XG4gICAgICB9XG4gICAgICBydWxlRmlsdGVyW2ldID0gdGhhdC5maWx0ZXIucnVsZXNbbmFtZV0gPT09IHRydWU7XG4gICAgfVxuICB9O1xuICAvKiB1c2VkIGJ5IG90aGVyIEFQRyBjb21wb25lbnRzIHRvIHZlcmlmeSB0aGF0IHRoZXkgaGF2ZSBhIHZhbGlkIHRyYWNlIG9iamVjdCAqL1xuICB0aGlzLnRyYWNlT2JqZWN0ID0gJ3RyYWNlT2JqZWN0JztcbiAgdGhpcy5maWx0ZXIgPSB7XG4gICAgb3BlcmF0b3JzOiBbXSxcbiAgICBydWxlczogW10sXG4gIH07XG4gIC8vIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byBrZWVwIChkZWZhdWx0ID0gNTAwMCkuXG4gIC8vIEVhY2ggcmVjb3JkIG51bWJlciBsYXJnZXIgdGhhbiBgbWF4UmVjb3Jkc2BcbiAgLy8gd2lsbCByZXN1bHQgaW4gZGVsZXRpbmcgdGhlIHByZXZpb3VzbHkgb2xkZXN0IHJlY29yZC5cbiAgLy8gLSBgbWF4YDogbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byByZXRhaW4gKGRlZmF1bHQgPSA1MDAwKVxuICAvLyAtIGBsYXN0YDogbGFzdCByZWNvcmQgbnVtYmVyIHRvIHJldGFpbiwgKGRlZmF1bHQgPSAtMSBmb3IgKHVua25vd24pIGFjdHVhbCBsYXN0IHJlY29yZClcbiAgdGhpcy5zZXRNYXhSZWNvcmRzID0gZnVuY3Rpb24gKG1heCwgbGFzdCkge1xuICAgIGxhc3RSZWNvcmQgPSAtMTtcbiAgICBpZiAodHlwZW9mIG1heCA9PT0gJ251bWJlcicgJiYgbWF4ID4gMCkge1xuICAgICAgbWF4UmVjb3JkcyA9IE1hdGguY2VpbChtYXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhSZWNvcmRzID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgICAgbGFzdFJlY29yZCA9IE1hdGguZmxvb3IobGFzdCk7XG4gICAgICBpZiAobGFzdFJlY29yZCA8IDApIHtcbiAgICAgICAgbGFzdFJlY29yZCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gUmV0dXJucyBgbWF4UmVjb3Jkc2AgdG8gdGhlIGNhbGxlci5cbiAgdGhpcy5nZXRNYXhSZWNvcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXhSZWNvcmRzO1xuICB9O1xuICAvLyBSZXR1cm5zIGBsYXN0UmVjb3JkYCB0byB0aGUgY2FsbGVyLlxuICB0aGlzLmdldExhc3RSZWNvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxhc3RSZWNvcmQ7XG4gIH07XG4gIC8qIENhbGxlZCBvbmx5IGJ5IHRoZSBgcGFyc2VyLmpzYCBvYmplY3QuIE5vIHZlcmlmaWNhdGlvbiBvZiBpbnB1dC4gKi9cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKHJ1bGVzSW4sIHVkdHNJbiwgY2hhcnNJbikge1xuICAgIHJlY29yZHMubGVuZ3RoID0gMDtcbiAgICByZWNvcmRTdGFjay5sZW5ndGggPSAwO1xuICAgIGZpbHRlcmVkUmVjb3JkcyA9IDA7XG4gICAgdHJlZURlcHRoID0gMDtcbiAgICBjaGFycyA9IGNoYXJzSW47XG4gICAgcnVsZXMgPSBydWxlc0luO1xuICAgIHVkdHMgPSB1ZHRzSW47XG4gICAgaW5pdE9wZXJhdG9yRmlsdGVyKCk7XG4gICAgaW5pdFJ1bGVGaWx0ZXIoKTtcbiAgICBjaXJjdWxhci5pbml0KG1heFJlY29yZHMpO1xuICB9O1xuICAvKiByZXR1cm5zIHRydWUgaWYgdGhpcyByZWNvcmRzIHBhc3NlcyB0aHJvdWdoIHRoZSBkZXNpZ25hdGVkIGZpbHRlciwgZmFsc2UgaWYgdGhlIHJlY29yZCBpcyB0byBiZSBza2lwcGVkICovXG4gIGNvbnN0IGZpbHRlck9wcyA9IGZ1bmN0aW9uIChvcCkge1xuICAgIGxldCByZXQgPSBmYWxzZTtcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICBpZiAob3BlcmF0b3JGaWx0ZXJbb3AudHlwZV0gJiYgcnVsZUZpbHRlcltvcC5pbmRleF0pIHtcbiAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gaWQuVURUKSB7XG4gICAgICBpZiAob3BlcmF0b3JGaWx0ZXJbb3AudHlwZV0gJiYgcnVsZUZpbHRlcltydWxlcy5sZW5ndGggKyBvcC5pbmRleF0pIHtcbiAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSBvcGVyYXRvckZpbHRlcltvcC50eXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgY29uc3QgZmlsdGVyUmVjb3JkcyA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVjb3JkIDw9IGxhc3RSZWNvcmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qIENvbGxlY3QgdGhlIFwiZG93blwiIHJlY29yZC4gKi9cbiAgdGhpcy5kb3duID0gZnVuY3Rpb24gKG9wLCBzdGF0ZSwgb2Zmc2V0LCBsZW5ndGgsIGFuY2hvciwgbG9va0Fyb3VuZCkge1xuICAgIGlmIChmaWx0ZXJSZWNvcmRzKGZpbHRlcmVkUmVjb3JkcykgJiYgZmlsdGVyT3BzKG9wKSkge1xuICAgICAgcmVjb3JkU3RhY2sucHVzaChmaWx0ZXJlZFJlY29yZHMpO1xuICAgICAgcmVjb3Jkc1tjaXJjdWxhci5pbmNyZW1lbnQoKV0gPSB7XG4gICAgICAgIGRpclVwOiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IHRyZWVEZXB0aCxcbiAgICAgICAgdGhpc0xpbmU6IGZpbHRlcmVkUmVjb3JkcyxcbiAgICAgICAgdGhhdExpbmU6IHVuZGVmaW5lZCxcbiAgICAgICAgb3Bjb2RlOiBvcCxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHBocmFzZUluZGV4OiBvZmZzZXQsXG4gICAgICAgIHBocmFzZUxlbmd0aDogbGVuZ3RoLFxuICAgICAgICBsb29rQW5jaG9yOiBhbmNob3IsXG4gICAgICAgIGxvb2tBcm91bmQsXG4gICAgICB9O1xuICAgICAgZmlsdGVyZWRSZWNvcmRzICs9IDE7XG4gICAgICB0cmVlRGVwdGggKz0gMTtcbiAgICB9XG4gIH07XG4gIC8qIENvbGxlY3QgdGhlIFwidXBcIiByZWNvcmQuICovXG4gIHRoaXMudXAgPSBmdW5jdGlvbiAob3AsIHN0YXRlLCBvZmZzZXQsIGxlbmd0aCwgYW5jaG9yLCBsb29rQXJvdW5kKSB7XG4gICAgaWYgKGZpbHRlclJlY29yZHMoZmlsdGVyZWRSZWNvcmRzKSAmJiBmaWx0ZXJPcHMob3ApKSB7XG4gICAgICBjb25zdCB0aGlzTGluZSA9IGZpbHRlcmVkUmVjb3JkcztcbiAgICAgIGNvbnN0IHRoYXRMaW5lID0gcmVjb3JkU3RhY2sucG9wKCk7XG4gICAgICBjb25zdCB0aGF0UmVjb3JkID0gY2lyY3VsYXIuZ2V0TGlzdEluZGV4KHRoYXRMaW5lKTtcbiAgICAgIGlmICh0aGF0UmVjb3JkICE9PSAtMSkge1xuICAgICAgICByZWNvcmRzW3RoYXRSZWNvcmRdLnRoYXRMaW5lID0gdGhpc0xpbmU7XG4gICAgICB9XG4gICAgICB0cmVlRGVwdGggLT0gMTtcbiAgICAgIHJlY29yZHNbY2lyY3VsYXIuaW5jcmVtZW50KCldID0ge1xuICAgICAgICBkaXJVcDogdHJ1ZSxcbiAgICAgICAgZGVwdGg6IHRyZWVEZXB0aCxcbiAgICAgICAgdGhpc0xpbmUsXG4gICAgICAgIHRoYXRMaW5lLFxuICAgICAgICBvcGNvZGU6IG9wLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGhyYXNlSW5kZXg6IG9mZnNldCxcbiAgICAgICAgcGhyYXNlTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIGxvb2tBbmNob3I6IGFuY2hvcixcbiAgICAgICAgbG9va0Fyb3VuZCxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJlZFJlY29yZHMgKz0gMTtcbiAgICB9XG4gIH07XG4gIC8qIGNvbnZlcnQgdGhlIHRyYWNlIHJlY29yZHMgdG8gYSB0cmVlIG9mIG5vZGVzICovXG4gIGNvbnN0IHRvVHJlZU9iaiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBwcml2YXRlIGhlbHBlciBmdW5jdGlvbnMgKi9cbiAgICBmdW5jdGlvbiBub2RlT3Bjb2RlKG5vZGUsIG9wY29kZSkge1xuICAgICAgbGV0IG5hbWU7XG4gICAgICBsZXQgY2FzZXR5cGU7XG4gICAgICBsZXQgbW9kZXR5cGU7XG4gICAgICBpZiAob3Bjb2RlKSB7XG4gICAgICAgIG5vZGUub3AgPSB7IGlkOiBvcGNvZGUudHlwZSwgbmFtZTogdXRpbHMub3Bjb2RlVG9TdHJpbmcob3Bjb2RlLnR5cGUpIH07XG4gICAgICAgIG5vZGUub3BEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKG9wY29kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBpZC5STk06XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IHJ1bGVzW29wY29kZS5pbmRleF0ubmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVURUOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSB1ZHRzW29wY29kZS5pbmRleF0ubmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuQktSOlxuICAgICAgICAgICAgaWYgKG9wY29kZS5pbmRleCA8IHJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBuYW1lID0gcnVsZXNbb3Bjb2RlLmluZGV4XS5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHVkdHNbb3Bjb2RlLmluZGV4IC0gcnVsZXMubGVuZ3RoXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZXR5cGUgPSBvcGNvZGUuYmtyQ2FzZSA9PT0gaWQuQktSX01PREVfQ0kgPyAnJWknIDogJyVzJztcbiAgICAgICAgICAgIG1vZGV0eXBlID0gb3Bjb2RlLmJrck1vZGUgPT09IGlkLkJLUl9NT0RFX1VNID8gJyV1JyA6ICclcCc7XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IGBcXFxcXFxcXCR7Y2FzZXR5cGV9JHttb2RldHlwZX0ke25hbWV9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQuVExTOlxuICAgICAgICAgICAgbm9kZS5vcERhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3Bjb2RlLnN0cmluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBub2RlLm9wRGF0YS5wdXNoKG9wY29kZS5zdHJpbmdbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5UQlM6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcGNvZGUuc3RyaW5nLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIG5vZGUub3BEYXRhLnB1c2gob3Bjb2RlLnN0cmluZ1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGlkLlRSRzpcbiAgICAgICAgICAgIG5vZGUub3BEYXRhID0gW29wY29kZS5taW4sIG9wY29kZS5tYXhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBpZC5SRVA6XG4gICAgICAgICAgICBub2RlLm9wRGF0YSA9IFtvcGNvZGUubWluLCBvcGNvZGUubWF4XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBvcGNvZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vcCA9IHsgaWQ6IHVuZGVmaW5lZCwgbmFtZTogdW5kZWZpbmVkIH07XG4gICAgICAgIG5vZGUub3BEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlUGhyYXNlKHN0YXRlLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IGlkLk1BVENIKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGVuZ3RoLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBpZC5OT01BVENIKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlID09PSBpZC5FTVBUWSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbm9kZUlkID0gLTE7XG4gICAgZnVuY3Rpb24gbm9kZURvd24ocGFyZW50LCByZWNvcmQsIGRlcHRoKSB7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgICAgaWQ6IG5vZGVJZCsrLFxuICAgICAgICBicmFuY2g6IC0xLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHVwOiBmYWxzZSxcbiAgICAgICAgZG93bjogZmFsc2UsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICB9O1xuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBub2RlLmRvd24gPSB0cnVlO1xuICAgICAgICBub2RlLnN0YXRlID0geyBpZDogcmVjb3JkLnN0YXRlLCBuYW1lOiB1dGlscy5zdGF0ZVRvU3RyaW5nKHJlY29yZC5zdGF0ZSkgfTtcbiAgICAgICAgbm9kZS5waHJhc2UgPSBudWxsO1xuICAgICAgICBub2RlT3Bjb2RlKG5vZGUsIHJlY29yZC5vcGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zdGF0ZSA9IHsgaWQ6IHVuZGVmaW5lZCwgbmFtZTogdW5kZWZpbmVkIH07XG4gICAgICAgIG5vZGUucGhyYXNlID0gbm9kZVBocmFzZSgpO1xuICAgICAgICBub2RlT3Bjb2RlKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9kZVVwKG5vZGUsIHJlY29yZCkge1xuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBub2RlLnVwID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5zdGF0ZSA9IHsgaWQ6IHJlY29yZC5zdGF0ZSwgbmFtZTogdXRpbHMuc3RhdGVUb1N0cmluZyhyZWNvcmQuc3RhdGUpIH07XG4gICAgICAgIG5vZGUucGhyYXNlID0gbm9kZVBocmFzZShyZWNvcmQuc3RhdGUsIHJlY29yZC5waHJhc2VJbmRleCwgcmVjb3JkLnBocmFzZUxlbmd0aCk7XG4gICAgICAgIGlmICghbm9kZS5kb3duKSB7XG4gICAgICAgICAgbm9kZU9wY29kZShub2RlLCByZWNvcmQub3Bjb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiB3YWxrIHRoZSBmaW5hbCB0cmVlOiBsYWJlbCBicmFuY2hlcyBhbmQgY291bnQgbGVhZiBub2RlcyAqL1xuICAgIGxldCBsZWFmTm9kZXMgPSAwO1xuICAgIGxldCBkZXB0aCA9IC0xO1xuICAgIGxldCBicmFuY2hDb3VudCA9IDE7XG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBkZXB0aCArPSAxO1xuICAgICAgbm9kZS5icmFuY2ggPSBicmFuY2hDb3VudDtcbiAgICAgIGlmIChkZXB0aCA+IHRyZWVEZXB0aCkge1xuICAgICAgICB0cmVlRGVwdGggPSBkZXB0aDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsZWFmTm9kZXMgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgYnJhbmNoQ291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5sZWZ0TW9zdCA9IGZhbHNlO1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0ucmlnaHRNb3N0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG5vZGUubGVmdE1vc3QpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0ubGVmdE1vc3QgPSBpID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS5yaWdodE1vc3QpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW5baV0ucmlnaHRNb3N0ID0gaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YWxrKG5vZGUuY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwbGF5KG5vZGUsIG9mZnNldCkge1xuICAgICAgbGV0IG5hbWU7XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIG9iai5pZCA9IG5vZGUuaWQ7XG4gICAgICBvYmouYnJhbmNoID0gbm9kZS5icmFuY2g7XG4gICAgICBvYmoubGVmdE1vc3QgPSBub2RlLmxlZnRNb3N0O1xuICAgICAgb2JqLnJpZ2h0TW9zdCA9IG5vZGUucmlnaHRNb3N0O1xuICAgICAgbmFtZSA9IG5vZGUuc3RhdGUubmFtZSA/IG5vZGUuc3RhdGUubmFtZSA6ICdBQ1RJVkUnO1xuICAgICAgb2JqLnN0YXRlID0geyBpZDogbm9kZS5zdGF0ZS5pZCwgbmFtZSB9O1xuICAgICAgbmFtZSA9IG5vZGUub3AubmFtZSA/IG5vZGUub3AubmFtZSA6ICc/JztcbiAgICAgIG9iai5vcCA9IHsgaWQ6IG5vZGUub3AuaWQsIG5hbWUgfTtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5vcERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9iai5vcERhdGEgPSBub2RlLm9wRGF0YTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlLm9wRGF0YSkpIHtcbiAgICAgICAgb2JqLm9wRGF0YSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUub3BEYXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgb2JqLm9wRGF0YVtpXSA9IG5vZGUub3BEYXRhW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmoub3BEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUucGhyYXNlKSB7XG4gICAgICAgIG9iai5waHJhc2UgPSB7IGluZGV4OiBub2RlLnBocmFzZS5pbmRleCwgbGVuZ3RoOiBub2RlLnBocmFzZS5sZW5ndGggfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iai5waHJhc2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgb2JqLmRlcHRoID0gbm9kZS5kZXB0aDtcbiAgICAgIG9iai5jaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGMgPSBpICE9PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG9iai5jaGlsZHJlbltpXSA9IGRpc3BsYXkobm9kZS5jaGlsZHJlbltpXSwgb2Zmc2V0LCBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLyogY29uc3RydWN0IHRoZSB0cmVlIGJlZ2lubmluZyBoZXJlICovXG4gICAgY29uc3QgYnJhbmNoID0gW107XG4gICAgbGV0IHJvb3Q7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IHBhcmVudDtcbiAgICBsZXQgcmVjb3JkO1xuICAgIGxldCBmaXJzdFJlY29yZCA9IHRydWU7XG4gICAgLyogcHVzaCBhIGR1bW15IG5vZGUgc28gdGhlIHJvb3Qgbm9kZSB3aWxsIGhhdmUgYSBub24tbnVsbCBwYXJlbnQgKi9cbiAgICBjb25zdCBkdW1teSA9IG5vZGVEb3duKG51bGwsIG51bGwsIC0xKTtcbiAgICBicmFuY2gucHVzaChkdW1teSk7XG4gICAgbm9kZSA9IGR1bW15O1xuICAgIGNpcmN1bGFyLmZvckVhY2goKGxpbmVJbmRleCkgPT4ge1xuICAgICAgcmVjb3JkID0gcmVjb3Jkc1tsaW5lSW5kZXhdO1xuICAgICAgaWYgKGZpcnN0UmVjb3JkKSB7XG4gICAgICAgIGZpcnN0UmVjb3JkID0gZmFsc2U7XG4gICAgICAgIGlmIChyZWNvcmQuZGVwdGggPiAwKSB7XG4gICAgICAgICAgLyogcHVzaCBzb21lIGR1bW15IG5vZGVzIHRvIGZpbGwgaW4gZm9yIG1pc3NpbmcgcmVjb3JkcyAqL1xuICAgICAgICAgIGNvbnN0IG51bSA9IHJlY29yZC5kaXJVcCA/IHJlY29yZC5kZXB0aCArIDEgOiByZWNvcmQuZGVwdGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkgKz0gMSkge1xuICAgICAgICAgICAgcGFyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlRG93bihub2RlLCBudWxsLCBpKTtcbiAgICAgICAgICAgIGJyYW5jaC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVjb3JkLmRpclVwKSB7XG4gICAgICAgIC8qIGhhbmRsZSB0aGUgbmV4dCByZWNvcmQgdXAgKi9cbiAgICAgICAgbm9kZSA9IGJyYW5jaC5wb3AoKTtcbiAgICAgICAgbm9kZVVwKG5vZGUsIHJlY29yZCk7XG4gICAgICAgIG5vZGUgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaGFuZGxlIHRoZSBuZXh0IHJlY29yZCBkb3duICovXG4gICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlRG93bihub2RlLCByZWNvcmQsIHJlY29yZC5kZXB0aCk7XG4gICAgICAgIGJyYW5jaC5wdXNoKG5vZGUpO1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qIGlmIG5vdCBhdCByb290LCB3YWxrIGl0IHVwIHRvIHJvb3QgKi9cbiAgICB3aGlsZSAoYnJhbmNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIG5vZGUgPSBicmFuY2gucG9wKCk7XG4gICAgICBub2RlVXAobm9kZSwgbnVsbCk7XG4gICAgfVxuICAgIC8qIG1heWJlIHJlZHVuZGFudCBvciBwYXJhbm9pZCB0ZXN0czogdGhlc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiAqL1xuICAgIGlmIChkdW1teS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2UudG9UcmVlKCk6IHBhcnNlIHRyZWUgaGFzIG5vIG5vZGVzJyk7XG4gICAgfVxuICAgIGlmIChicmFuY2gubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYWNlLnRvVHJlZSgpOiBpbnRlZ3JpdHkgY2hlY2s6IGR1bW15IHJvb3Qgbm9kZSBkaXNhcHBlYXJlZD8nKTtcbiAgICB9XG5cbiAgICAvKiBpZiBubyByZWNvcmQgZm9yIHN0YXJ0IHJ1bGU6IGZpbmQgdGhlIHBzZXVkbyByb290IG5vZGUgKGZpcnN0IGR1bW15IG5vZGUgYWJvdmUgYSByZWFsIG5vZGUpICovXG4gICAgcm9vdCA9IGR1bW15LmNoaWxkcmVuWzBdO1xuICAgIGxldCBwcmV2ID0gcm9vdDtcbiAgICB3aGlsZSAocm9vdCAmJiAhcm9vdC5kb3duICYmICFyb290LnVwKSB7XG4gICAgICBwcmV2ID0gcm9vdDtcbiAgICAgIHJvb3QgPSByb290LmNoaWxkcmVuWzBdO1xuICAgIH1cbiAgICByb290ID0gcHJldjtcblxuICAgIC8qIHdhbGsgdGhlIHRyZWUgb2Ygbm9kZXM6IGxhYmVsIGJyYW5jZXMgYW5kIGNvdW50IGxlYXZlcyAqL1xuICAgIHJvb3QubGVmdE1vc3QgPSB0cnVlO1xuICAgIHJvb3QucmlnaHRNb3N0ID0gdHJ1ZTtcbiAgICB3YWxrKHJvb3QpO1xuICAgIHJvb3QuYnJhbmNoID0gMDtcblxuICAgIC8qIGdlbmVyYXRlIHRoZSBleHBvcnRlZCBvYmplY3QgKi9cbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBvYmouc3RyaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb2JqLnN0cmluZ1tpXSA9IGNoYXJzW2ldO1xuICAgIH1cbiAgICAvKiBnZW5lcmF0ZSB0aGUgZXhwb3J0ZWQgcnVsZSBuYW1lcyAqL1xuICAgIG9iai5ydWxlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG9iai5ydWxlc1tpXSA9IHJ1bGVzW2ldLm5hbWU7XG4gICAgfVxuICAgIC8qIGdlbmVyYXRlIHRoZSBleHBvcnRlZCBVRFQgbmFtZXMgKi9cbiAgICBvYmoudWR0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWR0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgb2JqLnVkdHNbaV0gPSB1ZHRzW2ldLm5hbWU7XG4gICAgfVxuICAgIC8qIGdlbmVyYXRlIHRoZSBpZHMgKi9cbiAgICBvYmouaWQgPSB7fTtcbiAgICBvYmouaWQuQUxUID0geyBpZDogaWQuQUxULCBuYW1lOiAnQUxUJyB9O1xuICAgIG9iai5pZC5DQVQgPSB7IGlkOiBpZC5DQVQsIG5hbWU6ICdDQVQnIH07XG4gICAgb2JqLmlkLlJFUCA9IHsgaWQ6IGlkLlJFUCwgbmFtZTogJ1JFUCcgfTtcbiAgICBvYmouaWQuUk5NID0geyBpZDogaWQuUk5NLCBuYW1lOiAnUk5NJyB9O1xuICAgIG9iai5pZC5UTFMgPSB7IGlkOiBpZC5UTFMsIG5hbWU6ICdUTFMnIH07XG4gICAgb2JqLmlkLlRCUyA9IHsgaWQ6IGlkLlRCUywgbmFtZTogJ1RCUycgfTtcbiAgICBvYmouaWQuVFJHID0geyBpZDogaWQuVFJHLCBuYW1lOiAnVFJHJyB9O1xuICAgIG9iai5pZC5VRFQgPSB7IGlkOiBpZC5VRFQsIG5hbWU6ICdVRFQnIH07XG4gICAgb2JqLmlkLkFORCA9IHsgaWQ6IGlkLkFORCwgbmFtZTogJ0FORCcgfTtcbiAgICBvYmouaWQuTk9UID0geyBpZDogaWQuTk9ULCBuYW1lOiAnTk9UJyB9O1xuICAgIG9iai5pZC5CS1IgPSB7IGlkOiBpZC5CS1IsIG5hbWU6ICdCS1InIH07XG4gICAgb2JqLmlkLkJLQSA9IHsgaWQ6IGlkLkJLQSwgbmFtZTogJ0JLQScgfTtcbiAgICBvYmouaWQuQktOID0geyBpZDogaWQuQktOLCBuYW1lOiAnQktOJyB9O1xuICAgIG9iai5pZC5BQkcgPSB7IGlkOiBpZC5BQkcsIG5hbWU6ICdBQkcnIH07XG4gICAgb2JqLmlkLkFFTiA9IHsgaWQ6IGlkLkFFTiwgbmFtZTogJ0FFTicgfTtcbiAgICBvYmouaWQuQUNUSVZFID0geyBpZDogaWQuQUNUSVZFLCBuYW1lOiAnQUNUSVZFJyB9O1xuICAgIG9iai5pZC5NQVRDSCA9IHsgaWQ6IGlkLk1BVENILCBuYW1lOiAnTUFUQ0gnIH07XG4gICAgb2JqLmlkLkVNUFRZID0geyBpZDogaWQuRU1QVFksIG5hbWU6ICdFTVBUWScgfTtcbiAgICBvYmouaWQuTk9NQVRDSCA9IHsgaWQ6IGlkLk5PTUFUQ0gsIG5hbWU6ICdOT01BVENIJyB9O1xuICAgIC8qIGdlbmVyYXRlIHRoZSBtYXggdHJlZSBkZXB0aCAqL1xuICAgIG9iai50cmVlRGVwdGggPSB0cmVlRGVwdGg7XG4gICAgLyogZ2VuZXJhdGUgdGhlIG51bWJlciBvZiBsZWFmIG5vZGVzIChicmFuY2hlcykgKi9cbiAgICBvYmoubGVhZk5vZGVzID0gbGVhZk5vZGVzO1xuICAgIC8qIGdlbmVyYXRlIHRoZSB0eXBlcyBvZiB0aGUgbGVmdC0gYW5kIHJpZ2h0LW1vc3QgYnJhbmNoZXMgKi9cbiAgICBsZXQgYnJhbmNoZXNJbmNvbXBsZXRlO1xuICAgIGlmIChyb290LmRvd24pIHtcbiAgICAgIGlmIChyb290LnVwKSB7XG4gICAgICAgIGJyYW5jaGVzSW5jb21wbGV0ZSA9ICdub25lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyYW5jaGVzSW5jb21wbGV0ZSA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyb290LnVwKSB7XG4gICAgICBicmFuY2hlc0luY29tcGxldGUgPSAnbGVmdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyYW5jaGVzSW5jb21wbGV0ZSA9ICdib3RoJztcbiAgICB9XG4gICAgb2JqLmJyYW5jaGVzSW5jb21wbGV0ZSA9IGJyYW5jaGVzSW5jb21wbGV0ZTtcbiAgICBvYmoudHJlZSA9IGRpc3BsYXkocm9vdCwgcm9vdC5kZXB0aCwgZmFsc2UpO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIC8vIFJldHVybnMgdGhlIHRyYWNlIHJlY29yZHMgYXMgSlNPTiBwYXJzZSB0cmVlIG9iamVjdC5cbiAgLy8gLSBzdHJpbmdpZnk6IGlmIGB0cnVlYCwgdGhlIG9iamVjdCBpcyAnc3RyaW5naWZpZWQnIGJlZm9yZSByZXR1cm5pbmcsIG90aGVyd2lzZSwgdGhlIG9iamVjdCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gIHRoaXMudG9UcmVlID0gZnVuY3Rpb24gKHN0cmluZ2lmeSkge1xuICAgIGNvbnN0IG9iaiA9IHRvVHJlZU9iaigpO1xuICAgIGlmIChzdHJpbmdpZnkpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuICAvLyBUcmFuc2xhdGUgdGhlIHRyYWNlIHJlY29yZHMgdG8gSFRNTCBmb3JtYXQgYW5kIGNyZWF0ZSBhIGNvbXBsZXRlIEhUTUwgcGFnZSBmb3IgYnJvd3NlciBkaXNwbGF5LlxuICB0aGlzLnRvSHRtbFBhZ2UgPSBmdW5jdGlvbiAobW9kZSwgY2FwdGlvbiwgdGl0bGUpIHtcbiAgICByZXR1cm4gdXRpbHMuaHRtbFRvUGFnZSh0aGlzLnRvSHRtbChtb2RlLCBjYXB0aW9uKSwgdGl0bGUpO1xuICB9O1xuXG4gIC8qIEZyb20gaGVyZSBvbiBkb3duLCB0aGVzZSBhcmUganVzdCBoZWxwZXIgZnVuY3Rpb25zIGZvciBgdG9IdG1sKClgLiAqL1xuICBjb25zdCBodG1sSGVhZGVyID0gZnVuY3Rpb24gKG1vZGUsIGNhcHRpb24pIHtcbiAgICAvKiBvcGVuIHRoZSBwYWdlICovXG4gICAgLyogd3JpdGUgdGhlIEhUTUw1IGhlYWRlciB3aXRoIHRhYmxlIHN0eWxlICovXG4gICAgLyogb3BlbiB0aGUgPHRhYmxlPiB0YWcgKi9cbiAgICBsZXQgbW9kZU5hbWU7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIE1PREVfSEVYOlxuICAgICAgICBtb2RlTmFtZSA9ICdoZXhhZGVjaW1hbCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX0RFQzpcbiAgICAgICAgbW9kZU5hbWUgPSAnZGVjaW1hbCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX0FTQ0lJOlxuICAgICAgICBtb2RlTmFtZSA9ICdBU0NJSSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX1VOSUNPREU6XG4gICAgICAgIG1vZGVOYW1lID0gJ1VOSUNPREUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9aHRtbEhlYWRlcjogdW5yZWNvZ25pemVkIG1vZGU6ICR7bW9kZX1gKTtcbiAgICB9XG4gICAgbGV0IGhlYWRlciA9ICcnO1xuICAgIGhlYWRlciArPSBgPHA+ZGlzcGxheSBtb2RlOiAke21vZGVOYW1lfTwvcD5cXG5gO1xuICAgIGhlYWRlciArPSBgPHRhYmxlIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19UUkFDRX1cIj5cXG5gO1xuICAgIGlmICh0eXBlb2YgY2FwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGhlYWRlciArPSBgPGNhcHRpb24+JHtjYXB0aW9ufTwvY2FwdGlvbj5gO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVyO1xuICB9O1xuICBjb25zdCBodG1sRm9vdGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBmb290ZXIgPSAnJztcbiAgICAvKiBjbG9zZSB0aGUgPC90YWJsZT4gdGFnICovXG4gICAgZm9vdGVyICs9ICc8L3RhYmxlPlxcbic7XG4gICAgLyogZGlzcGxheSBhIHRhYmxlIGxlZ2VuZCAqL1xuICAgIGZvb3RlciArPSBgPHAgY2xhc3M9XCIke3N0eWxlLkNMQVNTX01PTk9TUEFDRX1cIj5sZWdlbmQ6PGJyPlxcbmA7XG4gICAgZm9vdGVyICs9ICcoYSkmbmJzcDstJm5ic3A7bGluZSBudW1iZXI8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhiKSZuYnNwOy0mbmJzcDttYXRjaGluZyBsaW5lIG51bWJlcjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGMpJm5ic3A7LSZuYnNwO3BocmFzZSBvZmZzZXQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJyhkKSZuYnNwOy0mbmJzcDtwaHJhc2UgbGVuZ3RoPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICcoZSkmbmJzcDstJm5ic3A7dHJlZSBkZXB0aDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnKGYpJm5ic3A7LSZuYnNwO29wZXJhdG9yIHN0YXRlPGJyPlxcbic7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4mZGFycjs8L3NwYW4+Jm5ic3A7Jm5ic3A7cGhyYXNlIG9wZW5lZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj4mdWFycjtNPC9zcGFuPiBwaHJhc2UgbWF0Y2hlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj4mdWFycjtFPC9zcGFuPiBlbXB0eSBwaHJhc2UgbWF0Y2hlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPiZ1YXJyO048L3NwYW4+IHBocmFzZSBub3QgbWF0Y2hlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPVxuICAgICAgJ29wZXJhdG9yJm5ic3A7LSZuYnNwO0FMVCwgQ0FULCBSRVAsIFJOTSwgVFJHLCBUTFMsIFRCUzxzdXA+JmRhZ2dlcjs8L3N1cD4sIFVEVCwgQU5ELCBOT1QsIEJLQSwgQktOLCBCS1IsIEFCRywgQUVOPHN1cD4mRGFnZ2VyOzwvc3VwPjxicj5cXG4nO1xuICAgIGZvb3RlciArPSBgcGhyYXNlJm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwO3VwIHRvICR7TUFYX1BIUkFTRX0gY2hhcmFjdGVycyBvZiB0aGUgcGhyYXNlIGJlaW5nIG1hdGNoZWQ8YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+bWF0Y2hlZCBjaGFyYWN0ZXJzPC9zcGFuPjxicj5cXG5gO1xuICAgIGZvb3RlciArPSBgJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7LSZuYnNwOzxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19MT09LQUhFQUR9XCI+bWF0Y2hlZCBjaGFyYWN0ZXJzIGluIGxvb2sgYWhlYWQgbW9kZTwvc3Bhbj48YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0JFSElORH1cIj5tYXRjaGVkIGNoYXJhY3RlcnMgaW4gbG9vayBiZWhpbmQgbW9kZTwvc3Bhbj48YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfUkVNQUlOREVSfVwiPnJlbWFpbmRlciBjaGFyYWN0ZXJzKG5vdCB5ZXQgZXhhbWluZWQgYnkgcGFyc2VyKTwvc3Bhbj48YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDs8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQ1RSTENIQVJ9XCI+Y29udHJvbCBjaGFyYWN0ZXJzLCBUQUIsIExGLCBDUiwgZXRjLiAoQVNDSUkgbW9kZSBvbmx5KTwvc3Bhbj48YnI+XFxuYDtcbiAgICBmb290ZXIgKz0gYCZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOy0mbmJzcDske1BIUkFTRV9FTVBUWX0gZW1wdHkgc3RyaW5nPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7JHtQSFJBU0VfRU5EfSBlbmQgb2YgaW5wdXQgc3RyaW5nPGJyPlxcbmA7XG4gICAgZm9vdGVyICs9IGAmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDstJm5ic3A7JHtQSFJBU0VfQ09OVElOVUV9IGlucHV0IHN0cmluZyBkaXNwbGF5IHRydW5jYXRlZDxicj5cXG5gO1xuICAgIGZvb3RlciArPSAnPC9wPlxcbic7XG4gICAgZm9vdGVyICs9IGA8cCBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTU9OT1NQQUNFfVwiPlxcbmA7XG4gICAgZm9vdGVyICs9ICc8c3VwPiZkYWdnZXI7PC9zdXA+b3JpZ2luYWwgQUJORiBvcGVyYXRvcnM6PGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdBTFQgLSBhbHRlcm5hdGlvbjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQ0FUIC0gY29uY2F0ZW5hdGlvbjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnUkVQIC0gcmVwZXRpdGlvbjxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnUk5NIC0gcnVsZSBuYW1lPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdUUkcgLSB0ZXJtaW5hbCByYW5nZTxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnVExTIC0gdGVybWluYWwgbGl0ZXJhbCBzdHJpbmcgKGNhc2UgaW5zZW5zaXRpdmUpPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdUQlMgLSB0ZXJtaW5hbCBiaW5hcnkgc3RyaW5nIChjYXNlIHNlbnNpdGl2ZSk8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJzxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnPHN1cD4mRGFnZ2VyOzwvc3VwPnN1cGVyIHNldCBTQUJORiBvcGVyYXRvcnM6PGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdVRFQgLSB1c2VyLWRlZmluZWQgdGVybWluYWw8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0FORCAtIHBvc2l0aXZlIGxvb2sgYWhlYWQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ05PVCAtIG5lZ2F0aXZlIGxvb2sgYWhlYWQ8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0JLQSAtIHBvc2l0aXZlIGxvb2sgYmVoaW5kPGJyPlxcbic7XG4gICAgZm9vdGVyICs9ICdCS04gLSBuZWdhdGl2ZSBsb29rIGJlaGluZDxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQktSIC0gYmFjayByZWZlcmVuY2U8YnI+XFxuJztcbiAgICBmb290ZXIgKz0gJ0FCRyAtIGFuY2hvciAtIGJlZ2luIG9mIGlucHV0IHN0cmluZzxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnQUVOIC0gYW5jaG9yIC0gZW5kIG9mIGlucHV0IHN0cmluZzxicj5cXG4nO1xuICAgIGZvb3RlciArPSAnPC9wPlxcbic7XG4gICAgcmV0dXJuIGZvb3RlcjtcbiAgfTtcbiAgdGhpcy5pbmRlbnQgPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkgKz0gMSkge1xuICAgICAgaHRtbCArPSAnLic7XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBmb3JtYXQgdGhlIFRSRyBvcGVyYXRvciAqL1xuICBjb25zdCBkaXNwbGF5VHJnID0gZnVuY3Rpb24gKG1vZGUsIG9wKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuVFJHKSB7XG4gICAgICBpZiAobW9kZSA9PT0gTU9ERV9IRVggfHwgbW9kZSA9PT0gTU9ERV9VTklDT0RFKSB7XG4gICAgICAgIGxldCBoZXggPSBvcC5taW4udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IG1vZGUgPT09IE1PREVfSEVYID8gJyV4JyA6ICdVKyc7XG4gICAgICAgIGh0bWwgKz0gaGV4O1xuICAgICAgICBoZXggPSBvcC5tYXgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9IGAmbmRhc2g7JHtoZXh9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBgJWQke29wLm1pbi50b1N0cmluZygxMCl9Jm5kYXNoOyR7b3AubWF4LnRvU3RyaW5nKDEwKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbiAgfTtcbiAgLyogZm9ybWF0IHRoZSBSRVAgb3BlcmF0b3IgKi9cbiAgY29uc3QgZGlzcGxheVJlcCA9IGZ1bmN0aW9uIChtb2RlLCBvcCkge1xuICAgIGxldCBodG1sID0gJyc7XG4gICAgaWYgKG9wLnR5cGUgPT09IGlkLlJFUCkge1xuICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEVYKSB7XG4gICAgICAgIGxldCBoZXggPSBvcC5taW4udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICAgICAgfVxuICAgICAgICBodG1sID0gYHgke2hleH1gO1xuICAgICAgICBpZiAob3AubWF4IDwgSW5maW5pdHkpIHtcbiAgICAgICAgICBoZXggPSBvcC5tYXgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhleCA9ICdpbmYnO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwgKz0gYCZuZGFzaDske2hleH1gO1xuICAgICAgfSBlbHNlIGlmIChvcC5tYXggPCBJbmZpbml0eSkge1xuICAgICAgICBodG1sID0gYCR7b3AubWluLnRvU3RyaW5nKDEwKX0mbmRhc2g7JHtvcC5tYXgudG9TdHJpbmcoMTApfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sID0gYCR7b3AubWluLnRvU3RyaW5nKDEwKX0mbmRhc2g7aW5mYDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG4gIC8qIGZvcm1hdCB0aGUgVEJTIG9wZXJhdG9yICovXG4gIGNvbnN0IGRpc3BsYXlUYnMgPSBmdW5jdGlvbiAobW9kZSwgb3ApIHtcbiAgICBsZXQgaHRtbCA9ICcnO1xuICAgIGlmIChvcC50eXBlID09PSBpZC5UQlMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKG9wLnN0cmluZy5sZW5ndGgsIE1BWF9UTFMgKiAyKTtcbiAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCB8fCBtb2RlID09PSBNT0RFX1VOSUNPREUpIHtcbiAgICAgICAgaHRtbCArPSBtb2RlID09PSBNT0RFX0hFWCA/ICcleCcgOiAnVSsnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgbGV0IGhleDtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJy4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoZXggPSBvcC5zdHJpbmdbaV0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwgKz0gaGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sID0gJyVkJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwgKz0gb3Auc3RyaW5nW2ldLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxlbiA8IG9wLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgaHRtbCArPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvKiBmb3JtYXQgdGhlIFRMUyBvcGVyYXRvciAqL1xuICBjb25zdCBkaXNwbGF5VGxzID0gZnVuY3Rpb24gKG1vZGUsIG9wKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBpZiAob3AudHlwZSA9PT0gaWQuVExTKSB7XG4gICAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihvcC5zdHJpbmcubGVuZ3RoLCBNQVhfVExTKTtcbiAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCB8fCBtb2RlID09PSBNT0RFX0RFQykge1xuICAgICAgICBsZXQgY2hhcnU7XG4gICAgICAgIGxldCBjaGFybDtcbiAgICAgICAgbGV0IGJhc2U7XG4gICAgICAgIGlmIChtb2RlID09PSBNT0RFX0hFWCkge1xuICAgICAgICAgIGh0bWwgPSAnJXgnO1xuICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBodG1sID0gJyVkJztcbiAgICAgICAgICBiYXNlID0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaHRtbCArPSAnLic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJsID0gb3Auc3RyaW5nW2ldO1xuICAgICAgICAgIGlmIChjaGFybCA+PSA5NyAmJiBjaGFybCA8PSAxMjIpIHtcbiAgICAgICAgICAgIGNoYXJ1ID0gY2hhcmwgLSAzMjtcbiAgICAgICAgICAgIGh0bWwgKz0gYCR7Y2hhcnUudG9TdHJpbmcoYmFzZSl9LyR7Y2hhcmwudG9TdHJpbmcoYmFzZSl9YC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcmwgPj0gNjUgJiYgY2hhcmwgPD0gOTApIHtcbiAgICAgICAgICAgIGNoYXJ1ID0gY2hhcmw7XG4gICAgICAgICAgICBjaGFybCArPSAzMjtcbiAgICAgICAgICAgIGh0bWwgKz0gYCR7Y2hhcnUudG9TdHJpbmcoYmFzZSl9LyR7Y2hhcmwudG9TdHJpbmcoYmFzZSl9YC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sICs9IGNoYXJsLnRvU3RyaW5nKGJhc2UpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPCBvcC5zdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgaHRtbCArPSBQSFJBU0VfQ09OVElOVUU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSAnXCInO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaHRtbCArPSB1dGlscy5hc2NpaUNoYXJzW29wLnN0cmluZ1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA8IG9wLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICBodG1sICs9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgICAgfVxuICAgICAgICBodG1sICs9ICdcIic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xuICB9O1xuICBjb25zdCBzdWJQaHJhc2UgPSBmdW5jdGlvbiAobW9kZSwgY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgsIHByZXYpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGxldCBwaHJhc2UgPSAnJztcbiAgICBjb25zdCBjb21tYSA9IHByZXYgPyAnLCcgOiAnJztcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgTU9ERV9IRVg6XG4gICAgICAgIHBocmFzZSA9IGNvbW1hICsgdXRpbHMuY2hhcnNUb0hleChjaGFyc0FyZywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBNT0RFX0RFQzpcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICByZXR1cm4gYCwke3V0aWxzLmNoYXJzVG9EZWMoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcGhyYXNlID0gY29tbWEgKyB1dGlscy5jaGFyc1RvRGVjKGNoYXJzQXJnLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE1PREVfVU5JQ09ERTpcbiAgICAgICAgcGhyYXNlID0gdXRpbHMuY2hhcnNUb1VuaWNvZGUoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTU9ERV9BU0NJSTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBocmFzZSA9IHV0aWxzLmNoYXJzVG9Bc2NpaUh0bWwoY2hhcnNBcmcsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBocmFzZTtcbiAgfTtcbiAgLyogZGlzcGxheSBwaHJhc2VzIG1hdGNoZWQgaW4gbG9vay1iZWhpbmQgbW9kZSAqL1xuICBjb25zdCBkaXNwbGF5QmVoaW5kID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCwgYW5jaG9yKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgYmVnMTtcbiAgICBsZXQgbGVuMTtcbiAgICBsZXQgYmVnMjtcbiAgICBsZXQgbGVuMjtcbiAgICBsZXQgbGFzdGNoYXIgPSBQSFJBU0VfRU5EO1xuICAgIGNvbnN0IHNwYW5CZWhpbmQgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tCRUhJTkR9XCI+YDtcbiAgICBjb25zdCBzcGFuUmVtYWluZGVyID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19SRU1BSU5ERVJ9XCI+YDtcbiAgICBjb25zdCBzcGFuZW5kID0gJzwvc3Bhbj4nO1xuICAgIGxldCBwcmV2ID0gZmFsc2U7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBpZC5FTVBUWTpcbiAgICAgICAgaHRtbCArPSBQSFJBU0VfRU1QVFk7XG4gICAgICAvKiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgIGNhc2UgaWQuTUFUQ0g6XG4gICAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgICAgYmVnMSA9IGluZGV4IC0gbGVuZ3RoO1xuICAgICAgICBsZW4xID0gYW5jaG9yIC0gYmVnMTtcbiAgICAgICAgYmVnMiA9IGFuY2hvcjtcbiAgICAgICAgbGVuMiA9IGNoYXJzQXJnLmxlbmd0aCAtIGJlZzI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgc3RhdGUnKTtcbiAgICB9XG4gICAgbGFzdGNoYXIgPSBQSFJBU0VfRU5EO1xuICAgIGlmIChsZW4xID4gTUFYX1BIUkFTRSkge1xuICAgICAgbGVuMSA9IE1BWF9QSFJBU0U7XG4gICAgICBsYXN0Y2hhciA9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIGxlbjIgPSAwO1xuICAgIH0gZWxzZSBpZiAobGVuMSArIGxlbjIgPiBNQVhfUEhSQVNFKSB7XG4gICAgICBsYXN0Y2hhciA9IFBIUkFTRV9DT05USU5VRTtcbiAgICAgIGxlbjIgPSBNQVhfUEhSQVNFIC0gbGVuMTtcbiAgICB9XG4gICAgaWYgKGxlbjEgPiAwKSB7XG4gICAgICBodG1sICs9IHNwYW5CZWhpbmQ7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMSwgbGVuMSwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgICBwcmV2ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxlbjIgPiAwKSB7XG4gICAgICBodG1sICs9IHNwYW5SZW1haW5kZXI7XG4gICAgICBodG1sICs9IHN1YlBocmFzZShtb2RlLCBjaGFyc0FyZywgYmVnMiwgbGVuMiwgcHJldik7XG4gICAgICBodG1sICs9IHNwYW5lbmQ7XG4gICAgfVxuICAgIHJldHVybiBodG1sICsgbGFzdGNoYXI7XG4gIH07XG4gIGNvbnN0IGRpc3BsYXlGb3J3YXJkID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCwgc3BhbkFoZWFkKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcbiAgICBsZXQgYmVnMTtcbiAgICBsZXQgbGVuMTtcbiAgICBsZXQgYmVnMjtcbiAgICBsZXQgbGVuMjtcbiAgICBsZXQgbGFzdGNoYXIgPSBQSFJBU0VfRU5EO1xuICAgIGNvbnN0IHNwYW5SZW1haW5kZXIgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX1JFTUFJTkRFUn1cIj5gO1xuICAgIGNvbnN0IHNwYW5lbmQgPSAnPC9zcGFuPic7XG4gICAgbGV0IHByZXYgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICBodG1sICs9IFBIUkFTRV9FTVBUWTtcbiAgICAgIC8qIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgY2FzZSBpZC5OT01BVENIOlxuICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgIGJlZzEgPSBpbmRleDtcbiAgICAgICAgbGVuMSA9IDA7XG4gICAgICAgIGJlZzIgPSBpbmRleDtcbiAgICAgICAgbGVuMiA9IGNoYXJzQXJnLmxlbmd0aCAtIGJlZzI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgYmVnMSA9IGluZGV4O1xuICAgICAgICBsZW4xID0gbGVuZ3RoO1xuICAgICAgICBiZWcyID0gaW5kZXggKyBsZW4xO1xuICAgICAgICBsZW4yID0gY2hhcnNBcmcubGVuZ3RoIC0gYmVnMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICAgIH1cbiAgICBsYXN0Y2hhciA9IFBIUkFTRV9FTkQ7XG4gICAgaWYgKGxlbjEgPiBNQVhfUEhSQVNFKSB7XG4gICAgICBsZW4xID0gTUFYX1BIUkFTRTtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IDA7XG4gICAgfSBlbHNlIGlmIChsZW4xICsgbGVuMiA+IE1BWF9QSFJBU0UpIHtcbiAgICAgIGxhc3RjaGFyID0gUEhSQVNFX0NPTlRJTlVFO1xuICAgICAgbGVuMiA9IE1BWF9QSFJBU0UgLSBsZW4xO1xuICAgIH1cbiAgICBpZiAobGVuMSA+IDApIHtcbiAgICAgIGh0bWwgKz0gc3BhbkFoZWFkO1xuICAgICAgaHRtbCArPSBzdWJQaHJhc2UobW9kZSwgY2hhcnNBcmcsIGJlZzEsIGxlbjEsIHByZXYpO1xuICAgICAgaHRtbCArPSBzcGFuZW5kO1xuICAgICAgcHJldiA9IHRydWU7XG4gICAgfVxuICAgIGlmIChsZW4yID4gMCkge1xuICAgICAgaHRtbCArPSBzcGFuUmVtYWluZGVyO1xuICAgICAgaHRtbCArPSBzdWJQaHJhc2UobW9kZSwgY2hhcnNBcmcsIGJlZzIsIGxlbjIsIHByZXYpO1xuICAgICAgaHRtbCArPSBzcGFuZW5kO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbCArIGxhc3RjaGFyO1xuICB9O1xuICAvKiBkaXNwbGF5IHBocmFzZXMgbWF0Y2hlZCBpbiBsb29rLWFoZWFkIG1vZGUgKi9cbiAgY29uc3QgZGlzcGxheUFoZWFkID0gZnVuY3Rpb24gKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCkge1xuICAgIGNvbnN0IHNwYW5BaGVhZCA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0FIRUFEfVwiPmA7XG4gICAgcmV0dXJuIGRpc3BsYXlGb3J3YXJkKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCwgc3BhbkFoZWFkKTtcbiAgfTtcbiAgLyogZGlzcGxheSBwaHJhc2VzIG1hdGNoZWQgaW4gbm9ybWFsIHBhcnNpbmcgbW9kZSAqL1xuICBjb25zdCBkaXNwbGF5Tm9uZSA9IGZ1bmN0aW9uIChtb2RlLCBjaGFyc0FyZywgc3RhdGUsIGluZGV4LCBsZW5ndGgpIHtcbiAgICBjb25zdCBzcGFuQWhlYWQgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPmA7XG4gICAgcmV0dXJuIGRpc3BsYXlGb3J3YXJkKG1vZGUsIGNoYXJzQXJnLCBzdGF0ZSwgaW5kZXgsIGxlbmd0aCwgc3BhbkFoZWFkKTtcbiAgfTtcbiAgLyogUmV0dXJucyB0aGUgZmlsdGVyZWQgcmVjb3JkcywgZm9ybWF0dGVkIGFzIGFuIEhUTUwgdGFibGUuICovXG4gIGNvbnN0IGh0bWxUYWJsZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgaWYgKHJ1bGVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGxldCBodG1sID0gJyc7XG4gICAgbGV0IHRoaXNMaW5lO1xuICAgIGxldCB0aGF0TGluZTtcbiAgICBsZXQgbG9va0FoZWFkO1xuICAgIGxldCBsb29rQmVoaW5kO1xuICAgIGxldCBsb29rQXJvdW5kO1xuICAgIGxldCBhbmNob3I7XG4gICAgaHRtbCArPSAnPHRyPjx0aD4oYSk8L3RoPjx0aD4oYik8L3RoPjx0aD4oYyk8L3RoPjx0aD4oZCk8L3RoPjx0aD4oZSk8L3RoPjx0aD4oZik8L3RoPic7XG4gICAgaHRtbCArPSAnPHRoPm9wZXJhdG9yPC90aD48dGg+cGhyYXNlPC90aD48L3RyPlxcbic7XG4gICAgY2lyY3VsYXIuZm9yRWFjaCgobGluZUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBsaW5lID0gcmVjb3Jkc1tsaW5lSW5kZXhdO1xuICAgICAgdGhpc0xpbmUgPSBsaW5lLnRoaXNMaW5lO1xuICAgICAgdGhhdExpbmUgPSBsaW5lLnRoYXRMaW5lICE9PSB1bmRlZmluZWQgPyBsaW5lLnRoYXRMaW5lIDogJy0tJztcbiAgICAgIGxvb2tBaGVhZCA9IGZhbHNlO1xuICAgICAgbG9va0JlaGluZCA9IGZhbHNlO1xuICAgICAgbG9va0Fyb3VuZCA9IGZhbHNlO1xuICAgICAgaWYgKGxpbmUubG9va0Fyb3VuZCA9PT0gaWQuTE9PS0FST1VORF9BSEVBRCkge1xuICAgICAgICBsb29rQWhlYWQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5sb29rQW5jaG9yO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLkFORCB8fCBsaW5lLm9wY29kZS50eXBlID09PSBpZC5OT1QpIHtcbiAgICAgICAgbG9va0FoZWFkID0gdHJ1ZTtcbiAgICAgICAgbG9va0Fyb3VuZCA9IHRydWU7XG4gICAgICAgIGFuY2hvciA9IGxpbmUucGhyYXNlSW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5sb29rQXJvdW5kID09PSBpZC5MT09LQVJPVU5EX0JFSElORCkge1xuICAgICAgICBsb29rQmVoaW5kID0gdHJ1ZTtcbiAgICAgICAgbG9va0Fyb3VuZCA9IHRydWU7XG4gICAgICAgIGFuY2hvciA9IGxpbmUubG9va0FuY2hvcjtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5CS0EgfHwgbGluZS5vcGNvZGUudHlwZSA9PT0gaWQuQktOKSB7XG4gICAgICAgIGxvb2tCZWhpbmQgPSB0cnVlO1xuICAgICAgICBsb29rQXJvdW5kID0gdHJ1ZTtcbiAgICAgICAgYW5jaG9yID0gbGluZS5waHJhc2VJbmRleDtcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgaHRtbCArPSBgPHRkPiR7dGhpc0xpbmV9PC90ZD48dGQ+JHt0aGF0TGluZX08L3RkPmA7XG4gICAgICBodG1sICs9IGA8dGQ+JHtsaW5lLnBocmFzZUluZGV4fTwvdGQ+YDtcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke2xpbmUucGhyYXNlTGVuZ3RofTwvdGQ+YDtcbiAgICAgIGh0bWwgKz0gYDx0ZD4ke2xpbmUuZGVwdGh9PC90ZD5gO1xuICAgICAgaHRtbCArPSAnPHRkPic7XG4gICAgICBzd2l0Y2ggKGxpbmUuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBpZC5BQ1RJVkU6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4mZGFycjsmbmJzcDs8L3NwYW4+YDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTUFUQ0h9XCI+JnVhcnI7TTwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLk5PTUFUQ0g6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX05PTUFUQ0h9XCI+JnVhcnI7Tjwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19FTVBUWX1cIj4mdWFycjtFPC9zcGFuPmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0FDVElWRX1cIj4tLTwvc3Bhbj5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaHRtbCArPSAnPC90ZD4nO1xuICAgICAgaHRtbCArPSAnPHRkPic7XG4gICAgICBodG1sICs9IHRoYXQuaW5kZW50KGxpbmUuZGVwdGgpO1xuICAgICAgaWYgKGxvb2tBaGVhZCkge1xuICAgICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTE9PS0FIRUFEfVwiPmA7XG4gICAgICB9IGVsc2UgaWYgKGxvb2tCZWhpbmQpIHtcbiAgICAgICAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0xPT0tCRUhJTkR9XCI+YDtcbiAgICAgIH1cbiAgICAgIGh0bWwgKz0gdXRpbHMub3Bjb2RlVG9TdHJpbmcobGluZS5vcGNvZGUudHlwZSk7XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuUk5NKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke3J1bGVzW2xpbmUub3Bjb2RlLmluZGV4XS5uYW1lfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5CS1IpIHtcbiAgICAgICAgY29uc3QgY2FzZXR5cGUgPSBsaW5lLm9wY29kZS5ia3JDYXNlID09PSBpZC5CS1JfTU9ERV9DSSA/ICclaScgOiAnJXMnO1xuICAgICAgICBjb25zdCBtb2RldHlwZSA9IGxpbmUub3Bjb2RlLmJrck1vZGUgPT09IGlkLkJLUl9NT0RFX1VNID8gJyV1JyA6ICclcCc7XG4gICAgICAgIGh0bWwgKz0gYChcXFxcJHtjYXNldHlwZX0ke21vZGV0eXBlfSR7cnVsZXNbbGluZS5vcGNvZGUuaW5kZXhdLm5hbWV9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlVEVCkge1xuICAgICAgICBodG1sICs9IGAoJHt1ZHRzW2xpbmUub3Bjb2RlLmluZGV4XS5uYW1lfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5UUkcpIHtcbiAgICAgICAgaHRtbCArPSBgKCR7ZGlzcGxheVRyZyhtb2RlLCBsaW5lLm9wY29kZSl9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmUub3Bjb2RlLnR5cGUgPT09IGlkLlRCUykge1xuICAgICAgICBodG1sICs9IGAoJHtkaXNwbGF5VGJzKG1vZGUsIGxpbmUub3Bjb2RlKX0pIGA7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5vcGNvZGUudHlwZSA9PT0gaWQuVExTKSB7XG4gICAgICAgIGh0bWwgKz0gYCgke2Rpc3BsYXlUbHMobW9kZSwgbGluZS5vcGNvZGUpfSkgYDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lLm9wY29kZS50eXBlID09PSBpZC5SRVApIHtcbiAgICAgICAgaHRtbCArPSBgKCR7ZGlzcGxheVJlcChtb2RlLCBsaW5lLm9wY29kZSl9KSBgO1xuICAgICAgfVxuICAgICAgaWYgKGxvb2tBcm91bmQpIHtcbiAgICAgICAgaHRtbCArPSAnPC9zcGFuPic7XG4gICAgICB9XG4gICAgICBodG1sICs9ICc8L3RkPic7XG4gICAgICBodG1sICs9ICc8dGQ+JztcbiAgICAgIGlmIChsb29rQmVoaW5kKSB7XG4gICAgICAgIGh0bWwgKz0gZGlzcGxheUJlaGluZChtb2RlLCBjaGFycywgbGluZS5zdGF0ZSwgbGluZS5waHJhc2VJbmRleCwgbGluZS5waHJhc2VMZW5ndGgsIGFuY2hvcik7XG4gICAgICB9IGVsc2UgaWYgKGxvb2tBaGVhZCkge1xuICAgICAgICBodG1sICs9IGRpc3BsYXlBaGVhZChtb2RlLCBjaGFycywgbGluZS5zdGF0ZSwgbGluZS5waHJhc2VJbmRleCwgbGluZS5waHJhc2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCArPSBkaXNwbGF5Tm9uZShtb2RlLCBjaGFycywgbGluZS5zdGF0ZSwgbGluZS5waHJhc2VJbmRleCwgbGluZS5waHJhc2VMZW5ndGgpO1xuICAgICAgfVxuICAgICAgaHRtbCArPSAnPC90ZD48L3RyPlxcbic7XG4gICAgfSk7XG4gICAgaHRtbCArPSAnPHRyPjx0aD4oYSk8L3RoPjx0aD4oYik8L3RoPjx0aD4oYyk8L3RoPjx0aD4oZCk8L3RoPjx0aD4oZSk8L3RoPjx0aD4oZik8L3RoPic7XG4gICAgaHRtbCArPSAnPHRoPm9wZXJhdG9yPC90aD48dGg+cGhyYXNlPC90aD48L3RyPlxcbic7XG4gICAgaHRtbCArPSAnPC90YWJsZT5cXG4nO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xuICAvLyBUcmFuc2xhdGUgdGhlIHRyYWNlIHJlY29yZHMgdG8gSFRNTCBmb3JtYXQuXG4gIC8vIC0gKm1vZGVhcmcqIC0gY2FuIGJlIGBcImFzY2lpXCJgLCBgXCJkZWNpbWFsXCJgLCBgXCJoZXhhZGVjaW1hbFwiYCBvciBgXCJ1bmljb2RlXCJgLlxuICAvLyBEZXRlcm1pbmVzIHRoZSBmb3JtYXQgb2YgdGhlIHN0cmluZyBjaGFyYWN0ZXIgY29kZSBkaXNwbGF5LlxuICAvLyAtICpjYXB0aW9uKiAtIG9wdGlvbmFsIGNhcHRpb24gZm9yIHRoZSBIVE1MIHRhYmxlLlxuICB0aGlzLnRvSHRtbCA9IGZ1bmN0aW9uIChtb2RlYXJnLCBjYXB0aW9uKSB7XG4gICAgLyogd3JpdGVzIHRoZSB0cmFjZSByZWNvcmRzIGFzIGEgdGFibGUgaW4gYSBjb21wbGV0ZSBodG1sIHBhZ2UgKi9cbiAgICBsZXQgbW9kZSA9IE1PREVfQVNDSUk7XG4gICAgaWYgKHR5cGVvZiBtb2RlYXJnID09PSAnc3RyaW5nJyAmJiBtb2RlYXJnLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjb25zdCBtb2RlaW4gPSBtb2RlYXJnLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgMyk7XG4gICAgICBpZiAobW9kZWluID09PSAnaGV4Jykge1xuICAgICAgICBtb2RlID0gTU9ERV9IRVg7XG4gICAgICB9IGVsc2UgaWYgKG1vZGVpbiA9PT0gJ2RlYycpIHtcbiAgICAgICAgbW9kZSA9IE1PREVfREVDO1xuICAgICAgfSBlbHNlIGlmIChtb2RlaW4gPT09ICd1bmknKSB7XG4gICAgICAgIG1vZGUgPSBNT0RFX1VOSUNPREU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBodG1sID0gJyc7XG4gICAgaHRtbCArPSBodG1sSGVhZGVyKG1vZGUsIGNhcHRpb24pO1xuICAgIGh0bWwgKz0gaHRtbFRhYmxlKG1vZGUpO1xuICAgIGh0bWwgKz0gaHRtbEZvb3RlcigpO1xuICAgIHJldHVybiBodG1sO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/trace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js":
/*!******************************************************!*\
  !*** ./node_modules/apg-js/src/apg-lib/utilities.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\n\nconst style = __webpack_require__(/*! ./style */ \"(ssr)/./node_modules/apg-js/src/apg-lib/style.js\");\nconst converter = __webpack_require__(/*! ../apg-conv-api/converter */ \"(ssr)/./node_modules/apg-js/src/apg-conv-api/converter.js\");\nconst emitCss = __webpack_require__(/*! ./emitcss */ \"(ssr)/./node_modules/apg-js/src/apg-lib/emitcss.js\");\nconst id = __webpack_require__(/*! ./identifiers */ \"(ssr)/./node_modules/apg-js/src/apg-lib/identifiers.js\");\n\nconst thisFileName = 'utilities.js: ';\n\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */\n/* used by multiple phrase handling functions */\nconst getBounds = function (length, begArg, len) {\n  let end;\n  let beg = begArg;\n  const TRUE = true;\n  while (TRUE) {\n    if (length <= 0) {\n      beg = 0;\n      end = 0;\n      break;\n    }\n    if (typeof beg !== 'number') {\n      beg = 0;\n      end = length;\n      break;\n    }\n    if (beg >= length) {\n      beg = length;\n      end = length;\n      break;\n    }\n    if (typeof len !== 'number') {\n      end = length;\n      break;\n    }\n    end = beg + len;\n    if (end > length) {\n      end = length;\n      break;\n    }\n    break;\n  }\n  return {\n    beg,\n    end,\n  };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function (html, titleArg) {\n  let title;\n  if (typeof html !== 'string') {\n    throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n  }\n  if (typeof titleArg !== 'string') {\n    title = 'htmlToPage';\n  } else {\n    title = titleArg;\n  }\n  let page = '';\n  page += '<!DOCTYPE html>\\n';\n  page += '<html lang=\"en\">\\n';\n  page += '<head>\\n';\n  page += '<meta charset=\"utf-8\">\\n';\n  page += `<title>${title}</title>\\n`;\n  page += '<style>\\n';\n  page += emitCss();\n  page += '</style>\\n';\n  page += '</head>\\n<body>\\n';\n  page += `<p>${new Date()}</p>\\n`;\n  page += html;\n  page += '</body>\\n</html>\\n';\n  return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function (result, caption) {\n  let cap = null;\n  if (typeof caption === 'string' && caption !== '') {\n    cap = caption;\n  }\n  let success;\n  let state;\n  if (result.success === true) {\n    success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n  } else {\n    success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n  }\n  if (result.state === id.EMPTY) {\n    state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n  } else if (result.state === id.MATCH) {\n    state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n  } else if (result.state === id.NOMATCH) {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n  } else {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n  }\n  let html = '';\n  html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n  if (cap) {\n    html += `<caption>${cap}</caption>\\n`;\n  }\n  html += '<tr><th>state item</th><th>value</th><th>description</th></tr>\\n';\n  html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n  html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n  html += '<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n';\n  html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n  html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n  html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n  html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n  html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n  html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n  html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n  html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n  html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n  html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n  html += '</table>\\n';\n  return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function (chars, phraseIndex, phraseLength) {\n  let beg;\n  let end;\n  if (typeof phraseIndex === 'number') {\n    if (phraseIndex >= chars.length) {\n      return '';\n    }\n    beg = phraseIndex < 0 ? 0 : phraseIndex;\n  } else {\n    beg = 0;\n  }\n  if (typeof phraseLength === 'number') {\n    if (phraseLength <= 0) {\n      return '';\n    }\n    end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n  } else {\n    end = chars.length;\n  }\n  if (beg < end) {\n    return converter.encode('UTF16LE', chars.slice(beg, end)).toString('utf16le');\n  }\n  return '';\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function (string) {\n  return converter.decode('STRING', string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function (type) {\n  let ret = 'unknown';\n  switch (type) {\n    case id.ALT:\n      ret = 'ALT';\n      break;\n    case id.CAT:\n      ret = 'CAT';\n      break;\n    case id.RNM:\n      ret = 'RNM';\n      break;\n    case id.UDT:\n      ret = 'UDT';\n      break;\n    case id.AND:\n      ret = 'AND';\n      break;\n    case id.NOT:\n      ret = 'NOT';\n      break;\n    case id.REP:\n      ret = 'REP';\n      break;\n    case id.TRG:\n      ret = 'TRG';\n      break;\n    case id.TBS:\n      ret = 'TBS';\n      break;\n    case id.TLS:\n      ret = 'TLS';\n      break;\n    case id.BKR:\n      ret = 'BKR';\n      break;\n    case id.BKA:\n      ret = 'BKA';\n      break;\n    case id.BKN:\n      ret = 'BKN';\n      break;\n    case id.ABG:\n      ret = 'ABG';\n      break;\n    case id.AEN:\n      ret = 'AEN';\n      break;\n    default:\n      throw new Error('unrecognized opcode');\n  }\n  return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function (state) {\n  let ret = 'unknown';\n  switch (state) {\n    case id.ACTIVE:\n      ret = 'ACTIVE';\n      break;\n    case id.MATCH:\n      ret = 'MATCH';\n      break;\n    case id.EMPTY:\n      ret = 'EMPTY';\n      break;\n    case id.NOMATCH:\n      ret = 'NOMATCH';\n      break;\n    default:\n      throw new Error('unrecognized state');\n  }\n  return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n  'NUL',\n  'SOH',\n  'STX',\n  'ETX',\n  'EOT',\n  'ENQ',\n  'ACK',\n  'BEL',\n  'BS',\n  'TAB',\n  'LF',\n  'VT',\n  'FF',\n  'CR',\n  'SO',\n  'SI',\n  'DLE',\n  'DC1',\n  'DC2',\n  'DC3',\n  'DC4',\n  'NAK',\n  'SYN',\n  'ETB',\n  'CAN',\n  'EM',\n  'SUB',\n  'ESC',\n  'FS',\n  'GS',\n  'RS',\n  'US',\n  '&nbsp;',\n  '!',\n  '&#34;',\n  '#',\n  '$',\n  '%',\n  '&#38;',\n  '&#39;',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '&#60;',\n  '=',\n  '&#62;',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '&#92;',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  'DEL',\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function (char) {\n  let ch = char.toString(16).toUpperCase();\n  switch (ch.length) {\n    case 1:\n    case 3:\n    case 7:\n      ch = `0${ch}`;\n      break;\n    case 2:\n    case 6:\n      ch = `00${ch}`;\n      break;\n    case 4:\n      break;\n    case 5:\n      ch = `000${ch}`;\n      break;\n    default:\n      throw new Error('unrecognized option');\n  }\n  return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += chars[bounds.beg];\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,${chars[i]}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\x${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\x${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\nexports.charsToHtmlEntities = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      ret += `&#x${chars[i].toString(16)};`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n  if (char >= 0xd800 && char <= 0xdfff) {\n    return false;\n  }\n  if (char > 0x10ffff) {\n    return false;\n  }\n  return true;\n}\nexports.charsToUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      if (isUnicode(chars[i])) {\n        ret += `&#${chars[i]};`;\n      } else {\n        ret += ` U+${exports.charToHex(chars[i])}`;\n      }\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\u${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\u${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      ret += String.fromCharCode(char);\n    } else {\n      ret += `\\\\x${exports.charToHex(char)}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function (chars, beg, len) {\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n  }\n  let html = '';\n  let char;\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    char = chars[i];\n    if (char < 32 || char === 127) {\n      /* control characters */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">${exports.asciiChars[char]}</span>`;\n    } else if (char > 127) {\n      /* non-ASCII */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${exports.charToHex(char)}</span>`;\n    } else {\n      /* printing ASCII, 32 <= char <= 126 */\n      html += exports.asciiChars[char];\n    }\n  }\n  return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function (str) {\n  const chars = converter.decode('STRING', str);\n  return this.charsToAsciiHtml(chars);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBnLWpzL3NyYy9hcGctbGliL3V0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxpRUFBUztBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBMkI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMscUVBQVc7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLDZFQUFlOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQsSUFBSTtBQUNKLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUMsSUFBSTtBQUNKLDRCQUE0QixrQkFBa0I7QUFDOUMsSUFBSTtBQUNKLDRCQUE0Qixv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TixtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFCQUFxQixJQUFJLHlCQUF5QjtBQUNoRixNQUFNO0FBQ047QUFDQSw4QkFBOEIscUJBQXFCLE1BQU0sd0JBQXdCO0FBQ2pGLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9hcGctanMvc3JjL2FwZy1saWIvdXRpbGl0aWVzLmpzPzA4NDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuLyogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgY29weXJpZ2h0OiBDb3B5cmlnaHQgKGMpIDIwMjEgTG93ZWxsIEQuIFRob21hcywgYWxsIHJpZ2h0cyByZXNlcnZlZFxuICogICAgIGxpY2Vuc2U6IEJTRC0yLUNsYXVzZSAoaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMi1DbGF1c2UpXG4gKiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLy8gVGhpcyBtb2R1bGUgZXhwb3J0cyBhIHZhcmlldHkgb2YgdXRpbGl0eSBmdW5jdGlvbnMgdGhhdCBzdXBwb3J0XG4vLyBbYGFwZ2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9sZHRob21hcy9hcGctanMyKSwgW2BhcGctbGliYF0oaHR0cHM6Ly9naXRodWIuY29tL2xkdGhvbWFzL2FwZy1qczItbGliKVxuLy8gYW5kIHRoZSBnZW5lcmF0ZWQgcGFyc2VyIGFwcGxpY2F0aW9ucy5cblxuY29uc3Qgc3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG5jb25zdCBjb252ZXJ0ZXIgPSByZXF1aXJlKCcuLi9hcGctY29udi1hcGkvY29udmVydGVyJyk7XG5jb25zdCBlbWl0Q3NzID0gcmVxdWlyZSgnLi9lbWl0Y3NzJyk7XG5jb25zdCBpZCA9IHJlcXVpcmUoJy4vaWRlbnRpZmllcnMnKTtcblxuY29uc3QgdGhpc0ZpbGVOYW1lID0gJ3V0aWxpdGllcy5qczogJztcblxuLyogdHJhbnNsYXRlIChpbXBsaWVkKSBwaHJhc2UgYmVnaW5uaW5nIGNoYXJhY3RlciBhbmQgbGVuZ3RoIHRvIGFjdHVhbCBmaXJzdCBhbmQgbGFzdCBjaGFyYWN0ZXIgaW5kZXhlcyAqL1xuLyogdXNlZCBieSBtdWx0aXBsZSBwaHJhc2UgaGFuZGxpbmcgZnVuY3Rpb25zICovXG5jb25zdCBnZXRCb3VuZHMgPSBmdW5jdGlvbiAobGVuZ3RoLCBiZWdBcmcsIGxlbikge1xuICBsZXQgZW5kO1xuICBsZXQgYmVnID0gYmVnQXJnO1xuICBjb25zdCBUUlVFID0gdHJ1ZTtcbiAgd2hpbGUgKFRSVUUpIHtcbiAgICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICAgIGJlZyA9IDA7XG4gICAgICBlbmQgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmVnICE9PSAnbnVtYmVyJykge1xuICAgICAgYmVnID0gMDtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYmVnID49IGxlbmd0aCkge1xuICAgICAgYmVnID0gbGVuZ3RoO1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGVuICE9PSAnbnVtYmVyJykge1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVuZCA9IGJlZyArIGxlbjtcbiAgICBpZiAoZW5kID4gbGVuZ3RoKSB7XG4gICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBiZWcsXG4gICAgZW5kLFxuICB9O1xufTtcbi8vIEdlbmVyYXRlcyBhIGNvbXBsZXRlLCBtaW5pbWFsIEhUTUw1IHBhZ2UsIGluc2VydGluZyB0aGUgdXNlcidzIEhUTUwgdGV4dCBvbiB0aGUgcGFnZS5cbi8vIC0gKmh0bWwqIC0gdGhlIHBhZ2UgdGV4dCBpbiBIVE1MIGZvcm1hdFxuLy8gLSAqdGl0bGUqIC0gdGhlIEhUTUwgcGFnZSBgPHRpdGxlPmAgLSBkZWZhdWx0cyB0byBgaHRtbFRvUGFnZWAuXG5leHBvcnRzLmh0bWxUb1BhZ2UgPSBmdW5jdGlvbiAoaHRtbCwgdGl0bGVBcmcpIHtcbiAgbGV0IHRpdGxlO1xuICBpZiAodHlwZW9mIGh0bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1odG1sVG9QYWdlOiBpbnB1dCBIVE1MIGlzIG5vdCBhIHN0cmluZ2ApO1xuICB9XG4gIGlmICh0eXBlb2YgdGl0bGVBcmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGl0bGUgPSAnaHRtbFRvUGFnZSc7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSB0aXRsZUFyZztcbiAgfVxuICBsZXQgcGFnZSA9ICcnO1xuICBwYWdlICs9ICc8IURPQ1RZUEUgaHRtbD5cXG4nO1xuICBwYWdlICs9ICc8aHRtbCBsYW5nPVwiZW5cIj5cXG4nO1xuICBwYWdlICs9ICc8aGVhZD5cXG4nO1xuICBwYWdlICs9ICc8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cXG4nO1xuICBwYWdlICs9IGA8dGl0bGU+JHt0aXRsZX08L3RpdGxlPlxcbmA7XG4gIHBhZ2UgKz0gJzxzdHlsZT5cXG4nO1xuICBwYWdlICs9IGVtaXRDc3MoKTtcbiAgcGFnZSArPSAnPC9zdHlsZT5cXG4nO1xuICBwYWdlICs9ICc8L2hlYWQ+XFxuPGJvZHk+XFxuJztcbiAgcGFnZSArPSBgPHA+JHtuZXcgRGF0ZSgpfTwvcD5cXG5gO1xuICBwYWdlICs9IGh0bWw7XG4gIHBhZ2UgKz0gJzwvYm9keT5cXG48L2h0bWw+XFxuJztcbiAgcmV0dXJuIHBhZ2U7XG59O1xuLy8gRm9ybWF0cyB0aGUgcmV0dXJuZWQgb2JqZWN0IGZyb20gYHBhcnNlci5wYXJzZSgpYFxuLy8gaW50byBhbiBIVE1MIHRhYmxlLlxuLy8gYGBgXG4vLyByZXR1cm4ge1xuLy8gICBzdWNjZXNzIDogc3lzRGF0YS5zdWNjZXNzLFxuLy8gICBzdGF0ZSA6IHN5c0RhdGEuc3RhdGUsXG4vLyAgIGxlbmd0aCA6IGNoYXJzTGVuZ3RoLFxuLy8gICBtYXRjaGVkIDogc3lzRGF0YS5waHJhc2VMZW5ndGgsXG4vLyAgIG1heE1hdGNoZWQgOiBtYXhNYXRjaGVkLFxuLy8gICBtYXhUcmVlRGVwdGggOiBtYXhUcmVlRGVwdGgsXG4vLyAgIG5vZGVIaXRzIDogbm9kZUhpdHMsXG4vLyAgIGlucHV0TGVuZ3RoIDogY2hhcnMubGVuZ3RoLFxuLy8gICBzdWJCZWdpbiA6IGNoYXJzQmVnaW4sXG4vLyAgIHN1YkVuZCA6IGNoYXJzRW5kLFxuLy8gICBzdWJMZW5ndGggOiBjaGFyc0xlbmd0aFxuLy8gfTtcbi8vIGBgYFxuZXhwb3J0cy5wYXJzZXJSZXN1bHRUb0h0bWwgPSBmdW5jdGlvbiAocmVzdWx0LCBjYXB0aW9uKSB7XG4gIGxldCBjYXAgPSBudWxsO1xuICBpZiAodHlwZW9mIGNhcHRpb24gPT09ICdzdHJpbmcnICYmIGNhcHRpb24gIT09ICcnKSB7XG4gICAgY2FwID0gY2FwdGlvbjtcbiAgfVxuICBsZXQgc3VjY2VzcztcbiAgbGV0IHN0YXRlO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MgPT09IHRydWUpIHtcbiAgICBzdWNjZXNzID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj50cnVlPC9zcGFuPmA7XG4gIH0gZWxzZSB7XG4gICAgc3VjY2VzcyA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5mYWxzZTwvc3Bhbj5gO1xuICB9XG4gIGlmIChyZXN1bHQuc3RhdGUgPT09IGlkLkVNUFRZKSB7XG4gICAgc3RhdGUgPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPkVNUFRZPC9zcGFuPmA7XG4gIH0gZWxzZSBpZiAocmVzdWx0LnN0YXRlID09PSBpZC5NQVRDSCkge1xuICAgIHN0YXRlID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19NQVRDSH1cIj5NQVRDSDwvc3Bhbj5gO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gaWQuTk9NQVRDSCkge1xuICAgIHN0YXRlID0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPk5PTUFUQ0g8L3NwYW4+YDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj51bnJlY29nbml6ZWQ8L3NwYW4+YDtcbiAgfVxuICBsZXQgaHRtbCA9ICcnO1xuICBodG1sICs9IGA8dGFibGUgY2xhc3M9XCIke3N0eWxlLkNMQVNTX1NUQVRFfVwiPlxcbmA7XG4gIGlmIChjYXApIHtcbiAgICBodG1sICs9IGA8Y2FwdGlvbj4ke2NhcH08L2NhcHRpb24+XFxuYDtcbiAgfVxuICBodG1sICs9ICc8dHI+PHRoPnN0YXRlIGl0ZW08L3RoPjx0aD52YWx1ZTwvdGg+PHRoPmRlc2NyaXB0aW9uPC90aD48L3RyPlxcbic7XG4gIGh0bWwgKz0gYDx0cj48dGQ+cGFyc2VyIHN1Y2Nlc3M8L3RkPjx0ZD4ke3N1Y2Nlc3N9PC90ZD5cXG5gO1xuICBodG1sICs9IGA8dGQ+PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPnRydWU8L3NwYW4+IGlmIHRoZSBwYXJzZSBzdWNjZWVkZWQsXFxuYDtcbiAgaHRtbCArPSBgIDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19OT01BVENIfVwiPmZhbHNlPC9zcGFuPiBvdGhlcndpc2VgO1xuICBodG1sICs9ICc8YnI+PGk+Tk9URTogZm9yIHN1Y2Nlc3MsIGVudGlyZSBzdHJpbmcgbXVzdCBiZSBtYXRjaGVkPC9pPjwvdGQ+PC90cj5cXG4nO1xuICBodG1sICs9IGA8dHI+PHRkPnBhcnNlciBzdGF0ZTwvdGQ+PHRkPiR7c3RhdGV9PC90ZD5cXG5gO1xuICBodG1sICs9IGA8dGQ+PHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX0VNUFRZfVwiPkVNUFRZPC9zcGFuPiwgYDtcbiAgaHRtbCArPSBgPHNwYW4gY2xhc3M9XCIke3N0eWxlLkNMQVNTX01BVENIfVwiPk1BVENIPC9zcGFuPiBvciBcXG5gO1xuICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfTk9NQVRDSH1cIj5OT01BVENIPC9zcGFuPjwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPnN0cmluZyBsZW5ndGg8L3RkPjx0ZD4ke3Jlc3VsdC5sZW5ndGh9PC90ZD48dGQ+bGVuZ3RoIG9mIHRoZSBpbnB1dCAoc3ViKXN0cmluZzwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPm1hdGNoZWQgbGVuZ3RoPC90ZD48dGQ+JHtyZXN1bHQubWF0Y2hlZH08L3RkPjx0ZD5udW1iZXIgb2YgaW5wdXQgc3RyaW5nIGNoYXJhY3RlcnMgbWF0Y2hlZDwvdGQ+PC90cj5cXG5gO1xuICBodG1sICs9IGA8dHI+PHRkPm1heCBtYXRjaGVkPC90ZD48dGQ+JHtyZXN1bHQubWF4TWF0Y2hlZH08L3RkPjx0ZD5tYXhpbXVtIG51bWJlciBvZiBpbnB1dCBzdHJpbmcgY2hhcmFjdGVycyBtYXRjaGVkPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+bWF4IHRyZWUgZGVwdGg8L3RkPjx0ZD4ke3Jlc3VsdC5tYXhUcmVlRGVwdGh9PC90ZD48dGQ+bWF4aW11bSBkZXB0aCBvZiB0aGUgcGFyc2UgdHJlZSByZWFjaGVkPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+bm9kZSBoaXRzPC90ZD48dGQ+JHtyZXN1bHQubm9kZUhpdHN9PC90ZD48dGQ+bnVtYmVyIG9mIHBhcnNlIHRyZWUgbm9kZSBoaXRzIChvcGNvZGUgZnVuY3Rpb24gY2FsbHMpPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+aW5wdXQgbGVuZ3RoPC90ZD48dGQ+JHtyZXN1bHQuaW5wdXRMZW5ndGh9PC90ZD48dGQ+bGVuZ3RoIG9mIGZ1bGwgaW5wdXQgc3RyaW5nPC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+c3ViLXN0cmluZyBiZWdpbjwvdGQ+PHRkPiR7cmVzdWx0LnN1YkJlZ2lufTwvdGQ+PHRkPnN1Yi1zdHJpbmcgZmlyc3QgY2hhcmFjdGVyIGluZGV4PC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+c3ViLXN0cmluZyBlbmQ8L3RkPjx0ZD4ke3Jlc3VsdC5zdWJFbmR9PC90ZD48dGQ+c3ViLXN0cmluZyBlbmQtb2Ytc3RyaW5nIGluZGV4PC90ZD48L3RyPlxcbmA7XG4gIGh0bWwgKz0gYDx0cj48dGQ+c3ViLXN0cmluZyBsZW5ndGg8L3RkPjx0ZD4ke3Jlc3VsdC5zdWJMZW5ndGh9PC90ZD48dGQ+c3ViLXN0cmluZyBsZW5ndGg8L3RkPjwvdHI+XFxuYDtcbiAgaHRtbCArPSAnPC90YWJsZT5cXG4nO1xuICByZXR1cm4gaHRtbDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGludGVnZXIgY2hhcmFjdGVyIGNvZGVzIGludG8gYSBzdHJpbmcuXG4vLyBWZXJ5IHVzZWZ1bCBpbiBjYWxsYmFjayBmdW5jdGlvbnMgdG8gdHJhbnNsYXRlIHRoZSBtYXRjaGVkIHBocmFzZXMgaW50byBzdHJpbmdzLlxuZXhwb3J0cy5jaGFyc1RvU3RyaW5nID0gZnVuY3Rpb24gKGNoYXJzLCBwaHJhc2VJbmRleCwgcGhyYXNlTGVuZ3RoKSB7XG4gIGxldCBiZWc7XG4gIGxldCBlbmQ7XG4gIGlmICh0eXBlb2YgcGhyYXNlSW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHBocmFzZUluZGV4ID49IGNoYXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBiZWcgPSBwaHJhc2VJbmRleCA8IDAgPyAwIDogcGhyYXNlSW5kZXg7XG4gIH0gZWxzZSB7XG4gICAgYmVnID0gMDtcbiAgfVxuICBpZiAodHlwZW9mIHBocmFzZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAocGhyYXNlTGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZW5kID0gcGhyYXNlTGVuZ3RoID4gY2hhcnMubGVuZ3RoIC0gYmVnID8gY2hhcnMubGVuZ3RoIDogYmVnICsgcGhyYXNlTGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGVuZCA9IGNoYXJzLmxlbmd0aDtcbiAgfVxuICBpZiAoYmVnIDwgZW5kKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRlci5lbmNvZGUoJ1VURjE2TEUnLCBjaGFycy5zbGljZShiZWcsIGVuZCkpLnRvU3RyaW5nKCd1dGYxNmxlJyk7XG4gIH1cbiAgcmV0dXJuICcnO1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBpbnRlZ2VyIGNoYXJhY3RlciBjb2Rlcy5cbmV4cG9ydHMuc3RyaW5nVG9DaGFycyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIGNvbnZlcnRlci5kZWNvZGUoJ1NUUklORycsIHN0cmluZyk7XG59O1xuLy8gVHJhbnNsYXRlcyBhbiBvcGNvZGUgaWRlbnRpZmllciBpbnRvIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nLlxuZXhwb3J0cy5vcGNvZGVUb1N0cmluZyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gIGxldCByZXQgPSAndW5rbm93bic7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgaWQuQUxUOlxuICAgICAgcmV0ID0gJ0FMVCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkNBVDpcbiAgICAgIHJldCA9ICdDQVQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5STk06XG4gICAgICByZXQgPSAnUk5NJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuVURUOlxuICAgICAgcmV0ID0gJ1VEVCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkFORDpcbiAgICAgIHJldCA9ICdBTkQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5OT1Q6XG4gICAgICByZXQgPSAnTk9UJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuUkVQOlxuICAgICAgcmV0ID0gJ1JFUCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLlRSRzpcbiAgICAgIHJldCA9ICdUUkcnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5UQlM6XG4gICAgICByZXQgPSAnVEJTJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuVExTOlxuICAgICAgcmV0ID0gJ1RMUyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkJLUjpcbiAgICAgIHJldCA9ICdCS1InO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5CS0E6XG4gICAgICByZXQgPSAnQktBJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuQktOOlxuICAgICAgcmV0ID0gJ0JLTic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkFCRzpcbiAgICAgIHJldCA9ICdBQkcnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5BRU46XG4gICAgICByZXQgPSAnQUVOJztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBvcGNvZGUnKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYW4gc3RhdGUgaWRlbnRpZmllciBpbnRvIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nLlxuZXhwb3J0cy5zdGF0ZVRvU3RyaW5nID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIGxldCByZXQgPSAndW5rbm93bic7XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgICBjYXNlIGlkLkFDVElWRTpcbiAgICAgIHJldCA9ICdBQ1RJVkUnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBpZC5NQVRDSDpcbiAgICAgIHJldCA9ICdNQVRDSCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGlkLkVNUFRZOlxuICAgICAgcmV0ID0gJ0VNUFRZJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgaWQuTk9NQVRDSDpcbiAgICAgIHJldCA9ICdOT01BVENIJztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCBzdGF0ZScpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gQXJyYXkgd2hpY2ggdHJhbnNsYXRlcyBhbGwgMTI4LCA3LWJpdCBBU0NJSSBjaGFyYWN0ZXIgY29kZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBIVE1MIGZvcm1hdC5cbmV4cG9ydHMuYXNjaWlDaGFycyA9IFtcbiAgJ05VTCcsXG4gICdTT0gnLFxuICAnU1RYJyxcbiAgJ0VUWCcsXG4gICdFT1QnLFxuICAnRU5RJyxcbiAgJ0FDSycsXG4gICdCRUwnLFxuICAnQlMnLFxuICAnVEFCJyxcbiAgJ0xGJyxcbiAgJ1ZUJyxcbiAgJ0ZGJyxcbiAgJ0NSJyxcbiAgJ1NPJyxcbiAgJ1NJJyxcbiAgJ0RMRScsXG4gICdEQzEnLFxuICAnREMyJyxcbiAgJ0RDMycsXG4gICdEQzQnLFxuICAnTkFLJyxcbiAgJ1NZTicsXG4gICdFVEInLFxuICAnQ0FOJyxcbiAgJ0VNJyxcbiAgJ1NVQicsXG4gICdFU0MnLFxuICAnRlMnLFxuICAnR1MnLFxuICAnUlMnLFxuICAnVVMnLFxuICAnJm5ic3A7JyxcbiAgJyEnLFxuICAnJiMzNDsnLFxuICAnIycsXG4gICckJyxcbiAgJyUnLFxuICAnJiMzODsnLFxuICAnJiMzOTsnLFxuICAnKCcsXG4gICcpJyxcbiAgJyonLFxuICAnKycsXG4gICcsJyxcbiAgJy0nLFxuICAnLicsXG4gICcvJyxcbiAgJzAnLFxuICAnMScsXG4gICcyJyxcbiAgJzMnLFxuICAnNCcsXG4gICc1JyxcbiAgJzYnLFxuICAnNycsXG4gICc4JyxcbiAgJzknLFxuICAnOicsXG4gICc7JyxcbiAgJyYjNjA7JyxcbiAgJz0nLFxuICAnJiM2MjsnLFxuICAnPycsXG4gICdAJyxcbiAgJ0EnLFxuICAnQicsXG4gICdDJyxcbiAgJ0QnLFxuICAnRScsXG4gICdGJyxcbiAgJ0cnLFxuICAnSCcsXG4gICdJJyxcbiAgJ0onLFxuICAnSycsXG4gICdMJyxcbiAgJ00nLFxuICAnTicsXG4gICdPJyxcbiAgJ1AnLFxuICAnUScsXG4gICdSJyxcbiAgJ1MnLFxuICAnVCcsXG4gICdVJyxcbiAgJ1YnLFxuICAnVycsXG4gICdYJyxcbiAgJ1knLFxuICAnWicsXG4gICdbJyxcbiAgJyYjOTI7JyxcbiAgJ10nLFxuICAnXicsXG4gICdfJyxcbiAgJ2AnLFxuICAnYScsXG4gICdiJyxcbiAgJ2MnLFxuICAnZCcsXG4gICdlJyxcbiAgJ2YnLFxuICAnZycsXG4gICdoJyxcbiAgJ2knLFxuICAnaicsXG4gICdrJyxcbiAgJ2wnLFxuICAnbScsXG4gICduJyxcbiAgJ28nLFxuICAncCcsXG4gICdxJyxcbiAgJ3InLFxuICAncycsXG4gICd0JyxcbiAgJ3UnLFxuICAndicsXG4gICd3JyxcbiAgJ3gnLFxuICAneScsXG4gICd6JyxcbiAgJ3snLFxuICAnfCcsXG4gICd9JyxcbiAgJ34nLFxuICAnREVMJyxcbl07XG4vLyBUcmFuc2xhdGVzIGEgc2luZ2xlIGNoYXJhY3RlciB0byBoZXhhZGVjaW1hbCB3aXRoIGxlYWRpbmcgemVyb3MgZm9yIDIsIDQsIG9yIDggZGlnaXQgZGlzcGxheS5cbmV4cG9ydHMuY2hhclRvSGV4ID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgbGV0IGNoID0gY2hhci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgc3dpdGNoIChjaC5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNzpcbiAgICAgIGNoID0gYDAke2NofWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgY2FzZSA2OlxuICAgICAgY2ggPSBgMDAke2NofWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICBjaCA9IGAwMDAke2NofWA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgb3B0aW9uJyk7XG4gIH1cbiAgcmV0dXJuIGNoO1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIGRlY2ltYWwgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLmNoYXJzVG9EZWMgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGxldCByZXQgPSAnJztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoYXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzRmlsZU5hbWV9Y2hhcnNUb0RlYzogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgaWYgKGJvdW5kcy5lbmQgPiBib3VuZHMuYmVnKSB7XG4gICAgcmV0ICs9IGNoYXJzW2JvdW5kcy5iZWddO1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnICsgMTsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgcmV0ICs9IGAsJHtjaGFyc1tpXX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIGhleGFkZWNpbWFsIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5jaGFyc1RvSGV4ID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9IZXg6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIHJldCArPSBgXFxcXHgke2V4cG9ydHMuY2hhclRvSGV4KGNoYXJzW2JvdW5kcy5iZWddKX1gO1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnICsgMTsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgcmV0ICs9IGAsXFxcXHgke2V4cG9ydHMuY2hhclRvSGV4KGNoYXJzW2ldKX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbmV4cG9ydHMuY2hhcnNUb0h0bWxFbnRpdGllcyA9IGZ1bmN0aW9uIChjaGFycywgYmVnLCBsZW4pIHtcbiAgbGV0IHJldCA9ICcnO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY2hhcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXNGaWxlTmFtZX1jaGFyc1RvSGV4OiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgcmV0ICs9IGAmI3gke2NoYXJzW2ldLnRvU3RyaW5nKDE2KX07YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG4vLyBUcmFuc2xhdGVzIGEgc3ViLWFycmF5IG9mIGNoYXJhY3RlciBjb2RlcyB0byBVbmljb2RlIGRpc3BsYXkgZm9ybWF0LlxuZnVuY3Rpb24gaXNVbmljb2RlKGNoYXIpIHtcbiAgaWYgKGNoYXIgPj0gMHhkODAwICYmIGNoYXIgPD0gMHhkZmZmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjaGFyID4gMHgxMGZmZmYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNoYXJzVG9Vbmljb2RlID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9Vbmljb2RlOiBpbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIGludGVnZXJzYCk7XG4gIH1cbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBpZiAoYm91bmRzLmVuZCA+IGJvdW5kcy5iZWcpIHtcbiAgICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgaWYgKGlzVW5pY29kZShjaGFyc1tpXSkpIHtcbiAgICAgICAgcmV0ICs9IGAmIyR7Y2hhcnNbaV19O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgKz0gYCBVKyR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcnNbaV0pfWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59O1xuLy8gVHJhbnNsYXRlcyBhIHN1Yi1hcnJheSBvZiBjaGFyYWN0ZXIgY29kZXMgdG8gSmF2YVNjcmlwdCBVbmljb2RlIGRpc3BsYXkgZm9ybWF0IChgXFx1WFhYWGApLlxuZXhwb3J0cy5jaGFyc1RvSnNVbmljb2RlID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9Kc1VuaWNvZGU6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBjb25zdCBib3VuZHMgPSBnZXRCb3VuZHMoY2hhcnMubGVuZ3RoLCBiZWcsIGxlbik7XG4gIGlmIChib3VuZHMuZW5kID4gYm91bmRzLmJlZykge1xuICAgIHJldCArPSBgXFxcXHUke2V4cG9ydHMuY2hhclRvSGV4KGNoYXJzW2JvdW5kcy5iZWddKX1gO1xuICAgIGZvciAobGV0IGkgPSBib3VuZHMuYmVnICsgMTsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgICAgcmV0ICs9IGAsXFxcXHUke2V4cG9ydHMuY2hhclRvSGV4KGNoYXJzW2ldKX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIHByaW50aW5nIEFTQ0lJIGNoYXJhY3RlciBkaXNwbGF5IGZvcm1hdC5cbmV4cG9ydHMuY2hhcnNUb0FzY2lpID0gZnVuY3Rpb24gKGNoYXJzLCBiZWcsIGxlbikge1xuICBsZXQgcmV0ID0gJyc7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9Bc2NpaTogaW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vyc2ApO1xuICB9XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJvdW5kcyhjaGFycy5sZW5ndGgsIGJlZywgbGVuKTtcbiAgZm9yIChsZXQgaSA9IGJvdW5kcy5iZWc7IGkgPCBib3VuZHMuZW5kOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gY2hhcnNbaV07XG4gICAgaWYgKGNoYXIgPj0gMzIgJiYgY2hhciA8PSAxMjYpIHtcbiAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYFxcXFx4JHtleHBvcnRzLmNoYXJUb0hleChjaGFyKX1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBzdWItYXJyYXkgb2YgY2hhcmFjdGVyIGNvZGVzIHRvIEhUTUwgZGlzcGxheSBmb3JtYXQuXG5leHBvcnRzLmNoYXJzVG9Bc2NpaUh0bWwgPSBmdW5jdGlvbiAoY2hhcnMsIGJlZywgbGVuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGFycykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpc0ZpbGVOYW1lfWNoYXJzVG9Bc2NpaUh0bWw6IGlucHV0IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50ZWdlcnNgKTtcbiAgfVxuICBsZXQgaHRtbCA9ICcnO1xuICBsZXQgY2hhcjtcbiAgY29uc3QgYm91bmRzID0gZ2V0Qm91bmRzKGNoYXJzLmxlbmd0aCwgYmVnLCBsZW4pO1xuICBmb3IgKGxldCBpID0gYm91bmRzLmJlZzsgaSA8IGJvdW5kcy5lbmQ7IGkgKz0gMSkge1xuICAgIGNoYXIgPSBjaGFyc1tpXTtcbiAgICBpZiAoY2hhciA8IDMyIHx8IGNoYXIgPT09IDEyNykge1xuICAgICAgLyogY29udHJvbCBjaGFyYWN0ZXJzICovXG4gICAgICBodG1sICs9IGA8c3BhbiBjbGFzcz1cIiR7c3R5bGUuQ0xBU1NfQ1RSTENIQVJ9XCI+JHtleHBvcnRzLmFzY2lpQ2hhcnNbY2hhcl19PC9zcGFuPmA7XG4gICAgfSBlbHNlIGlmIChjaGFyID4gMTI3KSB7XG4gICAgICAvKiBub24tQVNDSUkgKi9cbiAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPVwiJHtzdHlsZS5DTEFTU19DVFJMQ0hBUn1cIj5VKyR7ZXhwb3J0cy5jaGFyVG9IZXgoY2hhcil9PC9zcGFuPmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIHByaW50aW5nIEFTQ0lJLCAzMiA8PSBjaGFyIDw9IDEyNiAqL1xuICAgICAgaHRtbCArPSBleHBvcnRzLmFzY2lpQ2hhcnNbY2hhcl07XG4gICAgfVxuICB9XG4gIHJldHVybiBodG1sO1xufTtcbi8vIFRyYW5zbGF0ZXMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBIVE1MIGRpc3BsYXkgZm9ybWF0LlxuZXhwb3J0cy5zdHJpbmdUb0FzY2lpSHRtbCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgY29uc3QgY2hhcnMgPSBjb252ZXJ0ZXIuZGVjb2RlKCdTVFJJTkcnLCBzdHIpO1xuICByZXR1cm4gdGhpcy5jaGFyc1RvQXNjaWlIdG1sKGNoYXJzKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/apg-js/src/apg-lib/utilities.js\n");

/***/ })

};
;