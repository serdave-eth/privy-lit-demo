"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/siwe";
exports.ids = ["vendor-chunks/siwe"];
exports.modules = {

/***/ "(ssr)/./node_modules/siwe/dist/client.js":
/*!******************************************!*\
  !*** ./node_modules/siwe/dist/client.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SiweMessage = void 0;\n// TODO: Figure out how to get types from this lib:\nconst siwe_parser_1 = __webpack_require__(/*! @spruceid/siwe-parser */ \"(ssr)/./node_modules/@spruceid/siwe-parser/dist/parsers.js\");\nconst uri = __importStar(__webpack_require__(/*! valid-url */ \"(ssr)/./node_modules/valid-url/index.js\"));\nconst ethersCompat_1 = __webpack_require__(/*! ./ethersCompat */ \"(ssr)/./node_modules/siwe/dist/ethersCompat.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/siwe/dist/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/siwe/dist/utils.js\");\nclass SiweMessage {\n    /**\n     * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a\n     * string or an object. If a string is used an ABNF parser is called to\n     * validate the parameter, otherwise the fields are attributed.\n     * @param param {string | SiweMessage} Sign message as a string or an object.\n     */\n    constructor(param) {\n        if (typeof param === 'string') {\n            const parsedMessage = new siwe_parser_1.ParsedMessage(param);\n            this.scheme = parsedMessage.scheme;\n            this.domain = parsedMessage.domain;\n            this.address = parsedMessage.address;\n            this.statement = parsedMessage.statement;\n            this.uri = parsedMessage.uri;\n            this.version = parsedMessage.version;\n            this.nonce = parsedMessage.nonce;\n            this.issuedAt = parsedMessage.issuedAt;\n            this.expirationTime = parsedMessage.expirationTime;\n            this.notBefore = parsedMessage.notBefore;\n            this.requestId = parsedMessage.requestId;\n            this.chainId = parsedMessage.chainId;\n            this.resources = parsedMessage.resources;\n        }\n        else {\n            this.scheme = param === null || param === void 0 ? void 0 : param.scheme;\n            this.domain = param.domain;\n            this.address = param.address;\n            this.statement = param === null || param === void 0 ? void 0 : param.statement;\n            this.uri = param.uri;\n            this.version = param.version;\n            this.chainId = param.chainId;\n            this.nonce = param.nonce;\n            this.issuedAt = param === null || param === void 0 ? void 0 : param.issuedAt;\n            this.expirationTime = param === null || param === void 0 ? void 0 : param.expirationTime;\n            this.notBefore = param === null || param === void 0 ? void 0 : param.notBefore;\n            this.requestId = param === null || param === void 0 ? void 0 : param.requestId;\n            this.resources = param === null || param === void 0 ? void 0 : param.resources;\n            if (typeof this.chainId === 'string') {\n                this.chainId = (0, siwe_parser_1.parseIntegerNumber)(this.chainId);\n            }\n        }\n        this.nonce = this.nonce || (0, utils_1.generateNonce)();\n        this.validateMessage();\n    }\n    /**\n     * This function can be used to retrieve an EIP-4361 formated message for\n     * signature, although you can call it directly it's advised to use\n     * [prepareMessage()] instead which will resolve to the correct method based\n     * on the [type] attribute of this object, in case of other formats being\n     * implemented.\n     * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.\n     */\n    toMessage() {\n        /** Validates all fields of the object */\n        this.validateMessage();\n        const headerPrefx = this.scheme ? `${this.scheme}://${this.domain}` : this.domain;\n        const header = `${headerPrefx} wants you to sign in with your Ethereum account:`;\n        const uriField = `URI: ${this.uri}`;\n        let prefix = [header, this.address].join('\\n');\n        const versionField = `Version: ${this.version}`;\n        if (!this.nonce) {\n            this.nonce = (0, utils_1.generateNonce)();\n        }\n        const chainField = `Chain ID: ` + this.chainId || 0;\n        const nonceField = `Nonce: ${this.nonce}`;\n        const suffixArray = [uriField, versionField, chainField, nonceField];\n        this.issuedAt = this.issuedAt || new Date().toISOString();\n        suffixArray.push(`Issued At: ${this.issuedAt}`);\n        if (this.expirationTime) {\n            const expiryField = `Expiration Time: ${this.expirationTime}`;\n            suffixArray.push(expiryField);\n        }\n        if (this.notBefore) {\n            suffixArray.push(`Not Before: ${this.notBefore}`);\n        }\n        if (this.requestId) {\n            suffixArray.push(`Request ID: ${this.requestId}`);\n        }\n        if (this.resources) {\n            suffixArray.push([`Resources:`, ...this.resources.map(x => `- ${x}`)].join('\\n'));\n        }\n        const suffix = suffixArray.join('\\n');\n        prefix = [prefix, this.statement].join('\\n\\n');\n        if (this.statement) {\n            prefix += '\\n';\n        }\n        return [prefix, suffix].join('\\n');\n    }\n    /**\n     * This method parses all the fields in the object and creates a messaging for signing\n     * message according with the type defined.\n     * @returns {string} Returns a message ready to be signed according with the\n     * type defined in the object.\n     */\n    prepareMessage() {\n        let message;\n        switch (this.version) {\n            case '1': {\n                message = this.toMessage();\n                break;\n            }\n            default: {\n                message = this.toMessage();\n                break;\n            }\n        }\n        return message;\n    }\n    /**\n     * @deprecated\n     * Verifies the integrity of the object by matching its signature.\n     * @param signature Signature to match the address in the message.\n     * @param provider Ethers provider to be used for EIP-1271 validation\n     */\n    validate(signature, provider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.warn('validate() has been deprecated, please update your code to use verify(). validate() may be removed in future versions.');\n            return this.verify({ signature }, { provider, suppressExceptions: false })\n                .then(({ data }) => data)\n                .catch(({ error }) => {\n                throw error;\n            });\n        });\n    }\n    /**\n     * Verifies the integrity of the object by matching its signature.\n     * @param params Parameters to verify the integrity of the message, signature is required.\n     * @returns {Promise<SiweMessage>} This object if valid.\n     */\n    verify(params, opts = { suppressExceptions: false }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                var _a, _b, _c;\n                const fail = result => {\n                    if (opts.suppressExceptions) {\n                        return resolve(result);\n                    }\n                    else {\n                        return reject(result);\n                    }\n                };\n                const invalidParams = (0, utils_1.checkInvalidKeys)(params, types_1.VerifyParamsKeys);\n                if (invalidParams.length > 0) {\n                    fail({\n                        success: false,\n                        data: this,\n                        error: new Error(`${invalidParams.join(', ')} is/are not valid key(s) for VerifyParams.`),\n                    });\n                }\n                const invalidOpts = (0, utils_1.checkInvalidKeys)(opts, types_1.VerifyOptsKeys);\n                if (invalidParams.length > 0) {\n                    fail({\n                        success: false,\n                        data: this,\n                        error: new Error(`${invalidOpts.join(', ')} is/are not valid key(s) for VerifyOpts.`),\n                    });\n                }\n                const { signature, scheme, domain, nonce, time } = params;\n                /** Scheme for domain binding */\n                if (scheme && scheme !== this.scheme) {\n                    fail({\n                        success: false,\n                        data: this,\n                        error: new types_1.SiweError(types_1.SiweErrorType.SCHEME_MISMATCH, scheme, this.scheme),\n                    });\n                }\n                /** Domain binding */\n                if (domain && domain !== this.domain) {\n                    fail({\n                        success: false,\n                        data: this,\n                        error: new types_1.SiweError(types_1.SiweErrorType.DOMAIN_MISMATCH, domain, this.domain),\n                    });\n                }\n                /** Nonce binding */\n                if (nonce && nonce !== this.nonce) {\n                    fail({\n                        success: false,\n                        data: this,\n                        error: new types_1.SiweError(types_1.SiweErrorType.NONCE_MISMATCH, nonce, this.nonce),\n                    });\n                }\n                /** Check time or now */\n                const checkTime = new Date(time || new Date());\n                /** Message not expired */\n                if (this.expirationTime) {\n                    const expirationDate = new Date(this.expirationTime);\n                    if (checkTime.getTime() >= expirationDate.getTime()) {\n                        fail({\n                            success: false,\n                            data: this,\n                            error: new types_1.SiweError(types_1.SiweErrorType.EXPIRED_MESSAGE, `${checkTime.toISOString()} < ${expirationDate.toISOString()}`, `${checkTime.toISOString()} >= ${expirationDate.toISOString()}`),\n                        });\n                    }\n                }\n                /** Message is valid already */\n                if (this.notBefore) {\n                    const notBefore = new Date(this.notBefore);\n                    if (checkTime.getTime() < notBefore.getTime()) {\n                        fail({\n                            success: false,\n                            data: this,\n                            error: new types_1.SiweError(types_1.SiweErrorType.NOT_YET_VALID_MESSAGE, `${checkTime.toISOString()} >= ${notBefore.toISOString()}`, `${checkTime.toISOString()} < ${notBefore.toISOString()}`),\n                        });\n                    }\n                }\n                let EIP4361Message;\n                try {\n                    EIP4361Message = this.prepareMessage();\n                }\n                catch (e) {\n                    fail({\n                        success: false,\n                        data: this,\n                        error: e,\n                    });\n                }\n                /** Recover address from signature */\n                let addr;\n                try {\n                    addr = (0, ethersCompat_1.verifyMessage)(EIP4361Message, signature);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n                /** Match signature with message's address */\n                if (addr === this.address) {\n                    return resolve({\n                        success: true,\n                        data: this,\n                    });\n                }\n                else {\n                    const EIP1271Promise = (0, utils_1.checkContractWalletSignature)(this, signature, opts.provider)\n                        .then(isValid => {\n                        if (!isValid) {\n                            return {\n                                success: false,\n                                data: this,\n                                error: new types_1.SiweError(types_1.SiweErrorType.INVALID_SIGNATURE, addr, `Resolved address to be ${this.address}`),\n                            };\n                        }\n                        return {\n                            success: true,\n                            data: this,\n                        };\n                    })\n                        .catch(error => {\n                        return {\n                            success: false,\n                            data: this,\n                            error,\n                        };\n                    });\n                    Promise.all([\n                        EIP1271Promise,\n                        (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.verificationFallback) === null || _a === void 0 ? void 0 : _a.call(opts, params, opts, this, EIP1271Promise)) === null || _b === void 0 ? void 0 : _b.then(res => res)) === null || _c === void 0 ? void 0 : _c.catch((res) => res),\n                    ]).then(([EIP1271Response, fallbackResponse]) => {\n                        if (fallbackResponse) {\n                            if (fallbackResponse.success) {\n                                return resolve(fallbackResponse);\n                            }\n                            else {\n                                fail(fallbackResponse);\n                            }\n                        }\n                        else {\n                            if (EIP1271Response.success) {\n                                return resolve(EIP1271Response);\n                            }\n                            else {\n                                fail(EIP1271Response);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n    /**\n     * Validates the values of this object fields.\n     * @throws Throws an {ErrorType} if a field is invalid.\n     */\n    validateMessage(...args) {\n        var _a;\n        /** Checks if the user might be using the function to verify instead of validate. */\n        if (args.length > 0) {\n            throw new types_1.SiweError(types_1.SiweErrorType.UNABLE_TO_PARSE, `Unexpected argument in the validateMessage function.`);\n        }\n        /** `domain` check. */\n        if (!this.domain ||\n            this.domain.length === 0 ||\n            !/[^#?]*/.test(this.domain)) {\n            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_DOMAIN, `${this.domain} to be a valid domain.`);\n        }\n        /** EIP-55 `address` check. */\n        if (!(0, siwe_parser_1.isEIP55Address)(this.address)) {\n            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_ADDRESS, (0, ethersCompat_1.getAddress)(this.address), this.address);\n        }\n        /** Check if the URI is valid. */\n        if (!uri.isUri(this.uri)) {\n            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_URI, `${this.uri} to be a valid uri.`);\n        }\n        /** Check if the version is 1. */\n        if (this.version !== '1') {\n            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_MESSAGE_VERSION, '1', this.version);\n        }\n        /** Check if the nonce is alphanumeric and bigger then 8 characters */\n        const nonce = (_a = this === null || this === void 0 ? void 0 : this.nonce) === null || _a === void 0 ? void 0 : _a.match(/[a-zA-Z0-9]{8,}/);\n        if (!nonce || this.nonce.length < 8 || nonce[0] !== this.nonce) {\n            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_NONCE, `Length > 8 (${nonce.length}). Alphanumeric.`, this.nonce);\n        }\n        /** `issuedAt` conforms to ISO-8601 and is a valid date. */\n        if (this.issuedAt) {\n            if (!(0, utils_1.isValidISO8601Date)(this.issuedAt)) {\n                throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);\n            }\n        }\n        /** `expirationTime` conforms to ISO-8601 and is a valid date. */\n        if (this.expirationTime) {\n            if (!(0, utils_1.isValidISO8601Date)(this.expirationTime)) {\n                throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);\n            }\n        }\n        /** `notBefore` conforms to ISO-8601 and is a valid date. */\n        if (this.notBefore) {\n            if (!(0, utils_1.isValidISO8601Date)(this.notBefore)) {\n                throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);\n            }\n        }\n    }\n}\nexports.SiweMessage = SiweMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHlGQUF1QjtBQUNyRCx5QkFBeUIsbUJBQU8sQ0FBQywwREFBVztBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWSxLQUFLLFlBQVk7QUFDMUUsMEJBQTBCLGFBQWE7QUFDdkMsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsQ0FBRztBQUM3RCxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQSxvREFBb0Qsb0JBQW9CO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0EsNEVBQTRFLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsSUFBSSxxQ0FBcUM7QUFDckYseUJBQXlCLE1BQU07QUFDL0IsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFLHFCQUFxQjtBQUNyQjtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHlCQUF5QixJQUFJLDZCQUE2QixNQUFNLHlCQUF5QixLQUFLLDZCQUE2QjtBQUM5Tix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHlCQUF5QixLQUFLLHdCQUF3QixNQUFNLHlCQUF5QixJQUFJLHdCQUF3QjtBQUMxTix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0ksYUFBYTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsYUFBYTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtJQUErSSxHQUFHO0FBQ2xKO0FBQ0EsNEZBQTRGLGFBQWE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdnktbGl0LWRlbW8vLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L2NsaWVudC5qcz82NGM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l3ZU1lc3NhZ2UgPSB2b2lkIDA7XG4vLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyB0byBnZXQgdHlwZXMgZnJvbSB0aGlzIGxpYjpcbmNvbnN0IHNpd2VfcGFyc2VyXzEgPSByZXF1aXJlKFwiQHNwcnVjZWlkL3Npd2UtcGFyc2VyXCIpO1xuY29uc3QgdXJpID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ2YWxpZC11cmxcIikpO1xuY29uc3QgZXRoZXJzQ29tcGF0XzEgPSByZXF1aXJlKFwiLi9ldGhlcnNDb21wYXRcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBTaXdlTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHBhcnNlZCBTaWduLUluIHdpdGggRXRoZXJldW0gTWVzc2FnZSAoRUlQLTQzNjEpIG9iamVjdCBmcm9tIGFcbiAgICAgKiBzdHJpbmcgb3IgYW4gb2JqZWN0LiBJZiBhIHN0cmluZyBpcyB1c2VkIGFuIEFCTkYgcGFyc2VyIGlzIGNhbGxlZCB0b1xuICAgICAqIHZhbGlkYXRlIHRoZSBwYXJhbWV0ZXIsIG90aGVyd2lzZSB0aGUgZmllbGRzIGFyZSBhdHRyaWJ1dGVkLlxuICAgICAqIEBwYXJhbSBwYXJhbSB7c3RyaW5nIHwgU2l3ZU1lc3NhZ2V9IFNpZ24gbWVzc2FnZSBhcyBhIHN0cmluZyBvciBhbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBuZXcgc2l3ZV9wYXJzZXJfMS5QYXJzZWRNZXNzYWdlKHBhcmFtKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gcGFyc2VkTWVzc2FnZS5zY2hlbWU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbiA9IHBhcnNlZE1lc3NhZ2UuZG9tYWluO1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzID0gcGFyc2VkTWVzc2FnZS5hZGRyZXNzO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnQgPSBwYXJzZWRNZXNzYWdlLnN0YXRlbWVudDtcbiAgICAgICAgICAgIHRoaXMudXJpID0gcGFyc2VkTWVzc2FnZS51cmk7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBwYXJzZWRNZXNzYWdlLnZlcnNpb247XG4gICAgICAgICAgICB0aGlzLm5vbmNlID0gcGFyc2VkTWVzc2FnZS5ub25jZTtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVkQXQgPSBwYXJzZWRNZXNzYWdlLmlzc3VlZEF0O1xuICAgICAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHBhcnNlZE1lc3NhZ2UuZXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICB0aGlzLm5vdEJlZm9yZSA9IHBhcnNlZE1lc3NhZ2Uubm90QmVmb3JlO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBwYXJzZWRNZXNzYWdlLnJlcXVlc3RJZDtcbiAgICAgICAgICAgIHRoaXMuY2hhaW5JZCA9IHBhcnNlZE1lc3NhZ2UuY2hhaW5JZDtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2VzID0gcGFyc2VkTWVzc2FnZS5yZXNvdXJjZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtZSA9IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS5zY2hlbWU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbiA9IHBhcmFtLmRvbWFpbjtcbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcyA9IHBhcmFtLmFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudCA9IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS5zdGF0ZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnVyaSA9IHBhcmFtLnVyaTtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IHBhcmFtLnZlcnNpb247XG4gICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBwYXJhbS5jaGFpbklkO1xuICAgICAgICAgICAgdGhpcy5ub25jZSA9IHBhcmFtLm5vbmNlO1xuICAgICAgICAgICAgdGhpcy5pc3N1ZWRBdCA9IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS5pc3N1ZWRBdDtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0uZXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICB0aGlzLm5vdEJlZm9yZSA9IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS5ub3RCZWZvcmU7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RJZCA9IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS5yZXF1ZXN0SWQ7XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlcyA9IHBhcmFtID09PSBudWxsIHx8IHBhcmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbS5yZXNvdXJjZXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2hhaW5JZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSAoMCwgc2l3ZV9wYXJzZXJfMS5wYXJzZUludGVnZXJOdW1iZXIpKHRoaXMuY2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub25jZSA9IHRoaXMubm9uY2UgfHwgKDAsIHV0aWxzXzEuZ2VuZXJhdGVOb25jZSkoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1lc3NhZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byByZXRyaWV2ZSBhbiBFSVAtNDM2MSBmb3JtYXRlZCBtZXNzYWdlIGZvclxuICAgICAqIHNpZ25hdHVyZSwgYWx0aG91Z2ggeW91IGNhbiBjYWxsIGl0IGRpcmVjdGx5IGl0J3MgYWR2aXNlZCB0byB1c2VcbiAgICAgKiBbcHJlcGFyZU1lc3NhZ2UoKV0gaW5zdGVhZCB3aGljaCB3aWxsIHJlc29sdmUgdG8gdGhlIGNvcnJlY3QgbWV0aG9kIGJhc2VkXG4gICAgICogb24gdGhlIFt0eXBlXSBhdHRyaWJ1dGUgb2YgdGhpcyBvYmplY3QsIGluIGNhc2Ugb2Ygb3RoZXIgZm9ybWF0cyBiZWluZ1xuICAgICAqIGltcGxlbWVudGVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEVJUC00MzYxIGZvcm1hdGVkIG1lc3NhZ2UsIHJlYWR5IGZvciBFSVAtMTkxIHNpZ25pbmcuXG4gICAgICovXG4gICAgdG9NZXNzYWdlKCkge1xuICAgICAgICAvKiogVmFsaWRhdGVzIGFsbCBmaWVsZHMgb2YgdGhlIG9iamVjdCAqL1xuICAgICAgICB0aGlzLnZhbGlkYXRlTWVzc2FnZSgpO1xuICAgICAgICBjb25zdCBoZWFkZXJQcmVmeCA9IHRoaXMuc2NoZW1lID8gYCR7dGhpcy5zY2hlbWV9Oi8vJHt0aGlzLmRvbWFpbn1gIDogdGhpcy5kb21haW47XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGAke2hlYWRlclByZWZ4fSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpgO1xuICAgICAgICBjb25zdCB1cmlGaWVsZCA9IGBVUkk6ICR7dGhpcy51cml9YDtcbiAgICAgICAgbGV0IHByZWZpeCA9IFtoZWFkZXIsIHRoaXMuYWRkcmVzc10uam9pbignXFxuJyk7XG4gICAgICAgIGNvbnN0IHZlcnNpb25GaWVsZCA9IGBWZXJzaW9uOiAke3RoaXMudmVyc2lvbn1gO1xuICAgICAgICBpZiAoIXRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgIHRoaXMubm9uY2UgPSAoMCwgdXRpbHNfMS5nZW5lcmF0ZU5vbmNlKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWluRmllbGQgPSBgQ2hhaW4gSUQ6IGAgKyB0aGlzLmNoYWluSWQgfHwgJzEnO1xuICAgICAgICBjb25zdCBub25jZUZpZWxkID0gYE5vbmNlOiAke3RoaXMubm9uY2V9YDtcbiAgICAgICAgY29uc3Qgc3VmZml4QXJyYXkgPSBbdXJpRmllbGQsIHZlcnNpb25GaWVsZCwgY2hhaW5GaWVsZCwgbm9uY2VGaWVsZF07XG4gICAgICAgIHRoaXMuaXNzdWVkQXQgPSB0aGlzLmlzc3VlZEF0IHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgc3VmZml4QXJyYXkucHVzaChgSXNzdWVkIEF0OiAke3RoaXMuaXNzdWVkQXR9YCk7XG4gICAgICAgIGlmICh0aGlzLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBleHBpcnlGaWVsZCA9IGBFeHBpcmF0aW9uIFRpbWU6ICR7dGhpcy5leHBpcmF0aW9uVGltZX1gO1xuICAgICAgICAgICAgc3VmZml4QXJyYXkucHVzaChleHBpcnlGaWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm90QmVmb3JlKSB7XG4gICAgICAgICAgICBzdWZmaXhBcnJheS5wdXNoKGBOb3QgQmVmb3JlOiAke3RoaXMubm90QmVmb3JlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RJZCkge1xuICAgICAgICAgICAgc3VmZml4QXJyYXkucHVzaChgUmVxdWVzdCBJRDogJHt0aGlzLnJlcXVlc3RJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHN1ZmZpeEFycmF5LnB1c2goW2BSZXNvdXJjZXM6YCwgLi4udGhpcy5yZXNvdXJjZXMubWFwKHggPT4gYC0gJHt4fWApXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gc3VmZml4QXJyYXkuam9pbignXFxuJyk7XG4gICAgICAgIHByZWZpeCA9IFtwcmVmaXgsIHRoaXMuc3RhdGVtZW50XS5qb2luKCdcXG5cXG4nKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVtZW50KSB7XG4gICAgICAgICAgICBwcmVmaXggKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHN1ZmZpeF0uam9pbignXFxuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHBhcnNlcyBhbGwgdGhlIGZpZWxkcyBpbiB0aGUgb2JqZWN0IGFuZCBjcmVhdGVzIGEgbWVzc2FnaW5nIGZvciBzaWduaW5nXG4gICAgICogbWVzc2FnZSBhY2NvcmRpbmcgd2l0aCB0aGUgdHlwZSBkZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYSBtZXNzYWdlIHJlYWR5IHRvIGJlIHNpZ25lZCBhY2NvcmRpbmcgd2l0aCB0aGVcbiAgICAgKiB0eXBlIGRlZmluZWQgaW4gdGhlIG9iamVjdC5cbiAgICAgKi9cbiAgICBwcmVwYXJlTWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxJzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnRvTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnRvTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFZlcmlmaWVzIHRoZSBpbnRlZ3JpdHkgb2YgdGhlIG9iamVjdCBieSBtYXRjaGluZyBpdHMgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSBzaWduYXR1cmUgU2lnbmF0dXJlIHRvIG1hdGNoIHRoZSBhZGRyZXNzIGluIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBwcm92aWRlciBFdGhlcnMgcHJvdmlkZXIgdG8gYmUgdXNlZCBmb3IgRUlQLTEyNzEgdmFsaWRhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlKHNpZ25hdHVyZSwgcHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndmFsaWRhdGUoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgdXBkYXRlIHlvdXIgY29kZSB0byB1c2UgdmVyaWZ5KCkuIHZhbGlkYXRlKCkgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyaWZ5KHsgc2lnbmF0dXJlIH0sIHsgcHJvdmlkZXIsIHN1cHByZXNzRXhjZXB0aW9uczogZmFsc2UgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoeyBkYXRhIH0pID0+IGRhdGEpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCh7IGVycm9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgdGhlIGludGVncml0eSBvZiB0aGUgb2JqZWN0IGJ5IG1hdGNoaW5nIGl0cyBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIHRvIHZlcmlmeSB0aGUgaW50ZWdyaXR5IG9mIHRoZSBtZXNzYWdlLCBzaWduYXR1cmUgaXMgcmVxdWlyZWQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2l3ZU1lc3NhZ2U+fSBUaGlzIG9iamVjdCBpZiB2YWxpZC5cbiAgICAgKi9cbiAgICB2ZXJpZnkocGFyYW1zLCBvcHRzID0geyBzdXBwcmVzc0V4Y2VwdGlvbnM6IGZhbHNlIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbCA9IHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN1cHByZXNzRXhjZXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZFBhcmFtcyA9ICgwLCB1dGlsc18xLmNoZWNrSW52YWxpZEtleXMpKHBhcmFtcywgdHlwZXNfMS5WZXJpZnlQYXJhbXNLZXlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZFBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgJHtpbnZhbGlkUGFyYW1zLmpvaW4oJywgJyl9IGlzL2FyZSBub3QgdmFsaWQga2V5KHMpIGZvciBWZXJpZnlQYXJhbXMuYCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkT3B0cyA9ICgwLCB1dGlsc18xLmNoZWNrSW52YWxpZEtleXMpKG9wdHMsIHR5cGVzXzEuVmVyaWZ5T3B0c0tleXMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGAke2ludmFsaWRPcHRzLmpvaW4oJywgJyl9IGlzL2FyZSBub3QgdmFsaWQga2V5KHMpIGZvciBWZXJpZnlPcHRzLmApLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzaWduYXR1cmUsIHNjaGVtZSwgZG9tYWluLCBub25jZSwgdGltZSB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIC8qKiBTY2hlbWUgZm9yIGRvbWFpbiBiaW5kaW5nICovXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtZSAmJiBzY2hlbWUgIT09IHRoaXMuc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyB0eXBlc18xLlNpd2VFcnJvcih0eXBlc18xLlNpd2VFcnJvclR5cGUuU0NIRU1FX01JU01BVENILCBzY2hlbWUsIHRoaXMuc2NoZW1lKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKiBEb21haW4gYmluZGluZyAqL1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiYgZG9tYWluICE9PSB0aGlzLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLkRPTUFJTl9NSVNNQVRDSCwgZG9tYWluLCB0aGlzLmRvbWFpbiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogTm9uY2UgYmluZGluZyAqL1xuICAgICAgICAgICAgICAgIGlmIChub25jZSAmJiBub25jZSAhPT0gdGhpcy5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLk5PTkNFX01JU01BVENILCBub25jZSwgdGhpcy5ub25jZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQ2hlY2sgdGltZSBvciBub3cgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja1RpbWUgPSBuZXcgRGF0ZSh0aW1lIHx8IG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgIC8qKiBNZXNzYWdlIG5vdCBleHBpcmVkICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZSh0aGlzLmV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrVGltZS5nZXRUaW1lKCkgPj0gZXhwaXJhdGlvbkRhdGUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLkVYUElSRURfTUVTU0FHRSwgYCR7Y2hlY2tUaW1lLnRvSVNPU3RyaW5nKCl9IDwgJHtleHBpcmF0aW9uRGF0ZS50b0lTT1N0cmluZygpfWAsIGAke2NoZWNrVGltZS50b0lTT1N0cmluZygpfSA+PSAke2V4cGlyYXRpb25EYXRlLnRvSVNPU3RyaW5nKCl9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogTWVzc2FnZSBpcyB2YWxpZCBhbHJlYWR5ICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm90QmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEJlZm9yZSA9IG5ldyBEYXRlKHRoaXMubm90QmVmb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrVGltZS5nZXRUaW1lKCkgPCBub3RCZWZvcmUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLk5PVF9ZRVRfVkFMSURfTUVTU0FHRSwgYCR7Y2hlY2tUaW1lLnRvSVNPU3RyaW5nKCl9ID49ICR7bm90QmVmb3JlLnRvSVNPU3RyaW5nKCl9YCwgYCR7Y2hlY2tUaW1lLnRvSVNPU3RyaW5nKCl9IDwgJHtub3RCZWZvcmUudG9JU09TdHJpbmcoKX1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBFSVA0MzYxTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBFSVA0MzYxTWVzc2FnZSA9IHRoaXMucHJlcGFyZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKiBSZWNvdmVyIGFkZHJlc3MgZnJvbSBzaWduYXR1cmUgKi9cbiAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyID0gKDAsIGV0aGVyc0NvbXBhdF8xLnZlcmlmeU1lc3NhZ2UpKEVJUDQzNjFNZXNzYWdlLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogTWF0Y2ggc2lnbmF0dXJlIHdpdGggbWVzc2FnZSdzIGFkZHJlc3MgKi9cbiAgICAgICAgICAgICAgICBpZiAoYWRkciA9PT0gdGhpcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IEVJUDEyNzFQcm9taXNlID0gKDAsIHV0aWxzXzEuY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZSkodGhpcywgc2lnbmF0dXJlLCBvcHRzLnByb3ZpZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oaXNWYWxpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyB0eXBlc18xLlNpd2VFcnJvcih0eXBlc18xLlNpd2VFcnJvclR5cGUuSU5WQUxJRF9TSUdOQVRVUkUsIGFkZHIsIGBSZXNvbHZlZCBhZGRyZXNzIHRvIGJlICR7dGhpcy5hZGRyZXNzfWApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIEVJUDEyNzFQcm9taXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgKF9jID0gKF9iID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnZlcmlmaWNhdGlvbkZhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRzLCBwYXJhbXMsIG9wdHMsIHRoaXMsIEVJUDEyNzFQcm9taXNlKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRoZW4ocmVzID0+IHJlcykpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXRjaCgocmVzKSA9PiByZXMpLFxuICAgICAgICAgICAgICAgICAgICBdKS50aGVuKChbRUlQMTI3MVJlc3BvbnNlLCBmYWxsYmFja1Jlc3BvbnNlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZhbGxiYWNrUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbGxiYWNrUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbChmYWxsYmFja1Jlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoRUlQMTI3MVJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoRUlQMTI3MVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwoRUlQMTI3MVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSB2YWx1ZXMgb2YgdGhpcyBvYmplY3QgZmllbGRzLlxuICAgICAqIEB0aHJvd3MgVGhyb3dzIGFuIHtFcnJvclR5cGV9IGlmIGEgZmllbGQgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZU1lc3NhZ2UoLi4uYXJncykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qKiBDaGVja3MgaWYgdGhlIHVzZXIgbWlnaHQgYmUgdXNpbmcgdGhlIGZ1bmN0aW9uIHRvIHZlcmlmeSBpbnN0ZWFkIG9mIHZhbGlkYXRlLiAqL1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLlVOQUJMRV9UT19QQVJTRSwgYFVuZXhwZWN0ZWQgYXJndW1lbnQgaW4gdGhlIHZhbGlkYXRlTWVzc2FnZSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogYGRvbWFpbmAgY2hlY2suICovXG4gICAgICAgIGlmICghdGhpcy5kb21haW4gfHxcbiAgICAgICAgICAgIHRoaXMuZG9tYWluLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgIS9bXiM/XSovLnRlc3QodGhpcy5kb21haW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLklOVkFMSURfRE9NQUlOLCBgJHt0aGlzLmRvbWFpbn0gdG8gYmUgYSB2YWxpZCBkb21haW4uYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEVJUC01NSBgYWRkcmVzc2AgY2hlY2suICovXG4gICAgICAgIGlmICghKDAsIHNpd2VfcGFyc2VyXzEuaXNFSVA1NUFkZHJlc3MpKHRoaXMuYWRkcmVzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlNpd2VFcnJvcih0eXBlc18xLlNpd2VFcnJvclR5cGUuSU5WQUxJRF9BRERSRVNTLCAoMCwgZXRoZXJzQ29tcGF0XzEuZ2V0QWRkcmVzcykodGhpcy5hZGRyZXNzKSwgdGhpcy5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvKiogQ2hlY2sgaWYgdGhlIFVSSSBpcyB2YWxpZC4gKi9cbiAgICAgICAgaWYgKCF1cmkuaXNVcmkodGhpcy51cmkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLklOVkFMSURfVVJJLCBgJHt0aGlzLnVyaX0gdG8gYmUgYSB2YWxpZCB1cmkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIENoZWNrIGlmIHRoZSB2ZXJzaW9uIGlzIDEuICovXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gIT09ICcxJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuU2l3ZUVycm9yKHR5cGVzXzEuU2l3ZUVycm9yVHlwZS5JTlZBTElEX01FU1NBR0VfVkVSU0lPTiwgJzEnLCB0aGlzLnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBDaGVjayBpZiB0aGUgbm9uY2UgaXMgYWxwaGFudW1lcmljIGFuZCBiaWdnZXIgdGhlbiA4IGNoYXJhY3RlcnMgKi9cbiAgICAgICAgY29uc3Qgbm9uY2UgPSAoX2EgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMubm9uY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXRjaCgvW2EtekEtWjAtOV17OCx9Lyk7XG4gICAgICAgIGlmICghbm9uY2UgfHwgdGhpcy5ub25jZS5sZW5ndGggPCA4IHx8IG5vbmNlWzBdICE9PSB0aGlzLm5vbmNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5TaXdlRXJyb3IodHlwZXNfMS5TaXdlRXJyb3JUeXBlLklOVkFMSURfTk9OQ0UsIGBMZW5ndGggPiA4ICgke25vbmNlLmxlbmd0aH0pLiBBbHBoYW51bWVyaWMuYCwgdGhpcy5ub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIGBpc3N1ZWRBdGAgY29uZm9ybXMgdG8gSVNPLTg2MDEgYW5kIGlzIGEgdmFsaWQgZGF0ZS4gKi9cbiAgICAgICAgaWYgKHRoaXMuaXNzdWVkQXQpIHtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNWYWxpZElTTzg2MDFEYXRlKSh0aGlzLmlzc3VlZEF0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlc18xLlNpd2VFcnJvclR5cGUuSU5WQUxJRF9USU1FX0ZPUk1BVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqIGBleHBpcmF0aW9uVGltZWAgY29uZm9ybXMgdG8gSVNPLTg2MDEgYW5kIGlzIGEgdmFsaWQgZGF0ZS4gKi9cbiAgICAgICAgaWYgKHRoaXMuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzXzEuaXNWYWxpZElTTzg2MDFEYXRlKSh0aGlzLmV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlc18xLlNpd2VFcnJvclR5cGUuSU5WQUxJRF9USU1FX0ZPUk1BVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqIGBub3RCZWZvcmVgIGNvbmZvcm1zIHRvIElTTy04NjAxIGFuZCBpcyBhIHZhbGlkIGRhdGUuICovXG4gICAgICAgIGlmICh0aGlzLm5vdEJlZm9yZSkge1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfMS5pc1ZhbGlkSVNPODYwMURhdGUpKHRoaXMubm90QmVmb3JlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlc18xLlNpd2VFcnJvclR5cGUuSU5WQUxJRF9USU1FX0ZPUk1BVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNpd2VNZXNzYWdlID0gU2l3ZU1lc3NhZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/siwe/dist/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/siwe/dist/ethersCompat.js":
/*!************************************************!*\
  !*** ./node_modules/siwe/dist/ethersCompat.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAddress = exports.hashMessage = exports.verifyMessage = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/index.js\");\nlet ethersVerifyMessage = null;\nlet ethersHashMessage = null;\nlet ethersGetAddress = null;\ntry {\n    // @ts-expect-error -- v6 compatibility hack\n    ethersVerifyMessage = ethers_1.ethers.utils.verifyMessage;\n    // @ts-expect-error -- v6 compatibility hack\n    ethersHashMessage = ethers_1.ethers.utils.hashMessage;\n    // @ts-expect-error -- v6 compatibility hack\n    ethersGetAddress = ethers_1.ethers.utils.getAddress;\n}\ncatch (_a) {\n    ethersVerifyMessage = ethers_1.ethers.verifyMessage;\n    ethersHashMessage = ethers_1.ethers.hashMessage;\n    ethersGetAddress = ethers_1.ethers.getAddress;\n}\nexports.verifyMessage = ethersVerifyMessage;\nexports.hashMessage = ethersHashMessage;\nexports.getAddress = ethersGetAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L2V0aGVyc0NvbXBhdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUI7QUFDaEUsaUJBQWlCLG1CQUFPLENBQUMsNERBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL3Npd2UvZGlzdC9ldGhlcnNDb21wYXQuanM/ZGQyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QWRkcmVzcyA9IGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBleHBvcnRzLnZlcmlmeU1lc3NhZ2UgPSB2b2lkIDA7XG5jb25zdCBldGhlcnNfMSA9IHJlcXVpcmUoXCJldGhlcnNcIik7XG5sZXQgZXRoZXJzVmVyaWZ5TWVzc2FnZSA9IG51bGw7XG5sZXQgZXRoZXJzSGFzaE1lc3NhZ2UgPSBudWxsO1xubGV0IGV0aGVyc0dldEFkZHJlc3MgPSBudWxsO1xudHJ5IHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIHY2IGNvbXBhdGliaWxpdHkgaGFja1xuICAgIGV0aGVyc1ZlcmlmeU1lc3NhZ2UgPSBldGhlcnNfMS5ldGhlcnMudXRpbHMudmVyaWZ5TWVzc2FnZTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIHY2IGNvbXBhdGliaWxpdHkgaGFja1xuICAgIGV0aGVyc0hhc2hNZXNzYWdlID0gZXRoZXJzXzEuZXRoZXJzLnV0aWxzLmhhc2hNZXNzYWdlO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gdjYgY29tcGF0aWJpbGl0eSBoYWNrXG4gICAgZXRoZXJzR2V0QWRkcmVzcyA9IGV0aGVyc18xLmV0aGVycy51dGlscy5nZXRBZGRyZXNzO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgZXRoZXJzVmVyaWZ5TWVzc2FnZSA9IGV0aGVyc18xLmV0aGVycy52ZXJpZnlNZXNzYWdlO1xuICAgIGV0aGVyc0hhc2hNZXNzYWdlID0gZXRoZXJzXzEuZXRoZXJzLmhhc2hNZXNzYWdlO1xuICAgIGV0aGVyc0dldEFkZHJlc3MgPSBldGhlcnNfMS5ldGhlcnMuZ2V0QWRkcmVzcztcbn1cbmV4cG9ydHMudmVyaWZ5TWVzc2FnZSA9IGV0aGVyc1ZlcmlmeU1lc3NhZ2U7XG5leHBvcnRzLmhhc2hNZXNzYWdlID0gZXRoZXJzSGFzaE1lc3NhZ2U7XG5leHBvcnRzLmdldEFkZHJlc3MgPSBldGhlcnNHZXRBZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/siwe/dist/ethersCompat.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/siwe/dist/siwe.js":
/*!****************************************!*\
  !*** ./node_modules/siwe/dist/siwe.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./client */ \"(ssr)/./node_modules/siwe/dist/client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/siwe/dist/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/siwe/dist/utils.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L3Npd2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDBEQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx3REFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsd0RBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9zaXdlL2Rpc3Qvc2l3ZS5qcz8wYWNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2xpZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/siwe/dist/siwe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/siwe/dist/types.js":
/*!*****************************************!*\
  !*** ./node_modules/siwe/dist/types.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SiweErrorType = exports.SiweError = exports.VerifyOptsKeys = exports.VerifyParamsKeys = void 0;\nexports.VerifyParamsKeys = [\n    'signature',\n    'scheme',\n    'domain',\n    'nonce',\n    'time',\n];\nexports.VerifyOptsKeys = [\n    'provider',\n    'suppressExceptions',\n    'verificationFallback',\n];\n/**\n * Interface used to return errors in SiweResponses.\n */\nclass SiweError {\n    constructor(type, expected, received) {\n        this.type = type;\n        this.expected = expected;\n        this.received = received;\n    }\n}\nexports.SiweError = SiweError;\n/**\n * Possible message error types.\n */\nvar SiweErrorType;\n(function (SiweErrorType) {\n    /** `expirationTime` is present and in the past. */\n    SiweErrorType[\"EXPIRED_MESSAGE\"] = \"Expired message.\";\n    /** `domain` is not a valid authority or is empty. */\n    SiweErrorType[\"INVALID_DOMAIN\"] = \"Invalid domain.\";\n    /** `scheme` don't match the scheme provided for verification. */\n    SiweErrorType[\"SCHEME_MISMATCH\"] = \"Scheme does not match provided scheme for verification.\";\n    /** `domain` don't match the domain provided for verification. */\n    SiweErrorType[\"DOMAIN_MISMATCH\"] = \"Domain does not match provided domain for verification.\";\n    /** `nonce` don't match the nonce provided for verification. */\n    SiweErrorType[\"NONCE_MISMATCH\"] = \"Nonce does not match provided nonce for verification.\";\n    /** `address` does not conform to EIP-55 or is not a valid address. */\n    SiweErrorType[\"INVALID_ADDRESS\"] = \"Invalid address.\";\n    /** `uri` does not conform to RFC 3986. */\n    SiweErrorType[\"INVALID_URI\"] = \"URI does not conform to RFC 3986.\";\n    /** `nonce` is smaller then 8 characters or is not alphanumeric */\n    SiweErrorType[\"INVALID_NONCE\"] = \"Nonce size smaller then 8 characters or is not alphanumeric.\";\n    /** `notBefore` is present and in the future. */\n    SiweErrorType[\"NOT_YET_VALID_MESSAGE\"] = \"Message is not valid yet.\";\n    /** Signature doesn't match the address of the message. */\n    SiweErrorType[\"INVALID_SIGNATURE\"] = \"Signature does not match address of the message.\";\n    /** `expirationTime`, `notBefore` or `issuedAt` not complient to ISO-8601. */\n    SiweErrorType[\"INVALID_TIME_FORMAT\"] = \"Invalid time format.\";\n    /** `version` is not 1. */\n    SiweErrorType[\"INVALID_MESSAGE_VERSION\"] = \"Invalid message version.\";\n    /** Thrown when some required field is missing. */\n    SiweErrorType[\"UNABLE_TO_PARSE\"] = \"Unable to parse the message.\";\n})(SiweErrorType = exports.SiweErrorType || (exports.SiweErrorType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QjtBQUM3Rix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QyxxQkFBcUIsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXZ5LWxpdC1kZW1vLy4vbm9kZV9tb2R1bGVzL3Npd2UvZGlzdC90eXBlcy5qcz9iOWVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaXdlRXJyb3JUeXBlID0gZXhwb3J0cy5TaXdlRXJyb3IgPSBleHBvcnRzLlZlcmlmeU9wdHNLZXlzID0gZXhwb3J0cy5WZXJpZnlQYXJhbXNLZXlzID0gdm9pZCAwO1xuZXhwb3J0cy5WZXJpZnlQYXJhbXNLZXlzID0gW1xuICAgICdzaWduYXR1cmUnLFxuICAgICdzY2hlbWUnLFxuICAgICdkb21haW4nLFxuICAgICdub25jZScsXG4gICAgJ3RpbWUnLFxuXTtcbmV4cG9ydHMuVmVyaWZ5T3B0c0tleXMgPSBbXG4gICAgJ3Byb3ZpZGVyJyxcbiAgICAnc3VwcHJlc3NFeGNlcHRpb25zJyxcbiAgICAndmVyaWZpY2F0aW9uRmFsbGJhY2snLFxuXTtcbi8qKlxuICogSW50ZXJmYWNlIHVzZWQgdG8gcmV0dXJuIGVycm9ycyBpbiBTaXdlUmVzcG9uc2VzLlxuICovXG5jbGFzcyBTaXdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGV4cGVjdGVkLCByZWNlaXZlZCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSByZWNlaXZlZDtcbiAgICB9XG59XG5leHBvcnRzLlNpd2VFcnJvciA9IFNpd2VFcnJvcjtcbi8qKlxuICogUG9zc2libGUgbWVzc2FnZSBlcnJvciB0eXBlcy5cbiAqL1xudmFyIFNpd2VFcnJvclR5cGU7XG4oZnVuY3Rpb24gKFNpd2VFcnJvclR5cGUpIHtcbiAgICAvKiogYGV4cGlyYXRpb25UaW1lYCBpcyBwcmVzZW50IGFuZCBpbiB0aGUgcGFzdC4gKi9cbiAgICBTaXdlRXJyb3JUeXBlW1wiRVhQSVJFRF9NRVNTQUdFXCJdID0gXCJFeHBpcmVkIG1lc3NhZ2UuXCI7XG4gICAgLyoqIGBkb21haW5gIGlzIG5vdCBhIHZhbGlkIGF1dGhvcml0eSBvciBpcyBlbXB0eS4gKi9cbiAgICBTaXdlRXJyb3JUeXBlW1wiSU5WQUxJRF9ET01BSU5cIl0gPSBcIkludmFsaWQgZG9tYWluLlwiO1xuICAgIC8qKiBgc2NoZW1lYCBkb24ndCBtYXRjaCB0aGUgc2NoZW1lIHByb3ZpZGVkIGZvciB2ZXJpZmljYXRpb24uICovXG4gICAgU2l3ZUVycm9yVHlwZVtcIlNDSEVNRV9NSVNNQVRDSFwiXSA9IFwiU2NoZW1lIGRvZXMgbm90IG1hdGNoIHByb3ZpZGVkIHNjaGVtZSBmb3IgdmVyaWZpY2F0aW9uLlwiO1xuICAgIC8qKiBgZG9tYWluYCBkb24ndCBtYXRjaCB0aGUgZG9tYWluIHByb3ZpZGVkIGZvciB2ZXJpZmljYXRpb24uICovXG4gICAgU2l3ZUVycm9yVHlwZVtcIkRPTUFJTl9NSVNNQVRDSFwiXSA9IFwiRG9tYWluIGRvZXMgbm90IG1hdGNoIHByb3ZpZGVkIGRvbWFpbiBmb3IgdmVyaWZpY2F0aW9uLlwiO1xuICAgIC8qKiBgbm9uY2VgIGRvbid0IG1hdGNoIHRoZSBub25jZSBwcm92aWRlZCBmb3IgdmVyaWZpY2F0aW9uLiAqL1xuICAgIFNpd2VFcnJvclR5cGVbXCJOT05DRV9NSVNNQVRDSFwiXSA9IFwiTm9uY2UgZG9lcyBub3QgbWF0Y2ggcHJvdmlkZWQgbm9uY2UgZm9yIHZlcmlmaWNhdGlvbi5cIjtcbiAgICAvKiogYGFkZHJlc3NgIGRvZXMgbm90IGNvbmZvcm0gdG8gRUlQLTU1IG9yIGlzIG5vdCBhIHZhbGlkIGFkZHJlc3MuICovXG4gICAgU2l3ZUVycm9yVHlwZVtcIklOVkFMSURfQUREUkVTU1wiXSA9IFwiSW52YWxpZCBhZGRyZXNzLlwiO1xuICAgIC8qKiBgdXJpYCBkb2VzIG5vdCBjb25mb3JtIHRvIFJGQyAzOTg2LiAqL1xuICAgIFNpd2VFcnJvclR5cGVbXCJJTlZBTElEX1VSSVwiXSA9IFwiVVJJIGRvZXMgbm90IGNvbmZvcm0gdG8gUkZDIDM5ODYuXCI7XG4gICAgLyoqIGBub25jZWAgaXMgc21hbGxlciB0aGVuIDggY2hhcmFjdGVycyBvciBpcyBub3QgYWxwaGFudW1lcmljICovXG4gICAgU2l3ZUVycm9yVHlwZVtcIklOVkFMSURfTk9OQ0VcIl0gPSBcIk5vbmNlIHNpemUgc21hbGxlciB0aGVuIDggY2hhcmFjdGVycyBvciBpcyBub3QgYWxwaGFudW1lcmljLlwiO1xuICAgIC8qKiBgbm90QmVmb3JlYCBpcyBwcmVzZW50IGFuZCBpbiB0aGUgZnV0dXJlLiAqL1xuICAgIFNpd2VFcnJvclR5cGVbXCJOT1RfWUVUX1ZBTElEX01FU1NBR0VcIl0gPSBcIk1lc3NhZ2UgaXMgbm90IHZhbGlkIHlldC5cIjtcbiAgICAvKiogU2lnbmF0dXJlIGRvZXNuJ3QgbWF0Y2ggdGhlIGFkZHJlc3Mgb2YgdGhlIG1lc3NhZ2UuICovXG4gICAgU2l3ZUVycm9yVHlwZVtcIklOVkFMSURfU0lHTkFUVVJFXCJdID0gXCJTaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggYWRkcmVzcyBvZiB0aGUgbWVzc2FnZS5cIjtcbiAgICAvKiogYGV4cGlyYXRpb25UaW1lYCwgYG5vdEJlZm9yZWAgb3IgYGlzc3VlZEF0YCBub3QgY29tcGxpZW50IHRvIElTTy04NjAxLiAqL1xuICAgIFNpd2VFcnJvclR5cGVbXCJJTlZBTElEX1RJTUVfRk9STUFUXCJdID0gXCJJbnZhbGlkIHRpbWUgZm9ybWF0LlwiO1xuICAgIC8qKiBgdmVyc2lvbmAgaXMgbm90IDEuICovXG4gICAgU2l3ZUVycm9yVHlwZVtcIklOVkFMSURfTUVTU0FHRV9WRVJTSU9OXCJdID0gXCJJbnZhbGlkIG1lc3NhZ2UgdmVyc2lvbi5cIjtcbiAgICAvKiogVGhyb3duIHdoZW4gc29tZSByZXF1aXJlZCBmaWVsZCBpcyBtaXNzaW5nLiAqL1xuICAgIFNpd2VFcnJvclR5cGVbXCJVTkFCTEVfVE9fUEFSU0VcIl0gPSBcIlVuYWJsZSB0byBwYXJzZSB0aGUgbWVzc2FnZS5cIjtcbn0pKFNpd2VFcnJvclR5cGUgPSBleHBvcnRzLlNpd2VFcnJvclR5cGUgfHwgKGV4cG9ydHMuU2l3ZUVycm9yVHlwZSA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/siwe/dist/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/siwe/dist/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/siwe/dist/utils.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkInvalidKeys = exports.isValidISO8601Date = exports.generateNonce = exports.checkContractWalletSignature = void 0;\nconst random_1 = __webpack_require__(/*! @stablelib/random */ \"(ssr)/./node_modules/@stablelib/random/lib/random.js\");\n// @ts-expect-error -- ethers v6 compatibility hack\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.esm/index.js\");\nconst ethersCompat_1 = __webpack_require__(/*! ./ethersCompat */ \"(ssr)/./node_modules/siwe/dist/ethersCompat.js\");\nconst EIP1271_ABI = [\n    'function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)',\n];\nconst EIP1271_MAGICVALUE = '0x1626ba7e';\nconst ISO8601 = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;\n/**\n * This method calls the EIP-1271 method for Smart Contract wallets\n * @param message The EIP-4361 parsed message\n * @param provider Web3 provider able to perform a contract check (Web3/EthersJS).\n * @returns {Promise<boolean>} Checks for the smart contract (if it exists) if\n * the signature is valid for given address.\n */\nconst checkContractWalletSignature = (message, signature, provider) => __awaiter(void 0, void 0, void 0, function* () {\n    if (!provider) {\n        return false;\n    }\n    const walletContract = new ethers_1.Contract(message.address, EIP1271_ABI, provider);\n    const hashedMessage = (0, ethersCompat_1.hashMessage)(message.prepareMessage());\n    const res = yield walletContract.isValidSignature(hashedMessage, signature);\n    return res === EIP1271_MAGICVALUE;\n});\nexports.checkContractWalletSignature = checkContractWalletSignature;\n/**\n * This method leverages a native CSPRNG with support for both browser and Node.js\n * environments in order generate a cryptographically secure nonce for use in the\n * SiweMessage in order to prevent replay attacks.\n *\n * 96 bits has been chosen as a number to sufficiently balance size and security considerations\n * relative to the lifespan of it's usage.\n *\n * @returns cryptographically generated random nonce with 96 bits of entropy encoded with\n * an alphanumeric character set.\n */\nconst generateNonce = () => {\n    const nonce = (0, random_1.randomStringForEntropy)(96);\n    if (!nonce || nonce.length < 8) {\n        throw new Error('Error during nonce creation.');\n    }\n    return nonce;\n};\nexports.generateNonce = generateNonce;\n/**\n * This method matches the given date string against the ISO-8601 regex and also\n * performs checks if it's a valid date.\n * @param inputDate any string to be validated against ISO-8601\n * @returns boolean indicating if the providade date is valid and conformant to ISO-8601\n */\nconst isValidISO8601Date = (inputDate) => {\n    /* Split groups and make sure inputDate is in ISO8601 format */\n    const inputMatch = ISO8601.exec(inputDate);\n    /* if inputMatch is null the date is not ISO-8601 */\n    if (!inputDate) {\n        return false;\n    }\n    /* Creates a date object with input date to parse for invalid days e.g. Feb, 30 -> Mar, 01 */\n    const inputDateParsed = new Date(inputMatch.groups.date).toISOString();\n    /* Get groups from new parsed date to compare with the original input */\n    const parsedInputMatch = ISO8601.exec(inputDateParsed);\n    /* Compare remaining fields */\n    return inputMatch.groups.date === parsedInputMatch.groups.date;\n};\nexports.isValidISO8601Date = isValidISO8601Date;\nconst checkInvalidKeys = (obj, keys) => {\n    const invalidKeys = [];\n    Object.keys(obj).forEach(key => {\n        if (!keys.includes(key)) {\n            invalidKeys.push(key);\n        }\n    });\n    return invalidKeys;\n};\nexports.checkInvalidKeys = checkInvalidKeys;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2l3ZS9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxvQ0FBb0M7QUFDcEgsaUJBQWlCLG1CQUFPLENBQUMsK0VBQW1CO0FBQzVDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsNERBQVE7QUFDakMsdUJBQXVCLG1CQUFPLENBQUMsc0VBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml2eS1saXQtZGVtby8uL25vZGVfbW9kdWxlcy9zaXdlL2Rpc3QvdXRpbHMuanM/NzU1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja0ludmFsaWRLZXlzID0gZXhwb3J0cy5pc1ZhbGlkSVNPODYwMURhdGUgPSBleHBvcnRzLmdlbmVyYXRlTm9uY2UgPSBleHBvcnRzLmNoZWNrQ29udHJhY3RXYWxsZXRTaWduYXR1cmUgPSB2b2lkIDA7XG5jb25zdCByYW5kb21fMSA9IHJlcXVpcmUoXCJAc3RhYmxlbGliL3JhbmRvbVwiKTtcbi8vIEB0cy1leHBlY3QtZXJyb3IgLS0gZXRoZXJzIHY2IGNvbXBhdGliaWxpdHkgaGFja1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgZXRoZXJzQ29tcGF0XzEgPSByZXF1aXJlKFwiLi9ldGhlcnNDb21wYXRcIik7XG5jb25zdCBFSVAxMjcxX0FCSSA9IFtcbiAgICAnZnVuY3Rpb24gaXNWYWxpZFNpZ25hdHVyZShieXRlczMyIF9tZXNzYWdlLCBieXRlcyBfc2lnbmF0dXJlKSBwdWJsaWMgdmlldyByZXR1cm5zIChieXRlczQpJyxcbl07XG5jb25zdCBFSVAxMjcxX01BR0lDVkFMVUUgPSAnMHgxNjI2YmE3ZSc7XG5jb25zdCBJU084NjAxID0gL14oPzxkYXRlPlswLTldezR9LSgwWzEtOV18MVswMTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSkpW1R0XShbMDFdWzAtOV18MlswLTNdKTooWzAtNV1bMC05XSk6KFswLTVdWzAtOV18NjApKC5bMC05XSspPygoW1p6XSl8KFsrfC1dKFswMV1bMC05XXwyWzAtM10pOlswLTVdWzAtOV0pKSQvO1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgRUlQLTEyNzEgbWV0aG9kIGZvciBTbWFydCBDb250cmFjdCB3YWxsZXRzXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgRUlQLTQzNjEgcGFyc2VkIG1lc3NhZ2VcbiAqIEBwYXJhbSBwcm92aWRlciBXZWIzIHByb3ZpZGVyIGFibGUgdG8gcGVyZm9ybSBhIGNvbnRyYWN0IGNoZWNrIChXZWIzL0V0aGVyc0pTKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBDaGVja3MgZm9yIHRoZSBzbWFydCBjb250cmFjdCAoaWYgaXQgZXhpc3RzKSBpZlxuICogdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAqL1xuY29uc3QgY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZSA9IChtZXNzYWdlLCBzaWduYXR1cmUsIHByb3ZpZGVyKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0Q29udHJhY3QgPSBuZXcgZXRoZXJzXzEuQ29udHJhY3QobWVzc2FnZS5hZGRyZXNzLCBFSVAxMjcxX0FCSSwgcHJvdmlkZXIpO1xuICAgIGNvbnN0IGhhc2hlZE1lc3NhZ2UgPSAoMCwgZXRoZXJzQ29tcGF0XzEuaGFzaE1lc3NhZ2UpKG1lc3NhZ2UucHJlcGFyZU1lc3NhZ2UoKSk7XG4gICAgY29uc3QgcmVzID0geWllbGQgd2FsbGV0Q29udHJhY3QuaXNWYWxpZFNpZ25hdHVyZShoYXNoZWRNZXNzYWdlLCBzaWduYXR1cmUpO1xuICAgIHJldHVybiByZXMgPT09IEVJUDEyNzFfTUFHSUNWQUxVRTtcbn0pO1xuZXhwb3J0cy5jaGVja0NvbnRyYWN0V2FsbGV0U2lnbmF0dXJlID0gY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZTtcbi8qKlxuICogVGhpcyBtZXRob2QgbGV2ZXJhZ2VzIGEgbmF0aXZlIENTUFJORyB3aXRoIHN1cHBvcnQgZm9yIGJvdGggYnJvd3NlciBhbmQgTm9kZS5qc1xuICogZW52aXJvbm1lbnRzIGluIG9yZGVyIGdlbmVyYXRlIGEgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIG5vbmNlIGZvciB1c2UgaW4gdGhlXG4gKiBTaXdlTWVzc2FnZSBpbiBvcmRlciB0byBwcmV2ZW50IHJlcGxheSBhdHRhY2tzLlxuICpcbiAqIDk2IGJpdHMgaGFzIGJlZW4gY2hvc2VuIGFzIGEgbnVtYmVyIHRvIHN1ZmZpY2llbnRseSBiYWxhbmNlIHNpemUgYW5kIHNlY3VyaXR5IGNvbnNpZGVyYXRpb25zXG4gKiByZWxhdGl2ZSB0byB0aGUgbGlmZXNwYW4gb2YgaXQncyB1c2FnZS5cbiAqXG4gKiBAcmV0dXJucyBjcnlwdG9ncmFwaGljYWxseSBnZW5lcmF0ZWQgcmFuZG9tIG5vbmNlIHdpdGggOTYgYml0cyBvZiBlbnRyb3B5IGVuY29kZWQgd2l0aFxuICogYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBzZXQuXG4gKi9cbmNvbnN0IGdlbmVyYXRlTm9uY2UgPSAoKSA9PiB7XG4gICAgY29uc3Qgbm9uY2UgPSAoMCwgcmFuZG9tXzEucmFuZG9tU3RyaW5nRm9yRW50cm9weSkoOTYpO1xuICAgIGlmICghbm9uY2UgfHwgbm9uY2UubGVuZ3RoIDwgOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGR1cmluZyBub25jZSBjcmVhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vbmNlO1xufTtcbmV4cG9ydHMuZ2VuZXJhdGVOb25jZSA9IGdlbmVyYXRlTm9uY2U7XG4vKipcbiAqIFRoaXMgbWV0aG9kIG1hdGNoZXMgdGhlIGdpdmVuIGRhdGUgc3RyaW5nIGFnYWluc3QgdGhlIElTTy04NjAxIHJlZ2V4IGFuZCBhbHNvXG4gKiBwZXJmb3JtcyBjaGVja3MgaWYgaXQncyBhIHZhbGlkIGRhdGUuXG4gKiBAcGFyYW0gaW5wdXREYXRlIGFueSBzdHJpbmcgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgSVNPLTg2MDFcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgcHJvdmlkYWRlIGRhdGUgaXMgdmFsaWQgYW5kIGNvbmZvcm1hbnQgdG8gSVNPLTg2MDFcbiAqL1xuY29uc3QgaXNWYWxpZElTTzg2MDFEYXRlID0gKGlucHV0RGF0ZSkgPT4ge1xuICAgIC8qIFNwbGl0IGdyb3VwcyBhbmQgbWFrZSBzdXJlIGlucHV0RGF0ZSBpcyBpbiBJU084NjAxIGZvcm1hdCAqL1xuICAgIGNvbnN0IGlucHV0TWF0Y2ggPSBJU084NjAxLmV4ZWMoaW5wdXREYXRlKTtcbiAgICAvKiBpZiBpbnB1dE1hdGNoIGlzIG51bGwgdGhlIGRhdGUgaXMgbm90IElTTy04NjAxICovXG4gICAgaWYgKCFpbnB1dERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBDcmVhdGVzIGEgZGF0ZSBvYmplY3Qgd2l0aCBpbnB1dCBkYXRlIHRvIHBhcnNlIGZvciBpbnZhbGlkIGRheXMgZS5nLiBGZWIsIDMwIC0+IE1hciwgMDEgKi9cbiAgICBjb25zdCBpbnB1dERhdGVQYXJzZWQgPSBuZXcgRGF0ZShpbnB1dE1hdGNoLmdyb3Vwcy5kYXRlKS50b0lTT1N0cmluZygpO1xuICAgIC8qIEdldCBncm91cHMgZnJvbSBuZXcgcGFyc2VkIGRhdGUgdG8gY29tcGFyZSB3aXRoIHRoZSBvcmlnaW5hbCBpbnB1dCAqL1xuICAgIGNvbnN0IHBhcnNlZElucHV0TWF0Y2ggPSBJU084NjAxLmV4ZWMoaW5wdXREYXRlUGFyc2VkKTtcbiAgICAvKiBDb21wYXJlIHJlbWFpbmluZyBmaWVsZHMgKi9cbiAgICByZXR1cm4gaW5wdXRNYXRjaC5ncm91cHMuZGF0ZSA9PT0gcGFyc2VkSW5wdXRNYXRjaC5ncm91cHMuZGF0ZTtcbn07XG5leHBvcnRzLmlzVmFsaWRJU084NjAxRGF0ZSA9IGlzVmFsaWRJU084NjAxRGF0ZTtcbmNvbnN0IGNoZWNrSW52YWxpZEtleXMgPSAob2JqLCBrZXlzKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZEtleXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGludmFsaWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbnZhbGlkS2V5cztcbn07XG5leHBvcnRzLmNoZWNrSW52YWxpZEtleXMgPSBjaGVja0ludmFsaWRLZXlzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/siwe/dist/utils.js\n");

/***/ })

};
;